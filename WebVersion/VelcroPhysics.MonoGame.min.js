Bridge.assembly("VelcroPhysics.MonoGame",function($asm,globals){"use strict";Bridge.define("VelcroPhysics.Collision.AABBHelper",{statics:{methods:{ComputeEdgeAABB:function(start,end,transform,aabb){var v1=VelcroPhysics.Utilities.MathUtils.Mul$5(transform,start),v2=VelcroPhysics.Utilities.MathUtils.Mul$5(transform,end),r;aabb.v.LowerBound=Microsoft.Xna.Framework.Vector2.Min(v1.$clone(),v2.$clone());aabb.v.UpperBound=Microsoft.Xna.Framework.Vector2.Max(v1.$clone(),v2.$clone());r=new Microsoft.Xna.Framework.Vector2.$ctor2(VelcroPhysics.Settings.PolygonRadius,VelcroPhysics.Settings.PolygonRadius);aabb.v.LowerBound=Microsoft.Xna.Framework.Vector2.op_Subtraction(aabb.v.LowerBound.$clone(),r.$clone());aabb.v.UpperBound=Microsoft.Xna.Framework.Vector2.op_Addition(aabb.v.UpperBound.$clone(),r.$clone())},ComputeCircleAABB:function(pos,radius,transform,aabb){var p=Microsoft.Xna.Framework.Vector2.op_Addition(transform.v.p.$clone(),VelcroPhysics.Utilities.MathUtils.Mul$2(transform.v.q.$clone(),pos.v.$clone()));aabb.v.LowerBound=new Microsoft.Xna.Framework.Vector2.$ctor2(p.X-radius,p.Y-radius);aabb.v.UpperBound=new Microsoft.Xna.Framework.Vector2.$ctor2(p.X+radius,p.Y+radius)},ComputePolygonAABB:function(vertices,transform,aabb){for(var v,r,lower=VelcroPhysics.Utilities.MathUtils.Mul$4(transform,vertices.getItem(0).$clone()),upper=lower.$clone(),i=1;i<vertices.Count;i=i+1|0)v=VelcroPhysics.Utilities.MathUtils.Mul$4(transform,vertices.getItem(i).$clone()),lower=Microsoft.Xna.Framework.Vector2.Min(lower.$clone(),v.$clone()),upper=Microsoft.Xna.Framework.Vector2.Max(upper.$clone(),v.$clone());r=new Microsoft.Xna.Framework.Vector2.$ctor2(VelcroPhysics.Settings.PolygonRadius,VelcroPhysics.Settings.PolygonRadius);aabb.v.LowerBound=Microsoft.Xna.Framework.Vector2.op_Subtraction(lower.$clone(),r.$clone());aabb.v.UpperBound=Microsoft.Xna.Framework.Vector2.op_Addition(upper.$clone(),r.$clone())}}}});Bridge.define("VelcroPhysics.Collision.Broadphase.DynamicTree$1",function(T){return{statics:{fields:{NullNode:0},ctors:{init:function(){this.NullNode=-1}}},fields:{_freeList:0,_nodeCapacity:0,_nodeCount:0,_nodes:null,_queryStack:null,_raycastStack:null,_root:0},props:{Height:{get:function(){return this._root===VelcroPhysics.Collision.Broadphase.DynamicTree$1(T).NullNode?0:this._nodes[this._root].Height}},AreaRatio:{get:function(){var i,node;if(this._root===VelcroPhysics.Collision.Broadphase.DynamicTree$1(T).NullNode)return 0;var root=this._nodes[this._root],rootArea=root.AABB.Perimeter,totalArea=0;for(i=0;i<this._nodeCapacity;i=i+1|0)(node=this._nodes[i],node.Height<0)||(totalArea+=node.AABB.Perimeter);return totalArea/rootArea}},MaxBalance:{get:function(){for(var node,maxBalance=0,i=0;i<this._nodeCapacity;i=i+1|0)if(node=this._nodes[i],!(node.Height<=1)){System.Diagnostics.Debug.Assert(node.IsLeaf()===!1);var child1=node.Child1,child2=node.Child2,balance=Math.abs(this._nodes[child2].Height-this._nodes[child1].Height|0);maxBalance=Math.max(maxBalance,balance)}return maxBalance}}},ctors:{init:function(){this._queryStack=new(System.Collections.Generic.Stack$1(System.Int32).$ctor2)(256);this._raycastStack=new(System.Collections.Generic.Stack$1(System.Int32).$ctor2)(256)},ctor:function(){this.$initialize();this._root=VelcroPhysics.Collision.Broadphase.DynamicTree$1(T).NullNode;this._nodeCapacity=16;this._nodeCount=0;this._nodes=System.Array.init(this._nodeCapacity,null,VelcroPhysics.Collision.Broadphase.TreeNode$1(T));for(var i=0;i<(this._nodeCapacity-1|0);i=i+1|0)this._nodes[i]=new(VelcroPhysics.Collision.Broadphase.TreeNode$1(T)),this._nodes[i].ParentOrNext=i+1|0,this._nodes[i].Height=1;this._nodes[this._nodeCapacity-1|0]=new(VelcroPhysics.Collision.Broadphase.TreeNode$1(T));this._nodes[this._nodeCapacity-1|0].ParentOrNext=VelcroPhysics.Collision.Broadphase.DynamicTree$1(T).NullNode;this._nodes[this._nodeCapacity-1|0].Height=1;this._freeList=0}},methods:{AddProxy:function(aabb,userData){var proxyId=this.AllocateNode(),r=new Microsoft.Xna.Framework.Vector2.$ctor2(VelcroPhysics.Settings.AABBExtension,VelcroPhysics.Settings.AABBExtension);return this._nodes[proxyId].AABB.LowerBound=Microsoft.Xna.Framework.Vector2.op_Subtraction(aabb.v.LowerBound.$clone(),r.$clone()),this._nodes[proxyId].AABB.UpperBound=Microsoft.Xna.Framework.Vector2.op_Addition(aabb.v.UpperBound.$clone(),r.$clone()),this._nodes[proxyId].UserData=userData,this._nodes[proxyId].Height=0,this.InsertLeaf(proxyId),proxyId},RemoveProxy:function(proxyId){System.Diagnostics.Debug.Assert(0<=proxyId&&proxyId<this._nodeCapacity);System.Diagnostics.Debug.Assert(this._nodes[proxyId].IsLeaf());this.RemoveLeaf(proxyId);this.FreeNode(proxyId)},MoveProxy:function(proxyId,aabb,displacement){var b,r,d;return(System.Diagnostics.Debug.Assert(0<=proxyId&&proxyId<this._nodeCapacity),System.Diagnostics.Debug.Assert(this._nodes[proxyId].IsLeaf()),this._nodes[proxyId].AABB.Contains$1(aabb))?!1:(this.RemoveLeaf(proxyId),b=aabb.v.$clone(),r=new Microsoft.Xna.Framework.Vector2.$ctor2(VelcroPhysics.Settings.AABBExtension,VelcroPhysics.Settings.AABBExtension),b.LowerBound=Microsoft.Xna.Framework.Vector2.op_Subtraction(b.LowerBound.$clone(),r.$clone()),b.UpperBound=Microsoft.Xna.Framework.Vector2.op_Addition(b.UpperBound.$clone(),r.$clone()),d=Microsoft.Xna.Framework.Vector2.op_Multiply$2(VelcroPhysics.Settings.AABBMultiplier,displacement.$clone()),d.X<0?b.LowerBound.X+=d.X:b.UpperBound.X+=d.X,d.Y<0?b.LowerBound.Y+=d.Y:b.UpperBound.Y+=d.Y,this._nodes[proxyId].AABB=b.$clone(),this.InsertLeaf(proxyId),!0)},GetUserData:function(proxyId){return System.Diagnostics.Debug.Assert(0<=proxyId&&proxyId<this._nodeCapacity),this._nodes[proxyId].UserData},GetFatAABB:function(proxyId,fatAABB){System.Diagnostics.Debug.Assert(0<=proxyId&&proxyId<this._nodeCapacity);fatAABB.v=this._nodes[proxyId].AABB.$clone()},Query:function(callback,aabb){var nodeId,node,proceed;for(this._queryStack.Clear(),this._queryStack.Push(this._root);this._queryStack.Count>0;)if((nodeId=this._queryStack.Pop(),nodeId!==VelcroPhysics.Collision.Broadphase.DynamicTree$1(T).NullNode)&&(node=this._nodes[nodeId],VelcroPhysics.Shared.AABB.TestOverlap(Bridge.ref(node,"AABB"),aabb)))if(node.IsLeaf()){if(proceed=callback(nodeId),proceed===!1)return}else this._queryStack.Push(node.Child1),this._queryStack.Push(node.Child2)},RayCast:function(callback,input){var p1={v:input.v.Point1.$clone()},p2=input.v.Point2.$clone(),r=Microsoft.Xna.Framework.Vector2.op_Subtraction(p2.$clone(),p1.v.$clone()),nodeId,node,subInput,value,t1;System.Diagnostics.Debug.Assert(r.LengthSquared()>0);r.Normalize();var absV=VelcroPhysics.Utilities.MathUtils.Abs(new Microsoft.Xna.Framework.Vector2.$ctor2(-r.Y,r.X)),maxFraction=input.v.MaxFraction,segmentAABB={v:new VelcroPhysics.Shared.AABB.ctor},t={v:Microsoft.Xna.Framework.Vector2.op_Addition(p1.v.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(maxFraction,Microsoft.Xna.Framework.Vector2.op_Subtraction(p2.$clone(),p1.v.$clone())))};for(Microsoft.Xna.Framework.Vector2.Min$1(p1,t,Bridge.ref(segmentAABB.v,"LowerBound")),Microsoft.Xna.Framework.Vector2.Max$1(p1,t,Bridge.ref(segmentAABB.v,"UpperBound")),this._raycastStack.Clear(),this._raycastStack.Push(this._root);this._raycastStack.Count>0;)if((nodeId=this._raycastStack.Pop(),nodeId!==VelcroPhysics.Collision.Broadphase.DynamicTree$1(T).NullNode)&&(node=this._nodes[nodeId],VelcroPhysics.Shared.AABB.TestOverlap(Bridge.ref(node,"AABB"),segmentAABB)!==!1)){var c=node.AABB.Center.$clone(),h=node.AABB.Extents.$clone(),separation=Math.abs(Microsoft.Xna.Framework.Vector2.Dot(new Microsoft.Xna.Framework.Vector2.$ctor2(-r.Y,r.X),Microsoft.Xna.Framework.Vector2.op_Subtraction(p1.v.$clone(),c.$clone())))-Microsoft.Xna.Framework.Vector2.Dot(absV.$clone(),h.$clone());if(!(separation>0))if(node.IsLeaf()){if(subInput=new VelcroPhysics.Collision.RayCast.RayCastInput,subInput.Point1=input.v.Point1.$clone(),subInput.Point2=input.v.Point2.$clone(),subInput.MaxFraction=maxFraction,value=callback(subInput.$clone(),nodeId),value===0)return;value>0&&(maxFraction=value,t1=Microsoft.Xna.Framework.Vector2.op_Addition(p1.v.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(maxFraction,Microsoft.Xna.Framework.Vector2.op_Subtraction(p2.$clone(),p1.v.$clone()))),segmentAABB.v.LowerBound=Microsoft.Xna.Framework.Vector2.Min(p1.v.$clone(),t1.$clone()),segmentAABB.v.UpperBound=Microsoft.Xna.Framework.Vector2.Max(p1.v.$clone(),t1.$clone()))}else this._raycastStack.Push(node.Child1),this._raycastStack.Push(node.Child2)}},AllocateNode:function(){var oldNodes,i,nodeId;if(this._freeList===VelcroPhysics.Collision.Broadphase.DynamicTree$1(T).NullNode){for(System.Diagnostics.Debug.Assert(this._nodeCount===this._nodeCapacity),oldNodes=this._nodes,this._nodeCapacity=Bridge.Int.mul(this._nodeCapacity,2),this._nodes=System.Array.init(this._nodeCapacity,null,VelcroPhysics.Collision.Broadphase.TreeNode$1(T)),System.Array.copy(oldNodes,0,this._nodes,0,this._nodeCount),i=this._nodeCount;i<(this._nodeCapacity-1|0);i=i+1|0)this._nodes[i]=new(VelcroPhysics.Collision.Broadphase.TreeNode$1(T)),this._nodes[i].ParentOrNext=i+1|0,this._nodes[i].Height=-1;this._nodes[this._nodeCapacity-1|0]=new(VelcroPhysics.Collision.Broadphase.TreeNode$1(T));this._nodes[this._nodeCapacity-1|0].ParentOrNext=VelcroPhysics.Collision.Broadphase.DynamicTree$1(T).NullNode;this._nodes[this._nodeCapacity-1|0].Height=-1;this._freeList=this._nodeCount}return nodeId=this._freeList,this._freeList=this._nodes[nodeId].ParentOrNext,this._nodes[nodeId].ParentOrNext=VelcroPhysics.Collision.Broadphase.DynamicTree$1(T).NullNode,this._nodes[nodeId].Child1=VelcroPhysics.Collision.Broadphase.DynamicTree$1(T).NullNode,this._nodes[nodeId].Child2=VelcroPhysics.Collision.Broadphase.DynamicTree$1(T).NullNode,this._nodes[nodeId].Height=0,this._nodes[nodeId].UserData=Bridge.getDefaultValue(T),this._nodeCount=this._nodeCount+1|0,nodeId},FreeNode:function(nodeId){System.Diagnostics.Debug.Assert(0<=nodeId&&nodeId<this._nodeCapacity);System.Diagnostics.Debug.Assert(0<this._nodeCount);this._nodes[nodeId].ParentOrNext=this._freeList;this._nodes[nodeId].Height=-1;this._freeList=nodeId;this._nodeCount=this._nodeCount-1|0},InsertLeaf:function(leaf){var leafAABB,index,aabb,aabb1,oldArea,newArea,cost2,aabb2,aabb3,oldArea1,newArea1,child11,child21;if(this._root===VelcroPhysics.Collision.Broadphase.DynamicTree$1(T).NullNode){this._root=leaf;this._nodes[this._root].ParentOrNext=VelcroPhysics.Collision.Broadphase.DynamicTree$1(T).NullNode;return}for(leafAABB={v:this._nodes[leaf].AABB.$clone()},index=this._root;this._nodes[index].IsLeaf()===!1;){var child1=this._nodes[index].Child1,child2=this._nodes[index].Child2,area=this._nodes[index].AABB.Perimeter,combinedAABB=new VelcroPhysics.Shared.AABB.ctor;combinedAABB.Combine$1(Bridge.ref(this._nodes[index],"AABB"),leafAABB);var combinedArea=combinedAABB.Perimeter,cost=2*combinedArea,inheritanceCost=2*(combinedArea-area),cost1;if(this._nodes[child1].IsLeaf()?(aabb=new VelcroPhysics.Shared.AABB.ctor,aabb.Combine$1(leafAABB,Bridge.ref(this._nodes[child1],"AABB")),cost1=aabb.Perimeter+inheritanceCost):(aabb1=new VelcroPhysics.Shared.AABB.ctor,aabb1.Combine$1(leafAABB,Bridge.ref(this._nodes[child1],"AABB")),oldArea=this._nodes[child1].AABB.Perimeter,newArea=aabb1.Perimeter,cost1=newArea-oldArea+inheritanceCost),this._nodes[child2].IsLeaf()?(aabb2=new VelcroPhysics.Shared.AABB.ctor,aabb2.Combine$1(leafAABB,Bridge.ref(this._nodes[child2],"AABB")),cost2=aabb2.Perimeter+inheritanceCost):(aabb3=new VelcroPhysics.Shared.AABB.ctor,aabb3.Combine$1(leafAABB,Bridge.ref(this._nodes[child2],"AABB")),oldArea1=this._nodes[child2].AABB.Perimeter,newArea1=aabb3.Perimeter,cost2=newArea1-oldArea1+inheritanceCost),cost<cost1&&cost1<cost2)break;index=cost1<cost2?child1:child2}var sibling=index,oldParent=this._nodes[sibling].ParentOrNext,newParent=this.AllocateNode();for(this._nodes[newParent].ParentOrNext=oldParent,this._nodes[newParent].UserData=Bridge.getDefaultValue(T),this._nodes[newParent].AABB.Combine$1(leafAABB,Bridge.ref(this._nodes[sibling],"AABB")),this._nodes[newParent].Height=this._nodes[sibling].Height+1|0,oldParent!==VelcroPhysics.Collision.Broadphase.DynamicTree$1(T).NullNode?(this._nodes[oldParent].Child1===sibling?this._nodes[oldParent].Child1=newParent:this._nodes[oldParent].Child2=newParent,this._nodes[newParent].Child1=sibling,this._nodes[newParent].Child2=leaf,this._nodes[sibling].ParentOrNext=newParent,this._nodes[leaf].ParentOrNext=newParent):(this._nodes[newParent].Child1=sibling,this._nodes[newParent].Child2=leaf,this._nodes[sibling].ParentOrNext=newParent,this._nodes[leaf].ParentOrNext=newParent,this._root=newParent),index=this._nodes[leaf].ParentOrNext;index!==VelcroPhysics.Collision.Broadphase.DynamicTree$1(T).NullNode;)index=this.Balance(index),child11=this._nodes[index].Child1,child21=this._nodes[index].Child2,System.Diagnostics.Debug.Assert(child11!==VelcroPhysics.Collision.Broadphase.DynamicTree$1(T).NullNode),System.Diagnostics.Debug.Assert(child21!==VelcroPhysics.Collision.Broadphase.DynamicTree$1(T).NullNode),this._nodes[index].Height=1+Math.max(this._nodes[child11].Height,this._nodes[child21].Height)|0,this._nodes[index].AABB.Combine$1(Bridge.ref(this._nodes[child11],"AABB"),Bridge.ref(this._nodes[child21],"AABB")),index=this._nodes[index].ParentOrNext},RemoveLeaf:function(leaf){var parent,grandParent,sibling,index,child1,child2;if(leaf===this._root){this._root=VelcroPhysics.Collision.Broadphase.DynamicTree$1(T).NullNode;return}if(parent=this._nodes[leaf].ParentOrNext,grandParent=this._nodes[parent].ParentOrNext,sibling=this._nodes[parent].Child1===leaf?this._nodes[parent].Child2:this._nodes[parent].Child1,grandParent!==VelcroPhysics.Collision.Broadphase.DynamicTree$1(T).NullNode)for(this._nodes[grandParent].Child1===parent?this._nodes[grandParent].Child1=sibling:this._nodes[grandParent].Child2=sibling,this._nodes[sibling].ParentOrNext=grandParent,this.FreeNode(parent),index=grandParent;index!==VelcroPhysics.Collision.Broadphase.DynamicTree$1(T).NullNode;)index=this.Balance(index),child1=this._nodes[index].Child1,child2=this._nodes[index].Child2,this._nodes[index].AABB.Combine$1(Bridge.ref(this._nodes[child1],"AABB"),Bridge.ref(this._nodes[child2],"AABB")),this._nodes[index].Height=1+Math.max(this._nodes[child1].Height,this._nodes[child2].Height)|0,index=this._nodes[index].ParentOrNext;else this._root=sibling,this._nodes[sibling].ParentOrNext=VelcroPhysics.Collision.Broadphase.DynamicTree$1(T).NullNode,this.FreeNode(parent)},Balance:function(iA){var A,iB,iC;if(System.Diagnostics.Debug.Assert(iA!==VelcroPhysics.Collision.Broadphase.DynamicTree$1(T).NullNode),A=this._nodes[iA],A.IsLeaf()||A.Height<2)return iA;iB=A.Child1;iC=A.Child2;System.Diagnostics.Debug.Assert(0<=iB&&iB<this._nodeCapacity);System.Diagnostics.Debug.Assert(0<=iC&&iC<this._nodeCapacity);var B=this._nodes[iB],C=this._nodes[iC],balance=C.Height-B.Height|0;if(balance>1){var iF=C.Child1,iG=C.Child2,F=this._nodes[iF],G=this._nodes[iG];return System.Diagnostics.Debug.Assert(0<=iF&&iF<this._nodeCapacity),System.Diagnostics.Debug.Assert(0<=iG&&iG<this._nodeCapacity),C.Child1=iA,C.ParentOrNext=A.ParentOrNext,A.ParentOrNext=iC,C.ParentOrNext!==VelcroPhysics.Collision.Broadphase.DynamicTree$1(T).NullNode?this._nodes[C.ParentOrNext].Child1===iA?this._nodes[C.ParentOrNext].Child1=iC:(System.Diagnostics.Debug.Assert(this._nodes[C.ParentOrNext].Child2===iA),this._nodes[C.ParentOrNext].Child2=iC):this._root=iC,F.Height>G.Height?(C.Child2=iF,A.Child2=iG,G.ParentOrNext=iA,A.AABB.Combine$1(Bridge.ref(B,"AABB"),Bridge.ref(G,"AABB")),C.AABB.Combine$1(Bridge.ref(A,"AABB"),Bridge.ref(F,"AABB")),A.Height=1+Math.max(B.Height,G.Height)|0,C.Height=1+Math.max(A.Height,F.Height)|0):(C.Child2=iG,A.Child2=iF,F.ParentOrNext=iA,A.AABB.Combine$1(Bridge.ref(B,"AABB"),Bridge.ref(F,"AABB")),C.AABB.Combine$1(Bridge.ref(A,"AABB"),Bridge.ref(G,"AABB")),A.Height=1+Math.max(B.Height,F.Height)|0,C.Height=1+Math.max(A.Height,G.Height)|0),iC}if(balance<-1){var iD=B.Child1,iE=B.Child2,D=this._nodes[iD],E=this._nodes[iE];return System.Diagnostics.Debug.Assert(0<=iD&&iD<this._nodeCapacity),System.Diagnostics.Debug.Assert(0<=iE&&iE<this._nodeCapacity),B.Child1=iA,B.ParentOrNext=A.ParentOrNext,A.ParentOrNext=iB,B.ParentOrNext!==VelcroPhysics.Collision.Broadphase.DynamicTree$1(T).NullNode?this._nodes[B.ParentOrNext].Child1===iA?this._nodes[B.ParentOrNext].Child1=iB:(System.Diagnostics.Debug.Assert(this._nodes[B.ParentOrNext].Child2===iA),this._nodes[B.ParentOrNext].Child2=iB):this._root=iB,D.Height>E.Height?(B.Child2=iD,A.Child1=iE,E.ParentOrNext=iA,A.AABB.Combine$1(Bridge.ref(C,"AABB"),Bridge.ref(E,"AABB")),B.AABB.Combine$1(Bridge.ref(A,"AABB"),Bridge.ref(D,"AABB")),A.Height=1+Math.max(C.Height,E.Height)|0,B.Height=1+Math.max(A.Height,D.Height)|0):(B.Child2=iE,A.Child1=iD,D.ParentOrNext=iA,A.AABB.Combine$1(Bridge.ref(C,"AABB"),Bridge.ref(D,"AABB")),B.AABB.Combine$1(Bridge.ref(A,"AABB"),Bridge.ref(E,"AABB")),A.Height=1+Math.max(C.Height,D.Height)|0,B.Height=1+Math.max(A.Height,E.Height)|0),iB}return iA},ComputeHeight$1:function(nodeId){var node,height1,height2;return(System.Diagnostics.Debug.Assert(0<=nodeId&&nodeId<this._nodeCapacity),node=this._nodes[nodeId],node.IsLeaf())?0:(height1=this.ComputeHeight$1(node.Child1),height2=this.ComputeHeight$1(node.Child2),1+Math.max(height1,height2)|0)},ComputeHeight:function(){return this.ComputeHeight$1(this._root)},ValidateStructure:function(index){if(index!==VelcroPhysics.Collision.Broadphase.DynamicTree$1(T).NullNode){index===this._root&&System.Diagnostics.Debug.Assert(this._nodes[index].ParentOrNext===VelcroPhysics.Collision.Broadphase.DynamicTree$1(T).NullNode);var node=this._nodes[index],child1=node.Child1,child2=node.Child2;if(node.IsLeaf()){System.Diagnostics.Debug.Assert(child1===VelcroPhysics.Collision.Broadphase.DynamicTree$1(T).NullNode);System.Diagnostics.Debug.Assert(child2===VelcroPhysics.Collision.Broadphase.DynamicTree$1(T).NullNode);System.Diagnostics.Debug.Assert(node.Height===0);return}System.Diagnostics.Debug.Assert(0<=child1&&child1<this._nodeCapacity);System.Diagnostics.Debug.Assert(0<=child2&&child2<this._nodeCapacity);System.Diagnostics.Debug.Assert(this._nodes[child1].ParentOrNext===index);System.Diagnostics.Debug.Assert(this._nodes[child2].ParentOrNext===index);this.ValidateStructure(child1);this.ValidateStructure(child2)}},ValidateMetrics:function(index){var AABB;if(index!==VelcroPhysics.Collision.Broadphase.DynamicTree$1(T).NullNode){var node=this._nodes[index],child1=node.Child1,child2=node.Child2;if(node.IsLeaf()){System.Diagnostics.Debug.Assert(child1===VelcroPhysics.Collision.Broadphase.DynamicTree$1(T).NullNode);System.Diagnostics.Debug.Assert(child2===VelcroPhysics.Collision.Broadphase.DynamicTree$1(T).NullNode);System.Diagnostics.Debug.Assert(node.Height===0);return}System.Diagnostics.Debug.Assert(0<=child1&&child1<this._nodeCapacity);System.Diagnostics.Debug.Assert(0<=child2&&child2<this._nodeCapacity);var height1=this._nodes[child1].Height,height2=this._nodes[child2].Height,height=1+Math.max(height1,height2)|0;System.Diagnostics.Debug.Assert(node.Height===height);AABB=new VelcroPhysics.Shared.AABB.ctor;AABB.Combine$1(Bridge.ref(this._nodes[child1],"AABB"),Bridge.ref(this._nodes[child2],"AABB"));System.Diagnostics.Debug.Assert(Microsoft.Xna.Framework.Vector2.op_Equality(AABB.LowerBound.$clone(),node.AABB.LowerBound.$clone()));System.Diagnostics.Debug.Assert(Microsoft.Xna.Framework.Vector2.op_Equality(AABB.UpperBound.$clone(),node.AABB.UpperBound.$clone()));this.ValidateMetrics(child1);this.ValidateMetrics(child2)}},Validate:function(){this.ValidateStructure(this._root);this.ValidateMetrics(this._root);for(var freeCount=0,freeIndex=this._freeList;freeIndex!==VelcroPhysics.Collision.Broadphase.DynamicTree$1(T).NullNode;)System.Diagnostics.Debug.Assert(0<=freeIndex&&freeIndex<this._nodeCapacity),freeIndex=this._nodes[freeIndex].ParentOrNext,freeCount=freeCount+1|0;System.Diagnostics.Debug.Assert(this.Height===this.ComputeHeight());System.Diagnostics.Debug.Assert((this._nodeCount+freeCount|0)===this._nodeCapacity)},RebuildBottomUp:function(){for(var i1,AABBi,j,AABBj,b,cost,nodes=System.Array.init(new Int32Array(this._nodeCount),System.Int32),count=0,i=0;i<this._nodeCapacity;i=i+1|0)this._nodes[i].Height<0||(this._nodes[i].IsLeaf()?(this._nodes[i].ParentOrNext=VelcroPhysics.Collision.Broadphase.DynamicTree$1(T).NullNode,nodes[count]=i,count=count+1|0):this.FreeNode(i));while(count>1){var minCost=VelcroPhysics.Settings.MaxFloat,iMin=-1,jMin=-1;for(i1=0;i1<count;i1=i1+1|0)for(AABBi={v:this._nodes[nodes[i1]].AABB.$clone()},j=i1+1|0;j<count;j=j+1|0)AABBj={v:this._nodes[nodes[j]].AABB.$clone()},b=new VelcroPhysics.Shared.AABB.ctor,b.Combine$1(AABBi,AABBj),cost=b.Perimeter,cost<minCost&&(iMin=i1,jMin=j,minCost=cost);var index1=nodes[iMin],index2=nodes[jMin],child1=this._nodes[index1],child2=this._nodes[index2],parentIndex=this.AllocateNode(),parent=this._nodes[parentIndex];parent.Child1=index1;parent.Child2=index2;parent.Height=1+Math.max(child1.Height,child2.Height)|0;parent.AABB.Combine$1(Bridge.ref(child1,"AABB"),Bridge.ref(child2,"AABB"));parent.ParentOrNext=VelcroPhysics.Collision.Broadphase.DynamicTree$1(T).NullNode;child1.ParentOrNext=parentIndex;child2.ParentOrNext=parentIndex;nodes[jMin]=nodes[count-1|0];nodes[iMin]=parentIndex;count=count-1|0}this._root=nodes[0];this.Validate()},ShiftOrigin:function(newOrigin){for(var i=0;i<this._nodeCapacity;i=i+1|0)this._nodes[i].AABB.LowerBound=Microsoft.Xna.Framework.Vector2.op_Subtraction(this._nodes[i].AABB.LowerBound.$clone(),newOrigin.$clone()),this._nodes[i].AABB.UpperBound=Microsoft.Xna.Framework.Vector2.op_Subtraction(this._nodes[i].AABB.UpperBound.$clone(),newOrigin.$clone())}}}});Bridge.define("VelcroPhysics.Collision.Broadphase.IBroadPhase",{$kind:"interface"});Bridge.define("VelcroPhysics.Collision.Broadphase.Pair",{inherits:function(){return[System.IComparable$1(VelcroPhysics.Collision.Broadphase.Pair)]},$kind:"struct",statics:{methods:{getDefaultValue:function(){return new VelcroPhysics.Collision.Broadphase.Pair}}},fields:{ProxyIdA:0,ProxyIdB:0},alias:["compareTo",["System$IComparable$1$VelcroPhysics$Collision$Broadphase$Pair$compareTo","System$IComparable$1$compareTo"]],ctors:{ctor:function(){this.$initialize()}},methods:{compareTo:function(other){if(this.ProxyIdA<other.ProxyIdA)return-1;if(this.ProxyIdA===other.ProxyIdA){if(this.ProxyIdB<other.ProxyIdB)return-1;if(this.ProxyIdB===other.ProxyIdB)return 0}return 1},getHashCode:function(){return Bridge.addHash([1919508816,this.ProxyIdA,this.ProxyIdB])},equals:function(o){return Bridge.is(o,VelcroPhysics.Collision.Broadphase.Pair)?Bridge.equals(this.ProxyIdA,o.ProxyIdA)&&Bridge.equals(this.ProxyIdB,o.ProxyIdB):!1},$clone:function(to){var s=to||new VelcroPhysics.Collision.Broadphase.Pair;return s.ProxyIdA=this.ProxyIdA,s.ProxyIdB=this.ProxyIdB,s}}});Bridge.define("VelcroPhysics.Collision.Broadphase.TreeNode$1",function(T){return{fields:{AABB:null,Child1:0,Child2:0,Height:0,ParentOrNext:0,UserData:Bridge.getDefaultValue(T)},ctors:{init:function(){this.AABB=new VelcroPhysics.Shared.AABB}},methods:{IsLeaf:function(){return this.Child1===VelcroPhysics.Collision.Broadphase.DynamicTree$1(T).NullNode}}}});Bridge.define("VelcroPhysics.Collision.ContactSystem.Contact",{statics:{fields:{_edge:null,_registers:null},ctors:{init:function(){this._edge=new VelcroPhysics.Collision.Shapes.EdgeShape.ctor;this._registers=System.Array.create(0,[[VelcroPhysics.Collision.ContactSystem.ContactType.Circle,VelcroPhysics.Collision.ContactSystem.ContactType.EdgeAndCircle,VelcroPhysics.Collision.ContactSystem.ContactType.PolygonAndCircle,VelcroPhysics.Collision.ContactSystem.ContactType.ChainAndCircle],[VelcroPhysics.Collision.ContactSystem.ContactType.EdgeAndCircle,VelcroPhysics.Collision.ContactSystem.ContactType.NotSupported,VelcroPhysics.Collision.ContactSystem.ContactType.EdgeAndPolygon,VelcroPhysics.Collision.ContactSystem.ContactType.NotSupported],[VelcroPhysics.Collision.ContactSystem.ContactType.PolygonAndCircle,VelcroPhysics.Collision.ContactSystem.ContactType.EdgeAndPolygon,VelcroPhysics.Collision.ContactSystem.ContactType.Polygon,VelcroPhysics.Collision.ContactSystem.ContactType.ChainAndPolygon],[VelcroPhysics.Collision.ContactSystem.ContactType.ChainAndCircle,VelcroPhysics.Collision.ContactSystem.ContactType.NotSupported,VelcroPhysics.Collision.ContactSystem.ContactType.ChainAndPolygon,VelcroPhysics.Collision.ContactSystem.ContactType.NotSupported]],VelcroPhysics.Collision.ContactSystem.ContactType,4,4)}},methods:{Create:function(fixtureA,indexA,fixtureB,indexB){var type1=fixtureA.Shape.ShapeType,type2=fixtureB.Shape.ShapeType,c,pool;return System.Diagnostics.Debug.Assert(VelcroPhysics.Collision.Shapes.ShapeType.Unknown<type1&&type1<VelcroPhysics.Collision.Shapes.ShapeType.TypeCount),System.Diagnostics.Debug.Assert(VelcroPhysics.Collision.Shapes.ShapeType.Unknown<type2&&type2<VelcroPhysics.Collision.Shapes.ShapeType.TypeCount),pool=fixtureA.Body._world._contactPool,pool.Count>0?(c=pool.Dequeue(),!(type1>=type2||type1===VelcroPhysics.Collision.Shapes.ShapeType.Edge&&type2===VelcroPhysics.Collision.Shapes.ShapeType.Polygon)||type2===VelcroPhysics.Collision.Shapes.ShapeType.Edge&&type1===VelcroPhysics.Collision.Shapes.ShapeType.Polygon?c.Reset(fixtureB,indexB,fixtureA,indexA):c.Reset(fixtureA,indexA,fixtureB,indexB)):c=!(type1>=type2||type1===VelcroPhysics.Collision.Shapes.ShapeType.Edge&&type2===VelcroPhysics.Collision.Shapes.ShapeType.Polygon)||type2===VelcroPhysics.Collision.Shapes.ShapeType.Edge&&type1===VelcroPhysics.Collision.Shapes.ShapeType.Polygon?new VelcroPhysics.Collision.ContactSystem.Contact(fixtureB,indexB,fixtureA,indexA):new VelcroPhysics.Collision.ContactSystem.Contact(fixtureA,indexA,fixtureB,indexB),c._type=VelcroPhysics.Collision.ContactSystem.Contact._registers.get([type1,type2]),c}}},fields:{_nodeA:null,_nodeB:null,_toi:0,_toiCount:0,_type:0,FixtureA:null,FixtureB:null,Manifold:null,Friction:0,Restitution:0,TangentSpeed:0,ChildIndexA:0,ChildIndexB:0,_flags:0},props:{Enabled:{get:function(){return(this._flags&VelcroPhysics.Collision.ContactSystem.ContactFlags.EnabledFlag&255)===VelcroPhysics.Collision.ContactSystem.ContactFlags.EnabledFlag},set:function(value){value?this._flags|=VelcroPhysics.Collision.ContactSystem.ContactFlags.EnabledFlag&255:this._flags&=251}},IsTouching:{get:function(){return(this._flags&VelcroPhysics.Collision.ContactSystem.ContactFlags.TouchingFlag&255)===VelcroPhysics.Collision.ContactSystem.ContactFlags.TouchingFlag}},IslandFlag:{get:function(){return(this._flags&VelcroPhysics.Collision.ContactSystem.ContactFlags.IslandFlag&255)===VelcroPhysics.Collision.ContactSystem.ContactFlags.IslandFlag}},TOIFlag:{get:function(){return(this._flags&VelcroPhysics.Collision.ContactSystem.ContactFlags.TOIFlag&255)===VelcroPhysics.Collision.ContactSystem.ContactFlags.TOIFlag}},FilterFlag:{get:function(){return(this._flags&VelcroPhysics.Collision.ContactSystem.ContactFlags.FilterFlag&255)===VelcroPhysics.Collision.ContactSystem.ContactFlags.FilterFlag}}},ctors:{init:function(){this.Manifold=new VelcroPhysics.Collision.Narrowphase.Manifold;this._nodeA=new VelcroPhysics.Collision.ContactSystem.ContactEdge;this._nodeB=new VelcroPhysics.Collision.ContactSystem.ContactEdge},ctor:function(fA,indexA,fB,indexB){this.$initialize();this.Reset(fA,indexA,fB,indexB)}},methods:{ResetRestitution:function(){this.Restitution=VelcroPhysics.Settings.MixRestitution(this.FixtureA.Restitution,this.FixtureB.Restitution)},ResetFriction:function(){this.Friction=VelcroPhysics.Settings.MixFriction(this.FixtureA.Friction,this.FixtureB.Friction)},GetWorldManifold:function(normal,points){var bodyA=this.FixtureA.Body,bodyB=this.FixtureB.Body,shapeA=this.FixtureA.Shape,shapeB=this.FixtureB.Shape,_discard1={v:new(VelcroPhysics.Shared.Optimization.FixedArray2$1(System.Single))};VelcroPhysics.Collision.Narrowphase.WorldManifold.Initialize(Bridge.ref(this,"Manifold"),Bridge.ref(bodyA,"_xf"),shapeA.Radius,Bridge.ref(bodyB,"_xf"),shapeB.Radius,normal,points,_discard1)},Reset:function(fA,indexA,fB,indexB){this._flags=VelcroPhysics.Collision.ContactSystem.ContactFlags.EnabledFlag;this.FixtureA=fA;this.FixtureB=fB;this.ChildIndexA=indexA;this.ChildIndexB=indexB;this.Manifold.PointCount=0;this._nodeA.Contact=null;this._nodeA.Prev=null;this._nodeA.Next=null;this._nodeA.Other=null;this._nodeB.Contact=null;this._nodeB.Prev=null;this._nodeB.Next=null;this._nodeB.Other=null;this._toiCount=0;this.FixtureA!=null&&this.FixtureB!=null&&(this.Friction=VelcroPhysics.Settings.MixFriction(this.FixtureA.Friction,this.FixtureB.Friction),this.Restitution=VelcroPhysics.Settings.MixRestitution(this.FixtureA.Restitution,this.FixtureB.Restitution));this.TangentSpeed=0},Update:function(contactManager){var touching,wasTouching,sensor,shapeA,shapeB,i,mp2,id2,j,mp1;if(this.FixtureA!=null&&this.FixtureB!=null){var bodyA=this.FixtureA.Body,bodyB=this.FixtureB.Body,oldManifold={v:this.Manifold.$clone()};if(this._flags|=VelcroPhysics.Collision.ContactSystem.ContactFlags.EnabledFlag&255,wasTouching=this.IsTouching,sensor=this.FixtureA.IsSensor||this.FixtureB.IsSensor,sensor)shapeA=this.FixtureA.Shape,shapeB=this.FixtureB.Shape,touching=VelcroPhysics.Collision.Narrowphase.Collision.TestOverlap(shapeA,this.ChildIndexA,shapeB,this.ChildIndexB,Bridge.ref(bodyA,"_xf"),Bridge.ref(bodyB,"_xf")),this.Manifold.PointCount=0;else{for(this.Evaluate(Bridge.ref(this,"Manifold"),Bridge.ref(bodyA,"_xf"),Bridge.ref(bodyB,"_xf")),touching=this.Manifold.PointCount>0,i=0;i<this.Manifold.PointCount;i=i+1|0){for(mp2=this.Manifold.Points.getItem(i).$clone(),mp2.NormalImpulse=0,mp2.TangentImpulse=0,id2=mp2.Id.$clone(),j=0;j<oldManifold.v.PointCount;j=j+1|0)if(mp1=oldManifold.v.Points.getItem(j).$clone(),mp1.Id.Key===id2.Key){mp2.NormalImpulse=mp1.NormalImpulse;mp2.TangentImpulse=mp1.TangentImpulse;break}this.Manifold.Points.setItem(i,mp2.$clone())}touching!==wasTouching&&(bodyA.Awake=!0,bodyB.Awake=!0)}(touching?this._flags|=VelcroPhysics.Collision.ContactSystem.ContactFlags.TouchingFlag&255:this._flags&=253,wasTouching===!1&&touching&&(Bridge.staticEquals(this.FixtureA.OnCollision,null)?null:this.FixtureA.OnCollision(this.FixtureA,this.FixtureB,this),Bridge.staticEquals(this.FixtureB.OnCollision,null)?null:this.FixtureB.OnCollision(this.FixtureB,this.FixtureA,this),Bridge.staticEquals(contactManager.BeginContact,null)?null:contactManager.BeginContact(this),this.Enabled||(touching=!1)),wasTouching===!0&&touching===!1&&(this.FixtureA!=null&&!Bridge.staticEquals(this.FixtureA.OnSeparation,null)?this.FixtureA.OnSeparation(this.FixtureA,this.FixtureB,this):null,this.FixtureB!=null&&!Bridge.staticEquals(this.FixtureB.OnSeparation,null)?this.FixtureB.OnSeparation(this.FixtureB,this.FixtureA,this):null,Bridge.staticEquals(contactManager.EndContact,null)?null:contactManager.EndContact(this)),sensor)||(Bridge.staticEquals(contactManager.PreSolve,null)?null:contactManager.PreSolve(this,oldManifold))}},Evaluate:function(manifold,transformA,transformB){var chain,loop2;switch(this._type){case VelcroPhysics.Collision.ContactSystem.ContactType.Polygon:VelcroPhysics.Collision.Narrowphase.CollidePolygon.CollidePolygons(manifold,Bridge.cast(this.FixtureA.Shape,VelcroPhysics.Collision.Shapes.PolygonShape),transformA,Bridge.cast(this.FixtureB.Shape,VelcroPhysics.Collision.Shapes.PolygonShape),transformB);break;case VelcroPhysics.Collision.ContactSystem.ContactType.PolygonAndCircle:VelcroPhysics.Collision.Narrowphase.CollideCircle.CollidePolygonAndCircle(manifold,Bridge.cast(this.FixtureA.Shape,VelcroPhysics.Collision.Shapes.PolygonShape),transformA,Bridge.cast(this.FixtureB.Shape,VelcroPhysics.Collision.Shapes.CircleShape),transformB);break;case VelcroPhysics.Collision.ContactSystem.ContactType.EdgeAndCircle:VelcroPhysics.Collision.Narrowphase.CollideEdge.CollideEdgeAndCircle(manifold,Bridge.cast(this.FixtureA.Shape,VelcroPhysics.Collision.Shapes.EdgeShape),transformA,Bridge.cast(this.FixtureB.Shape,VelcroPhysics.Collision.Shapes.CircleShape),transformB);break;case VelcroPhysics.Collision.ContactSystem.ContactType.EdgeAndPolygon:VelcroPhysics.Collision.Narrowphase.CollideEdge.CollideEdgeAndPolygon(manifold,Bridge.cast(this.FixtureA.Shape,VelcroPhysics.Collision.Shapes.EdgeShape),transformA,Bridge.cast(this.FixtureB.Shape,VelcroPhysics.Collision.Shapes.PolygonShape),transformB);break;case VelcroPhysics.Collision.ContactSystem.ContactType.ChainAndCircle:chain=Bridge.cast(this.FixtureA.Shape,VelcroPhysics.Collision.Shapes.ChainShape);chain.GetChildEdge$1(VelcroPhysics.Collision.ContactSystem.Contact._edge,this.ChildIndexA);VelcroPhysics.Collision.Narrowphase.CollideEdge.CollideEdgeAndCircle(manifold,VelcroPhysics.Collision.ContactSystem.Contact._edge,transformA,Bridge.cast(this.FixtureB.Shape,VelcroPhysics.Collision.Shapes.CircleShape),transformB);break;case VelcroPhysics.Collision.ContactSystem.ContactType.ChainAndPolygon:loop2=Bridge.cast(this.FixtureA.Shape,VelcroPhysics.Collision.Shapes.ChainShape);loop2.GetChildEdge$1(VelcroPhysics.Collision.ContactSystem.Contact._edge,this.ChildIndexA);VelcroPhysics.Collision.Narrowphase.CollideEdge.CollideEdgeAndPolygon(manifold,VelcroPhysics.Collision.ContactSystem.Contact._edge,transformA,Bridge.cast(this.FixtureB.Shape,VelcroPhysics.Collision.Shapes.PolygonShape),transformB);break;case VelcroPhysics.Collision.ContactSystem.ContactType.Circle:VelcroPhysics.Collision.Narrowphase.CollideCircle.CollideCircles(manifold,Bridge.cast(this.FixtureA.Shape,VelcroPhysics.Collision.Shapes.CircleShape),transformA,Bridge.cast(this.FixtureB.Shape,VelcroPhysics.Collision.Shapes.CircleShape),transformB);break;default:throw new System.ArgumentException.$ctor1("You are using an unsupported contact type.");}},Destroy:function(){this.FixtureA.Body._world._contactPool.Enqueue(this);this.Manifold.PointCount>0&&this.FixtureA.IsSensor===!1&&this.FixtureB.IsSensor===!1&&(this.FixtureA.Body.Awake=!0,this.FixtureB.Body.Awake=!0);this.Reset(null,0,null,0)}}});Bridge.define("VelcroPhysics.Collision.ContactSystem.ContactEdge",{fields:{Contact:null,Next:null,Other:null,Prev:null}});Bridge.define("VelcroPhysics.Collision.ContactSystem.ContactFeature",{$kind:"struct",statics:{methods:{getDefaultValue:function(){return new VelcroPhysics.Collision.ContactSystem.ContactFeature}}},fields:{IndexA:0,IndexB:0,TypeA:0,TypeB:0},ctors:{ctor:function(){this.$initialize()}},methods:{getHashCode:function(){return Bridge.addHash([5106014587,this.IndexA,this.IndexB,this.TypeA,this.TypeB])},equals:function(o){return Bridge.is(o,VelcroPhysics.Collision.ContactSystem.ContactFeature)?Bridge.equals(this.IndexA,o.IndexA)&&Bridge.equals(this.IndexB,o.IndexB)&&Bridge.equals(this.TypeA,o.TypeA)&&Bridge.equals(this.TypeB,o.TypeB):!1},$clone:function(to){var s=to||new VelcroPhysics.Collision.ContactSystem.ContactFeature;return s.IndexA=this.IndexA,s.IndexB=this.IndexB,s.TypeA=this.TypeA,s.TypeB=this.TypeB,s}}});Bridge.define("VelcroPhysics.Collision.ContactSystem.ContactFeatureType",{$kind:"enum",statics:{fields:{Vertex:0,Face:1}},$utype:System.Byte});Bridge.define("VelcroPhysics.Collision.ContactSystem.ContactFlags",{$kind:"enum",statics:{fields:{Unknown:0,IslandFlag:1,TouchingFlag:2,EnabledFlag:4,FilterFlag:8,BulletHitFlag:16,TOIFlag:32}},$flags:!0,$utype:System.Byte});Bridge.define("VelcroPhysics.Collision.ContactSystem.ContactID",{$kind:"struct",statics:{methods:{getDefaultValue:function(){return new VelcroPhysics.Collision.ContactSystem.ContactID}}},fields:{ContactFeature:null,Key:0},ctors:{init:function(){this.ContactFeature=new VelcroPhysics.Collision.ContactSystem.ContactFeature},ctor:function(){this.$initialize()}},methods:{getHashCode:function(){return Bridge.addHash([3185758952,this.ContactFeature,this.Key])},equals:function(o){return Bridge.is(o,VelcroPhysics.Collision.ContactSystem.ContactID)?Bridge.equals(this.ContactFeature,o.ContactFeature)&&Bridge.equals(this.Key,o.Key):!1},$clone:function(to){var s=to||new VelcroPhysics.Collision.ContactSystem.ContactID;return s.ContactFeature=this.ContactFeature.$clone(),s.Key=this.Key,s}}});Bridge.define("VelcroPhysics.Collision.ContactSystem.ContactManager",{statics:{methods:{ShouldCollide:function(fixtureA,fixtureB){if(VelcroPhysics.Settings.UseFPECollisionCategories)return fixtureA.CollisionGroup===fixtureB.CollisionGroup&&fixtureA.CollisionGroup!==0&&fixtureB.CollisionGroup!==0?!1:!((fixtureA.CollisionCategories&fixtureB.CollidesWith)===VelcroPhysics.Collision.Filtering.Category.None&(fixtureB.CollisionCategories&fixtureA.CollidesWith)===VelcroPhysics.Collision.Filtering.Category.None)?!0:!1;if(fixtureA.CollisionGroup===fixtureB.CollisionGroup&&fixtureA.CollisionGroup!==0)return fixtureA.CollisionGroup>0;return(fixtureA.CollidesWith&fixtureB.CollisionCategories)!=0&&(fixtureA.CollisionCategories&fixtureB.CollidesWith)!=0}}},fields:{BeginContact:null,ContactFilter:null,EndContact:null,OnBroadphaseCollision:null,PostSolve:null,PreSolve:null,ContactList:null,BroadPhase:null},ctors:{ctor:function(broadPhase){this.$initialize();this.BroadPhase=broadPhase;this.OnBroadphaseCollision=Bridge.fn.cacheBind(this,this.AddPair);this.ContactList=new(System.Collections.Generic.List$1(VelcroPhysics.Collision.ContactSystem.Contact).$ctor2)(128)}},methods:{AddPair:function(proxyA,proxyB){var fixtureA=proxyA.v.Fixture,fixtureB=proxyB.v.Fixture,indexA=proxyA.v.ChildIndex,indexB=proxyB.v.ChildIndex,bodyA=fixtureA.Body,bodyB=fixtureB.Body,edge,c;if(!Bridge.referenceEquals(bodyA,bodyB)){for(edge=bodyB.ContactList;edge!=null;){if(Bridge.referenceEquals(edge.Other,bodyA)){var fA=edge.Contact.FixtureA,fB=edge.Contact.FixtureB,iA=edge.Contact.ChildIndexA,iB=edge.Contact.ChildIndexB;if(Bridge.referenceEquals(fA,fixtureA)&&Bridge.referenceEquals(fB,fixtureB)&&iA===indexA&&iB===indexB)return;if(Bridge.referenceEquals(fA,fixtureB)&&Bridge.referenceEquals(fB,fixtureA)&&iA===indexB&&iB===indexA)return}edge=edge.Next}bodyB.ShouldCollide(bodyA)!==!1&&VelcroPhysics.Collision.ContactSystem.ContactManager.ShouldCollide(fixtureA,fixtureB)!==!1&&(Bridge.staticEquals(this.ContactFilter,null)||this.ContactFilter(fixtureA,fixtureB)!==!1)&&(Bridge.staticEquals(fixtureA.BeforeCollision,null)||fixtureA.BeforeCollision(fixtureA,fixtureB)!==!1)&&(Bridge.staticEquals(fixtureB.BeforeCollision,null)||fixtureB.BeforeCollision(fixtureB,fixtureA)!==!1)&&(c=VelcroPhysics.Collision.ContactSystem.Contact.Create(fixtureA,indexA,fixtureB,indexB),c!=null)&&(fixtureA=c.FixtureA,fixtureB=c.FixtureB,bodyA=fixtureA.Body,bodyB=fixtureB.Body,this.ContactList.add(c),c._nodeA.Contact=c,c._nodeA.Other=bodyB,c._nodeA.Prev=null,c._nodeA.Next=bodyA.ContactList,bodyA.ContactList!=null&&(bodyA.ContactList.Prev=c._nodeA),bodyA.ContactList=c._nodeA,c._nodeB.Contact=c,c._nodeB.Other=bodyA,c._nodeB.Prev=null,c._nodeB.Next=bodyB.ContactList,bodyB.ContactList!=null&&(bodyB.ContactList.Prev=c._nodeB),bodyB.ContactList=c._nodeB,fixtureA.IsSensor===!1&&fixtureB.IsSensor===!1&&(bodyA.Awake=!0,bodyB.Awake=!0))}},FindNewContacts:function(){this.BroadPhase.VelcroPhysics$Collision$Broadphase$IBroadPhase$UpdatePairs(this.OnBroadphaseCollision)},Destroy:function(contact){var fixtureA,fixtureB,bodyA,bodyB;contact.FixtureA!=null&&contact.FixtureB!=null&&(fixtureA=contact.FixtureA,fixtureB=contact.FixtureB,contact.IsTouching&&(Bridge.staticEquals(fixtureA.OnSeparation,null)?null:fixtureA.OnSeparation(fixtureA,fixtureB,contact),Bridge.staticEquals(fixtureB.OnSeparation,null)?null:fixtureB.OnSeparation(fixtureB,fixtureA,contact),Bridge.staticEquals(this.EndContact,null)?null:this.EndContact(contact)),bodyA=fixtureA.Body,bodyB=fixtureB.Body,this.ContactList.remove(contact),contact._nodeA.Prev!=null&&(contact._nodeA.Prev.Next=contact._nodeA.Next),contact._nodeA.Next!=null&&(contact._nodeA.Next.Prev=contact._nodeA.Prev),Bridge.referenceEquals(contact._nodeA,bodyA.ContactList)&&(bodyA.ContactList=contact._nodeA.Next),contact._nodeB.Prev!=null&&(contact._nodeB.Prev.Next=contact._nodeB.Next),contact._nodeB.Next!=null&&(contact._nodeB.Next.Prev=contact._nodeB.Prev),Bridge.referenceEquals(contact._nodeB,bodyB.ContactList)&&(bodyB.ContactList=contact._nodeB.Next),contact.Destroy())},Collide:function(){for(var cNuke,cNuke1,cNuke2,activeA,activeB,cNuke3,i=0;i<this.ContactList.Count;i=i+1|0){var c=this.ContactList.getItem(i),fixtureA=c.FixtureA,fixtureB=c.FixtureB,indexA=c.ChildIndexA,indexB=c.ChildIndexB,bodyA=fixtureA.Body,bodyB=fixtureB.Body;if(bodyA.Enabled&&bodyB.Enabled){if(c.FilterFlag){if(bodyB.ShouldCollide(bodyA)===!1){cNuke=c;this.Destroy(cNuke);continue}if(VelcroPhysics.Collision.ContactSystem.ContactManager.ShouldCollide(fixtureA,fixtureB)===!1){cNuke1=c;this.Destroy(cNuke1);continue}if(!Bridge.staticEquals(this.ContactFilter,null)&&this.ContactFilter(fixtureA,fixtureB)===!1){cNuke2=c;this.Destroy(cNuke2);continue}c._flags&=247}if(activeA=bodyA.Awake&&bodyA.BodyType!==VelcroPhysics.Dynamics.BodyType.Static,activeB=bodyB.Awake&&bodyB.BodyType!==VelcroPhysics.Dynamics.BodyType.Static,activeA!==!1||activeB!==!1){var proxyIdA=fixtureA.Proxies[indexA].ProxyId,proxyIdB=fixtureB.Proxies[indexB].ProxyId,overlap=this.BroadPhase.VelcroPhysics$Collision$Broadphase$IBroadPhase$TestOverlap(proxyIdA,proxyIdB);if(overlap===!1){cNuke3=c;this.Destroy(cNuke3);continue}c.Update(this)}}}}}});Bridge.define("VelcroPhysics.Collision.ContactSystem.ContactType",{$kind:"enum",statics:{fields:{NotSupported:0,Polygon:1,PolygonAndCircle:2,Circle:3,EdgeAndPolygon:4,EdgeAndCircle:5,ChainAndPolygon:6,ChainAndCircle:7}},$utype:System.Byte});Bridge.define("VelcroPhysics.Collision.Distance.DistanceGJK",{statics:{fields:{GJKCalls:0,GJKIters:0,GJKMaxIters:0},methods:{ComputeDistance:function(input,output,cache){var $t,$t1,simplex,saveCount,i,d,vertex,duplicate,i1,rA,rB,normal,p;cache.v=new VelcroPhysics.Collision.Narrowphase.SimplexCache;VelcroPhysics.Settings.EnableDiagnostics&&(VelcroPhysics.Collision.Distance.DistanceGJK.GJKCalls=VelcroPhysics.Collision.Distance.DistanceGJK.GJKCalls+1|0);simplex=new VelcroPhysics.Collision.Narrowphase.Simplex;simplex.ReadCache(cache,Bridge.ref(input.v,"ProxyA"),Bridge.ref(input.v,"TransformA"),Bridge.ref(input.v,"ProxyB"),Bridge.ref(input.v,"TransformB"));for(var saveA=new(VelcroPhysics.Shared.Optimization.FixedArray3$1(System.Int32)),saveB=new(VelcroPhysics.Shared.Optimization.FixedArray3$1(System.Int32)),iter=0;iter<VelcroPhysics.Settings.MaxGJKIterations;){for(saveCount=simplex.Count,i=0;i<saveCount;i=i+1|0)saveA.setItem(i,simplex.V.getItem(i).$clone().IndexA),saveB.setItem(i,simplex.V.getItem(i).$clone().IndexB);switch(simplex.Count){case 1:break;case 2:simplex.Solve2();break;case 3:simplex.Solve3();break;default:System.Diagnostics.Debug.Assert(!1);break}if(simplex.Count===3)break;if(d=simplex.GetSearchDirection(),d.LengthSquared()<142108547e-22)break;for(vertex=simplex.V.getItem(simplex.Count).$clone(),vertex.IndexA=input.v.ProxyA.GetSupport(VelcroPhysics.Utilities.MathUtils.MulT$2(input.v.TransformA.q.$clone(),Microsoft.Xna.Framework.Vector2.op_UnaryNegation(d.$clone()))),vertex.WA=VelcroPhysics.Utilities.MathUtils.Mul$4(Bridge.ref(input.v,"TransformA"),($t=input.v.ProxyA.Vertices)[vertex.IndexA].$clone()),vertex.IndexB=input.v.ProxyB.GetSupport(VelcroPhysics.Utilities.MathUtils.MulT$2(input.v.TransformB.q.$clone(),d.$clone())),vertex.WB=VelcroPhysics.Utilities.MathUtils.Mul$4(Bridge.ref(input.v,"TransformB"),($t1=input.v.ProxyB.Vertices)[vertex.IndexB].$clone()),vertex.W=Microsoft.Xna.Framework.Vector2.op_Subtraction(vertex.WB.$clone(),vertex.WA.$clone()),simplex.V.setItem(simplex.Count,vertex.$clone()),iter=iter+1|0,VelcroPhysics.Settings.EnableDiagnostics&&(VelcroPhysics.Collision.Distance.DistanceGJK.GJKIters=VelcroPhysics.Collision.Distance.DistanceGJK.GJKIters+1|0),duplicate=!1,i1=0;i1<saveCount;i1=i1+1|0)if(vertex.IndexA===saveA.getItem(i1)&&vertex.IndexB===saveB.getItem(i1)){duplicate=!0;break}if(duplicate)break;simplex.Count=simplex.Count+1|0}VelcroPhysics.Settings.EnableDiagnostics&&(VelcroPhysics.Collision.Distance.DistanceGJK.GJKMaxIters=Math.max(VelcroPhysics.Collision.Distance.DistanceGJK.GJKMaxIters,iter));simplex.GetWitnessPoints(Bridge.ref(output.v,"PointA"),Bridge.ref(output.v,"PointB"));output.v.Distance=Microsoft.Xna.Framework.Vector2.op_Subtraction(output.v.PointA.$clone(),output.v.PointB.$clone()).Length();output.v.Iterations=iter;simplex.WriteCache(cache);input.v.UseRadii&&(rA=input.v.ProxyA.Radius,rB=input.v.ProxyB.Radius,output.v.Distance>rA+rB&&output.v.Distance>VelcroPhysics.Settings.Epsilon?(output.v.Distance-=rA+rB,normal=Microsoft.Xna.Framework.Vector2.op_Subtraction(output.v.PointB.$clone(),output.v.PointA.$clone()),normal.Normalize(),output.v.PointA=Microsoft.Xna.Framework.Vector2.op_Addition(output.v.PointA.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(rA,normal.$clone())),output.v.PointB=Microsoft.Xna.Framework.Vector2.op_Subtraction(output.v.PointB.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(rB,normal.$clone()))):(p=Microsoft.Xna.Framework.Vector2.op_Multiply$2(.5,Microsoft.Xna.Framework.Vector2.op_Addition(output.v.PointA.$clone(),output.v.PointB.$clone())),output.v.PointA=p.$clone(),output.v.PointB=p.$clone(),output.v.Distance=0))}}}});Bridge.define("VelcroPhysics.Collision.Distance.DistanceInput",{$kind:"struct",statics:{methods:{getDefaultValue:function(){return new VelcroPhysics.Collision.Distance.DistanceInput}}},fields:{ProxyA:null,ProxyB:null,TransformA:null,TransformB:null,UseRadii:!1},ctors:{init:function(){this.ProxyA=new VelcroPhysics.Collision.Distance.DistanceProxy;this.ProxyB=new VelcroPhysics.Collision.Distance.DistanceProxy;this.TransformA=new VelcroPhysics.Shared.Transform;this.TransformB=new VelcroPhysics.Shared.Transform},ctor:function(){this.$initialize()}},methods:{getHashCode:function(){return Bridge.addHash([5625038434,this.ProxyA,this.ProxyB,this.TransformA,this.TransformB,this.UseRadii])},equals:function(o){return Bridge.is(o,VelcroPhysics.Collision.Distance.DistanceInput)?Bridge.equals(this.ProxyA,o.ProxyA)&&Bridge.equals(this.ProxyB,o.ProxyB)&&Bridge.equals(this.TransformA,o.TransformA)&&Bridge.equals(this.TransformB,o.TransformB)&&Bridge.equals(this.UseRadii,o.UseRadii):!1},$clone:function(to){var s=to||new VelcroPhysics.Collision.Distance.DistanceInput;return s.ProxyA=this.ProxyA,s.ProxyB=this.ProxyB,s.TransformA=this.TransformA.$clone(),s.TransformB=this.TransformB.$clone(),s.UseRadii=this.UseRadii,s}}});Bridge.define("VelcroPhysics.Collision.Distance.DistanceOutput",{$kind:"struct",statics:{methods:{getDefaultValue:function(){return new VelcroPhysics.Collision.Distance.DistanceOutput}}},fields:{Distance:0,Iterations:0,PointA:null,PointB:null},ctors:{init:function(){this.PointA=new Microsoft.Xna.Framework.Vector2;this.PointB=new Microsoft.Xna.Framework.Vector2},ctor:function(){this.$initialize()}},methods:{getHashCode:function(){return Bridge.addHash([5541445993,this.Distance,this.Iterations,this.PointA,this.PointB])},equals:function(o){return Bridge.is(o,VelcroPhysics.Collision.Distance.DistanceOutput)?Bridge.equals(this.Distance,o.Distance)&&Bridge.equals(this.Iterations,o.Iterations)&&Bridge.equals(this.PointA,o.PointA)&&Bridge.equals(this.PointB,o.PointB):!1},$clone:function(to){var s=to||new VelcroPhysics.Collision.Distance.DistanceOutput;return s.Distance=this.Distance,s.Iterations=this.Iterations,s.PointA=this.PointA.$clone(),s.PointB=this.PointB.$clone(),s}}});Bridge.define("VelcroPhysics.Collision.Distance.DistanceProxy",{$kind:"struct",statics:{methods:{getDefaultValue:function(){return new VelcroPhysics.Collision.Distance.DistanceProxy}}},fields:{Radius:0,Vertices:null},ctors:{$ctor1:function(shape,index){var circle,polygon,i,chain,edge;this.$initialize();switch(shape.ShapeType){case VelcroPhysics.Collision.Shapes.ShapeType.Circle:circle=Bridge.cast(shape,VelcroPhysics.Collision.Shapes.CircleShape);this.Vertices=System.Array.init(1,function(){return new Microsoft.Xna.Framework.Vector2},Microsoft.Xna.Framework.Vector2);this.Vertices[0]=circle.Position.$clone();this.Radius=circle.Radius;break;case VelcroPhysics.Collision.Shapes.ShapeType.Polygon:for(polygon=Bridge.cast(shape,VelcroPhysics.Collision.Shapes.PolygonShape),this.Vertices=System.Array.init(polygon.Vertices.Count,function(){return new Microsoft.Xna.Framework.Vector2},Microsoft.Xna.Framework.Vector2),i=0;i<polygon.Vertices.Count;i=i+1|0)this.Vertices[i]=polygon.Vertices.getItem(i).$clone();this.Radius=polygon.Radius;break;case VelcroPhysics.Collision.Shapes.ShapeType.Chain:chain=Bridge.cast(shape,VelcroPhysics.Collision.Shapes.ChainShape);System.Diagnostics.Debug.Assert(0<=index&&index<chain.Vertices.Count);this.Vertices=System.Array.init(2,function(){return new Microsoft.Xna.Framework.Vector2},Microsoft.Xna.Framework.Vector2);this.Vertices[0]=chain.Vertices.getItem(index).$clone();this.Vertices[1]=(index+1|0)<chain.Vertices.Count?chain.Vertices.getItem(index+1|0).$clone():chain.Vertices.getItem(0).$clone();this.Radius=chain.Radius;break;case VelcroPhysics.Collision.Shapes.ShapeType.Edge:edge=Bridge.cast(shape,VelcroPhysics.Collision.Shapes.EdgeShape);this.Vertices=System.Array.init(2,function(){return new Microsoft.Xna.Framework.Vector2},Microsoft.Xna.Framework.Vector2);this.Vertices[0]=edge.Vertex1.$clone();this.Vertices[1]=edge.Vertex2.$clone();this.Radius=edge.Radius;break;default:throw new System.NotSupportedException.ctor;}},ctor:function(){this.$initialize()}},methods:{GetSupport:function(direction){for(var value,bestIndex=0,bestValue=Microsoft.Xna.Framework.Vector2.Dot(this.Vertices[0].$clone(),direction.$clone()),i=1;i<this.Vertices.length;i=i+1|0)value=Microsoft.Xna.Framework.Vector2.Dot(this.Vertices[i].$clone(),direction.$clone()),value>bestValue&&(bestIndex=i,bestValue=value);return bestIndex},getHashCode:function(){return Bridge.addHash([5675305582,this.Radius,this.Vertices])},equals:function(o){return Bridge.is(o,VelcroPhysics.Collision.Distance.DistanceProxy)?Bridge.equals(this.Radius,o.Radius)&&Bridge.equals(this.Vertices,o.Vertices):!1},$clone:function(to){var s=to||new VelcroPhysics.Collision.Distance.DistanceProxy;return s.Radius=this.Radius,s.Vertices=this.Vertices,s}}});Bridge.define("VelcroPhysics.Collision.Filtering.Category",{$kind:"enum",statics:{fields:{None:0,All:0,Cat1:1,Cat2:2,Cat3:4,Cat4:8,Cat5:16,Cat6:32,Cat7:64,Cat8:128,Cat9:256,Cat10:512,Cat11:1024,Cat12:2048,Cat13:4096,Cat14:8192,Cat15:16384,Cat16:32768,Cat17:65536,Cat18:131072,Cat19:262144,Cat20:524288,Cat21:1048576,Cat22:2097152,Cat23:4194304,Cat24:8388608,Cat25:16777216,Cat26:33554432,Cat27:67108864,Cat28:134217728,Cat29:268435456,Cat30:536870912,Cat31:1073741824},ctors:{init:function(){this.All=2147483647}}},$flags:!0});Bridge.define("VelcroPhysics.Collision.Filtering.Filter",{fields:{Group:0,Category:0,CategoryMask:0},ctors:{ctor:function(group,category,mask){this.$initialize();this.Group=group;this.Category=category;this.CategoryMask=mask}}});Bridge.define("VelcroPhysics.Collision.Narrowphase.ClipVertex",{$kind:"struct",statics:{methods:{getDefaultValue:function(){return new VelcroPhysics.Collision.Narrowphase.ClipVertex}}},fields:{ID:null,V:null},ctors:{init:function(){this.ID=new VelcroPhysics.Collision.ContactSystem.ContactID;this.V=new Microsoft.Xna.Framework.Vector2},ctor:function(){this.$initialize()}},methods:{getHashCode:function(){return Bridge.addHash([3839642110,this.ID,this.V])},equals:function(o){return Bridge.is(o,VelcroPhysics.Collision.Narrowphase.ClipVertex)?Bridge.equals(this.ID,o.ID)&&Bridge.equals(this.V,o.V):!1},$clone:function(to){var s=to||new VelcroPhysics.Collision.Narrowphase.ClipVertex;return s.ID=this.ID.$clone(),s.V=this.V.$clone(),s}}});Bridge.define("VelcroPhysics.Collision.Narrowphase.CollideCircle",{statics:{methods:{CollideCircles:function(manifold,circleA,xfA,circleB,xfB){var p0;manifold.v.PointCount=0;var pA=VelcroPhysics.Utilities.MathUtils.Mul$4(xfA,circleA.Position.$clone()),pB=VelcroPhysics.Utilities.MathUtils.Mul$4(xfB,circleB.Position.$clone()),d=Microsoft.Xna.Framework.Vector2.op_Subtraction(pB.$clone(),pA.$clone()),distSqr=Microsoft.Xna.Framework.Vector2.Dot(d.$clone(),d.$clone()),rA=circleA.Radius,rB=circleB.Radius,radius=rA+rB;distSqr>radius*radius||(manifold.v.Type=VelcroPhysics.Collision.Narrowphase.ManifoldType.Circles,manifold.v.LocalPoint=circleA.Position.$clone(),manifold.v.LocalNormal=Microsoft.Xna.Framework.Vector2.Zero.$clone(),manifold.v.PointCount=1,p0=manifold.v.Points.getItem(0).$clone(),p0.LocalPoint=circleB.Position.$clone(),p0.Id.Key=0,manifold.v.Points.setItem(0,p0.$clone()))},CollidePolygonAndCircle:function(manifold,polygonA,xfA,circleB,xfB){var i,s,u1,u2,faceCenter,s1;manifold.v.PointCount=0;var c=VelcroPhysics.Utilities.MathUtils.Mul$4(xfB,circleB.Position.$clone()),cLocal=VelcroPhysics.Utilities.MathUtils.MulT$5(xfA,c.$clone()),normalIndex=0,separation=-340282347e30,radius=polygonA.Radius+circleB.Radius,vertexCount=polygonA.Vertices.Count,vertices=polygonA.Vertices,normals=polygonA.Normals;for(i=0;i<vertexCount;i=i+1|0){if(s=Microsoft.Xna.Framework.Vector2.Dot(normals.getItem(i).$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(cLocal.$clone(),vertices.getItem(i).$clone())),s>radius)return;s>separation&&(separation=s,normalIndex=i)}var vertIndex1=normalIndex,vertIndex2=(vertIndex1+1|0)<vertexCount?vertIndex1+1|0:0,v1=vertices.getItem(vertIndex1).$clone(),v2=vertices.getItem(vertIndex2).$clone();if(separation<VelcroPhysics.Settings.Epsilon){manifold.v.PointCount=1;manifold.v.Type=VelcroPhysics.Collision.Narrowphase.ManifoldType.FaceA;manifold.v.LocalNormal=normals.getItem(normalIndex).$clone();manifold.v.LocalPoint=Microsoft.Xna.Framework.Vector2.op_Multiply$2(.5,Microsoft.Xna.Framework.Vector2.op_Addition(v1.$clone(),v2.$clone()));manifold.v.Points.Value0.LocalPoint=circleB.Position.$clone();manifold.v.Points.Value0.Id.Key=0;return}if(u1=Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(cLocal.$clone(),v1.$clone()),Microsoft.Xna.Framework.Vector2.op_Subtraction(v2.$clone(),v1.$clone())),u2=Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(cLocal.$clone(),v2.$clone()),Microsoft.Xna.Framework.Vector2.op_Subtraction(v1.$clone(),v2.$clone())),u1<=0){if(Microsoft.Xna.Framework.Vector2.DistanceSquared(cLocal.$clone(),v1.$clone())>radius*radius)return;manifold.v.PointCount=1;manifold.v.Type=VelcroPhysics.Collision.Narrowphase.ManifoldType.FaceA;manifold.v.LocalNormal=Microsoft.Xna.Framework.Vector2.op_Subtraction(cLocal.$clone(),v1.$clone());manifold.v.LocalNormal.Normalize();manifold.v.LocalPoint=v1.$clone();manifold.v.Points.Value0.LocalPoint=circleB.Position.$clone();manifold.v.Points.Value0.Id.Key=0}else if(u2<=0){if(Microsoft.Xna.Framework.Vector2.DistanceSquared(cLocal.$clone(),v2.$clone())>radius*radius)return;manifold.v.PointCount=1;manifold.v.Type=VelcroPhysics.Collision.Narrowphase.ManifoldType.FaceA;manifold.v.LocalNormal=Microsoft.Xna.Framework.Vector2.op_Subtraction(cLocal.$clone(),v2.$clone());manifold.v.LocalNormal.Normalize();manifold.v.LocalPoint=v2.$clone();manifold.v.Points.Value0.LocalPoint=circleB.Position.$clone();manifold.v.Points.Value0.Id.Key=0}else{if(faceCenter=Microsoft.Xna.Framework.Vector2.op_Multiply$2(.5,Microsoft.Xna.Framework.Vector2.op_Addition(v1.$clone(),v2.$clone())),s1=Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(cLocal.$clone(),faceCenter.$clone()),normals.getItem(vertIndex1).$clone()),s1>radius)return;manifold.v.PointCount=1;manifold.v.Type=VelcroPhysics.Collision.Narrowphase.ManifoldType.FaceA;manifold.v.LocalNormal=normals.getItem(vertIndex1).$clone();manifold.v.LocalPoint=faceCenter.$clone();manifold.v.Points.Value0.LocalPoint=circleB.Position.$clone();manifold.v.Points.Value0.Id.Key=0}}}}});Bridge.define("VelcroPhysics.Collision.Narrowphase.CollideEdge",{statics:{methods:{CollideEdgeAndCircle:function(manifold,edgeA,transformA,circleB,transformB){var den,n;manifold.v.PointCount=0;var Q=VelcroPhysics.Utilities.MathUtils.MulT$5(transformA,VelcroPhysics.Utilities.MathUtils.Mul$5(transformB,Bridge.ref(circleB,"_position"))),A=edgeA.Vertex1.$clone(),B=edgeA.Vertex2.$clone(),e=Microsoft.Xna.Framework.Vector2.op_Subtraction(B.$clone(),A.$clone()),u=Microsoft.Xna.Framework.Vector2.Dot(e.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(B.$clone(),Q.$clone())),v=Microsoft.Xna.Framework.Vector2.Dot(e.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(Q.$clone(),A.$clone())),radius=edgeA.Radius+circleB.Radius,cf=new VelcroPhysics.Collision.ContactSystem.ContactFeature;if(cf.IndexB=0,cf.TypeB=VelcroPhysics.Collision.ContactSystem.ContactFeatureType.Vertex,v<=0){var P1=A.$clone(),d1=Microsoft.Xna.Framework.Vector2.op_Subtraction(Q.$clone(),P1.$clone()),dd1=Microsoft.Xna.Framework.Vector2.Dot(d1.$clone(),d1.$clone());if(dd1>radius*radius)return;if(edgeA.HasVertex0){var A1=edgeA.Vertex0.$clone(),B1=A.$clone(),e1=Microsoft.Xna.Framework.Vector2.op_Subtraction(B1.$clone(),A1.$clone()),u1=Microsoft.Xna.Framework.Vector2.Dot(e1.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(B1.$clone(),Q.$clone()));if(u1>0)return}cf.IndexA=0;cf.TypeA=VelcroPhysics.Collision.ContactSystem.ContactFeatureType.Vertex;manifold.v.PointCount=1;manifold.v.Type=VelcroPhysics.Collision.Narrowphase.ManifoldType.Circles;manifold.v.LocalNormal=Microsoft.Xna.Framework.Vector2.Zero.$clone();manifold.v.LocalPoint=P1.$clone();manifold.v.Points.Value0.Id.Key=0;manifold.v.Points.Value0.Id.ContactFeature=cf.$clone();manifold.v.Points.Value0.LocalPoint=circleB.Position.$clone();return}if(u<=0){var P2=B.$clone(),d2=Microsoft.Xna.Framework.Vector2.op_Subtraction(Q.$clone(),P2.$clone()),dd2=Microsoft.Xna.Framework.Vector2.Dot(d2.$clone(),d2.$clone());if(dd2>radius*radius)return;if(edgeA.HasVertex3){var B2=edgeA.Vertex3.$clone(),A2=B.$clone(),e2=Microsoft.Xna.Framework.Vector2.op_Subtraction(B2.$clone(),A2.$clone()),v2=Microsoft.Xna.Framework.Vector2.Dot(e2.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(Q.$clone(),A2.$clone()));if(v2>0)return}cf.IndexA=1;cf.TypeA=VelcroPhysics.Collision.ContactSystem.ContactFeatureType.Vertex;manifold.v.PointCount=1;manifold.v.Type=VelcroPhysics.Collision.Narrowphase.ManifoldType.Circles;manifold.v.LocalNormal=Microsoft.Xna.Framework.Vector2.Zero.$clone();manifold.v.LocalPoint=P2.$clone();manifold.v.Points.Value0.Id.Key=0;manifold.v.Points.Value0.Id.ContactFeature=cf.$clone();manifold.v.Points.Value0.LocalPoint=circleB.Position.$clone();return}den=Microsoft.Xna.Framework.Vector2.Dot(e.$clone(),e.$clone());System.Diagnostics.Debug.Assert(den>0);var P=Microsoft.Xna.Framework.Vector2.op_Multiply$2(1/den,Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(u,A.$clone()),Microsoft.Xna.Framework.Vector2.op_Multiply$2(v,B.$clone()))),d=Microsoft.Xna.Framework.Vector2.op_Subtraction(Q.$clone(),P.$clone()),dd=Microsoft.Xna.Framework.Vector2.Dot(d.$clone(),d.$clone());dd>radius*radius||(n=new Microsoft.Xna.Framework.Vector2.$ctor2(-e.Y,e.X),Microsoft.Xna.Framework.Vector2.Dot(n.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(Q.$clone(),A.$clone()))<0&&(n=new Microsoft.Xna.Framework.Vector2.$ctor2(-n.X,-n.Y)),n.Normalize(),cf.IndexA=0,cf.TypeA=VelcroPhysics.Collision.ContactSystem.ContactFeatureType.Face,manifold.v.PointCount=1,manifold.v.Type=VelcroPhysics.Collision.Narrowphase.ManifoldType.FaceA,manifold.v.LocalNormal=n.$clone(),manifold.v.LocalPoint=A.$clone(),manifold.v.Points.Value0.Id.Key=0,manifold.v.Points.Value0.Id.ContactFeature=cf.$clone(),manifold.v.Points.Value0.LocalPoint=circleB.Position.$clone())},CollideEdgeAndPolygon:function(manifold,edgeA,xfA,polygonB,xfB){VelcroPhysics.Collision.Narrowphase.EPCollider.Collide(manifold,edgeA,xfA,polygonB,xfB)}}}});Bridge.define("VelcroPhysics.Collision.Narrowphase.CollidePolygon",{statics:{methods:{CollidePolygons:function(manifold,polyA,xfA,polyB,xfB){var edgeB,separationB,incidentEdge,pointCount,i,separation,cp,cf;manifold.v.PointCount=0;var totalRadius=polyA.Radius+polyB.Radius,edgeA={},separationA=VelcroPhysics.Collision.Narrowphase.CollidePolygon.FindMaxSeparation(edgeA,polyA,xfA,polyB,xfB);if(!(separationA>totalRadius)&&(edgeB={},separationB=VelcroPhysics.Collision.Narrowphase.CollidePolygon.FindMaxSeparation(edgeB,polyB,xfB,polyA,xfA),!(separationB>totalRadius))){var poly1,poly2,xf1={v:new VelcroPhysics.Shared.Transform},xf2={v:new VelcroPhysics.Shared.Transform},edge1,flip,k_tol=.0005;separationB>separationA+k_tol?(poly1=polyB,poly2=polyA,xf1.v=xfB.v.$clone(),xf2.v=xfA.v.$clone(),edge1=edgeB.v,manifold.v.Type=VelcroPhysics.Collision.Narrowphase.ManifoldType.FaceB,flip=!0):(poly1=polyA,poly2=polyB,xf1.v=xfA.v.$clone(),xf2.v=xfB.v.$clone(),edge1=edgeA.v,manifold.v.Type=VelcroPhysics.Collision.Narrowphase.ManifoldType.FaceA,flip=!1);incidentEdge={v:new(VelcroPhysics.Shared.Optimization.FixedArray2$1(VelcroPhysics.Collision.Narrowphase.ClipVertex))};VelcroPhysics.Collision.Narrowphase.CollidePolygon.FindIncidentEdge(incidentEdge,poly1,xf1,edge1,poly2,xf2);var count1=poly1.Vertices.Count,vertices1=poly1.Vertices,iv1=edge1,iv2=(edge1+1|0)<count1?edge1+1|0:0,v11=vertices1.getItem(iv1).$clone(),v12=vertices1.getItem(iv2).$clone(),localTangent=Microsoft.Xna.Framework.Vector2.op_Subtraction(v12.$clone(),v11.$clone());localTangent.Normalize();var localNormal=VelcroPhysics.Utilities.MathUtils.Cross(localTangent.$clone(),1),planePoint=Microsoft.Xna.Framework.Vector2.op_Multiply$2(.5,Microsoft.Xna.Framework.Vector2.op_Addition(v11.$clone(),v12.$clone())),tangent=VelcroPhysics.Utilities.MathUtils.Mul$3(Bridge.ref(xf1.v,"q"),localTangent.$clone()),normal=VelcroPhysics.Utilities.MathUtils.Cross(tangent.$clone(),1);v11=VelcroPhysics.Utilities.MathUtils.Mul$4(xf1,v11.$clone());v12=VelcroPhysics.Utilities.MathUtils.Mul$4(xf1,v12.$clone());var frontOffset=Microsoft.Xna.Framework.Vector2.Dot(normal.$clone(),v11.$clone()),sideOffset1=-Microsoft.Xna.Framework.Vector2.Dot(tangent.$clone(),v11.$clone())+totalRadius,sideOffset2=Microsoft.Xna.Framework.Vector2.Dot(tangent.$clone(),v12.$clone())+totalRadius,clipPoints1={v:new(VelcroPhysics.Shared.Optimization.FixedArray2$1(VelcroPhysics.Collision.Narrowphase.ClipVertex))},clipPoints2={v:new(VelcroPhysics.Shared.Optimization.FixedArray2$1(VelcroPhysics.Collision.Narrowphase.ClipVertex))},np=VelcroPhysics.Collision.Narrowphase.Collision.ClipSegmentToLine(clipPoints1,incidentEdge,Microsoft.Xna.Framework.Vector2.op_UnaryNegation(tangent.$clone()),sideOffset1,iv1);if(!(np<2)&&(np=VelcroPhysics.Collision.Narrowphase.Collision.ClipSegmentToLine(clipPoints2,clipPoints1,tangent.$clone(),sideOffset2,iv2),!(np<2))){for(manifold.v.LocalNormal=localNormal.$clone(),manifold.v.LocalPoint=planePoint.$clone(),pointCount=0,i=0;i<VelcroPhysics.Settings.MaxManifoldPoints;i=i+1|0)separation=Microsoft.Xna.Framework.Vector2.Dot(normal.$clone(),clipPoints2.v.getItem(i).$clone().V.$clone())-frontOffset,separation<=totalRadius&&(cp=manifold.v.Points.getItem(pointCount).$clone(),cp.LocalPoint=VelcroPhysics.Utilities.MathUtils.MulT$5(xf2,clipPoints2.v.getItem(i).$clone().V.$clone()),cp.Id=clipPoints2.v.getItem(i).$clone().ID.$clone(),flip&&(cf=cp.Id.ContactFeature.$clone(),cp.Id.ContactFeature.IndexA=cf.IndexB,cp.Id.ContactFeature.IndexB=cf.IndexA,cp.Id.ContactFeature.TypeA=cf.TypeB,cp.Id.ContactFeature.TypeB=cf.TypeA),manifold.v.Points.setItem(pointCount,cp.$clone()),pointCount=pointCount+1|0);manifold.v.PointCount=pointCount}}},FindMaxSeparation:function(edgeIndex,poly1,xf1,poly2,xf2){for(var j,sij,count1=poly1.Vertices.Count,count2=poly2.Vertices.Count,n1s=poly1.Normals,v1s=poly1.Vertices,v2s=poly2.Vertices,xf={v:VelcroPhysics.Utilities.MathUtils.MulT$10(xf2.v.$clone(),xf1.v.$clone())},bestIndex=0,maxSeparation=-340282347e30,i=0;i<count1;i=i+1|0){var n=VelcroPhysics.Utilities.MathUtils.Mul$3(Bridge.ref(xf.v,"q"),n1s.getItem(i).$clone()),v1=VelcroPhysics.Utilities.MathUtils.Mul$4(xf,v1s.getItem(i).$clone()),si=VelcroPhysics.Settings.MaxFloat;for(j=0;j<count2;j=j+1|0)sij=Microsoft.Xna.Framework.Vector2.Dot(n.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(v2s.getItem(j).$clone(),v1.$clone())),sij<si&&(si=sij);si>maxSeparation&&(maxSeparation=si,bestIndex=i)}return edgeIndex.v=bestIndex,maxSeparation},FindIncidentEdge:function(c,poly1,xf1,edge1,poly2,xf2){var normals1=poly1.Normals,count2=poly2.Vertices.Count,vertices2=poly2.Vertices,normals2=poly2.Normals,i,dot,i1,i2;System.Diagnostics.Debug.Assert(0<=edge1&&edge1<poly1.Vertices.Count);var normal1=VelcroPhysics.Utilities.MathUtils.MulT$3(Bridge.ref(xf2.v,"q"),VelcroPhysics.Utilities.MathUtils.Mul$3(Bridge.ref(xf1.v,"q"),normals1.getItem(edge1).$clone())),index=0,minDot=VelcroPhysics.Settings.MaxFloat;for(i=0;i<count2;i=i+1|0)dot=Microsoft.Xna.Framework.Vector2.Dot(normal1.$clone(),normals2.getItem(i).$clone()),dot<minDot&&(minDot=dot,index=i);i1=index;i2=(i1+1|0)<count2?i1+1|0:0;c.v=new(VelcroPhysics.Shared.Optimization.FixedArray2$1(VelcroPhysics.Collision.Narrowphase.ClipVertex));c.v.Value0.V=VelcroPhysics.Utilities.MathUtils.Mul$4(xf2,vertices2.getItem(i1).$clone());c.v.Value0.ID.ContactFeature.IndexA=edge1&255;c.v.Value0.ID.ContactFeature.IndexB=i1&255;c.v.Value0.ID.ContactFeature.TypeA=VelcroPhysics.Collision.ContactSystem.ContactFeatureType.Face;c.v.Value0.ID.ContactFeature.TypeB=VelcroPhysics.Collision.ContactSystem.ContactFeatureType.Vertex;c.v.Value1.V=VelcroPhysics.Utilities.MathUtils.Mul$4(xf2,vertices2.getItem(i2).$clone());c.v.Value1.ID.ContactFeature.IndexA=edge1&255;c.v.Value1.ID.ContactFeature.IndexB=i2&255;c.v.Value1.ID.ContactFeature.TypeA=VelcroPhysics.Collision.ContactSystem.ContactFeatureType.Face;c.v.Value1.ID.ContactFeature.TypeB=VelcroPhysics.Collision.ContactSystem.ContactFeatureType.Vertex}}}});Bridge.define("VelcroPhysics.Collision.Narrowphase.Collision",{statics:{methods:{TestOverlap:function(shapeA,indexA,shapeB,indexB,xfA,xfB){var input={v:new VelcroPhysics.Collision.Distance.DistanceInput},cache,output;return input.v.ProxyA=new VelcroPhysics.Collision.Distance.DistanceProxy.$ctor1(shapeA,indexA),input.v.ProxyB=new VelcroPhysics.Collision.Distance.DistanceProxy.$ctor1(shapeB,indexB),input.v.TransformA=xfA.v.$clone(),input.v.TransformB=xfB.v.$clone(),input.v.UseRadii=!0,cache={v:new VelcroPhysics.Collision.Narrowphase.SimplexCache},output={v:new VelcroPhysics.Collision.Distance.DistanceOutput},VelcroPhysics.Collision.Distance.DistanceGJK.ComputeDistance(input,output,cache),output.v.Distance<11920929e-13},GetPointStates:function(state1,state2,manifold1,manifold2){var i,i1,id,j,i2,id1,j1;for(state1.v=new(VelcroPhysics.Shared.Optimization.FixedArray2$1(VelcroPhysics.Collision.Narrowphase.PointState)),state2.v=new(VelcroPhysics.Shared.Optimization.FixedArray2$1(VelcroPhysics.Collision.Narrowphase.PointState)),i=0;i<VelcroPhysics.Settings.MaxManifoldPoints;i=i+1|0)state1.v.setItem(i,VelcroPhysics.Collision.Narrowphase.PointState.Null),state2.v.setItem(i,VelcroPhysics.Collision.Narrowphase.PointState.Null);for(i1=0;i1<manifold1.v.PointCount;i1=i1+1|0)for(id=manifold1.v.Points.getItem(i1).$clone().Id.$clone(),state1.v.setItem(i1,VelcroPhysics.Collision.Narrowphase.PointState.Remove),j=0;j<manifold2.v.PointCount;j=j+1|0)if(manifold2.v.Points.getItem(j).$clone().Id.Key===id.Key){state1.v.setItem(i1,VelcroPhysics.Collision.Narrowphase.PointState.Persist);break}for(i2=0;i2<manifold2.v.PointCount;i2=i2+1|0)for(id1=manifold2.v.Points.getItem(i2).$clone().Id.$clone(),state2.v.setItem(i2,VelcroPhysics.Collision.Narrowphase.PointState.Add),j1=0;j1<manifold1.v.PointCount;j1=j1+1|0)if(manifold1.v.Points.getItem(j1).$clone().Id.Key===id1.Key){state2.v.setItem(i2,VelcroPhysics.Collision.Narrowphase.PointState.Persist);break}},ClipSegmentToLine:function(vOut,vIn,normal,offset,vertexIndexA){var interp,cv;vOut.v=new(VelcroPhysics.Shared.Optimization.FixedArray2$1(VelcroPhysics.Collision.Narrowphase.ClipVertex));var numOut=0,distance0=Microsoft.Xna.Framework.Vector2.Dot(normal.$clone(),vIn.v.Value0.V.$clone())-offset,distance1=Microsoft.Xna.Framework.Vector2.Dot(normal.$clone(),vIn.v.Value1.V.$clone())-offset;return distance0<=0&&vOut.v.setItem(Bridge.identity(numOut,numOut=numOut+1|0),vIn.v.Value0.$clone()),distance1<=0&&vOut.v.setItem(Bridge.identity(numOut,numOut=numOut+1|0),vIn.v.Value1.$clone()),distance0*distance1<0&&(interp=distance0/(distance0-distance1),cv=vOut.v.getItem(numOut).$clone(),cv.V=Microsoft.Xna.Framework.Vector2.op_Addition(vIn.v.Value0.V.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(interp,Microsoft.Xna.Framework.Vector2.op_Subtraction(vIn.v.Value1.V.$clone(),vIn.v.Value0.V.$clone()))),cv.ID.ContactFeature.IndexA=vertexIndexA&255,cv.ID.ContactFeature.IndexB=vIn.v.Value0.ID.ContactFeature.IndexB,cv.ID.ContactFeature.TypeA=VelcroPhysics.Collision.ContactSystem.ContactFeatureType.Vertex,cv.ID.ContactFeature.TypeB=VelcroPhysics.Collision.ContactSystem.ContactFeatureType.Face,vOut.v.setItem(numOut,cv.$clone()),numOut=numOut+1|0),numOut}}}});Bridge.define("VelcroPhysics.Collision.Narrowphase.EPAxis",{$kind:"struct",statics:{methods:{getDefaultValue:function(){return new VelcroPhysics.Collision.Narrowphase.EPAxis}}},fields:{Index:0,Separation:0,Type:0},ctors:{ctor:function(){this.$initialize()}},methods:{getHashCode:function(){return Bridge.addHash([2017575854,this.Index,this.Separation,this.Type])},equals:function(o){return Bridge.is(o,VelcroPhysics.Collision.Narrowphase.EPAxis)?Bridge.equals(this.Index,o.Index)&&Bridge.equals(this.Separation,o.Separation)&&Bridge.equals(this.Type,o.Type):!1},$clone:function(to){var s=to||new VelcroPhysics.Collision.Narrowphase.EPAxis;return s.Index=this.Index,s.Separation=this.Separation,s.Type=this.Type,s}}});Bridge.define("VelcroPhysics.Collision.Narrowphase.EPAxisType",{$kind:"enum",statics:{fields:{Unknown:0,EdgeA:1,EdgeB:2}}});Bridge.define("VelcroPhysics.Collision.Narrowphase.EPCollider",{statics:{methods:{Collide:function(manifold,edgeA,xfA,polygonB,xfB){var front,lowerLimit=new Microsoft.Xna.Framework.Vector2,upperLimit=new Microsoft.Xna.Framework.Vector2,normal=new Microsoft.Xna.Framework.Vector2,normal0=Microsoft.Xna.Framework.Vector2.Zero.$clone(),normal2=Microsoft.Xna.Framework.Vector2.Zero.$clone(),xf={v:VelcroPhysics.Utilities.MathUtils.MulT$10(xfA.v.$clone(),xfB.v.$clone())},centroidB=VelcroPhysics.Utilities.MathUtils.Mul$4(xf,polygonB.MassData.Centroid.$clone()),v0=edgeA.Vertex0.$clone(),v1=edgeA._vertex1.$clone(),v2=edgeA._vertex2.$clone(),v3=edgeA.Vertex3.$clone(),hasVertex0=edgeA.HasVertex0,hasVertex3=edgeA.HasVertex3,edge1=Microsoft.Xna.Framework.Vector2.op_Subtraction(v2.$clone(),v1.$clone()),edge0,edge2,i,radius,edgeAxis,s,polygonAxis,perp,ie,rf,bestIndex,bestValue,i3,value,i1,i2,clipPoints1,clipPoints2,np,pointCount,i4,separation,cp;edge1.Normalize();var normal1=new Microsoft.Xna.Framework.Vector2.$ctor2(edge1.Y,-edge1.X),offset1=Microsoft.Xna.Framework.Vector2.Dot(normal1.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(centroidB.$clone(),v1.$clone())),offset0=0,offset2=0,convex1=!1,convex2=!1;hasVertex0&&(edge0=Microsoft.Xna.Framework.Vector2.op_Subtraction(v1.$clone(),v0.$clone()),edge0.Normalize(),normal0=new Microsoft.Xna.Framework.Vector2.$ctor2(edge0.Y,-edge0.X),convex1=VelcroPhysics.Utilities.MathUtils.Cross$3(edge0.$clone(),edge1.$clone())>=0,offset0=Microsoft.Xna.Framework.Vector2.Dot(normal0.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(centroidB.$clone(),v0.$clone())));hasVertex3&&(edge2=Microsoft.Xna.Framework.Vector2.op_Subtraction(v3.$clone(),v2.$clone()),edge2.Normalize(),normal2=new Microsoft.Xna.Framework.Vector2.$ctor2(edge2.Y,-edge2.X),convex2=VelcroPhysics.Utilities.MathUtils.Cross$3(edge1.$clone(),edge2.$clone())>0,offset2=Microsoft.Xna.Framework.Vector2.Dot(normal2.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(centroidB.$clone(),v2.$clone())));hasVertex0&&hasVertex3?convex1&&convex2?(front=offset0>=0||offset1>=0||offset2>=0,front?(normal=normal1.$clone(),lowerLimit=normal0.$clone(),upperLimit=normal2.$clone()):(normal=Microsoft.Xna.Framework.Vector2.op_UnaryNegation(normal1.$clone()),lowerLimit=Microsoft.Xna.Framework.Vector2.op_UnaryNegation(normal1.$clone()),upperLimit=Microsoft.Xna.Framework.Vector2.op_UnaryNegation(normal1.$clone()))):convex1?(front=offset0>=0||offset1>=0&&offset2>=0,front?(normal=normal1.$clone(),lowerLimit=normal0.$clone(),upperLimit=normal1.$clone()):(normal=Microsoft.Xna.Framework.Vector2.op_UnaryNegation(normal1.$clone()),lowerLimit=Microsoft.Xna.Framework.Vector2.op_UnaryNegation(normal2.$clone()),upperLimit=Microsoft.Xna.Framework.Vector2.op_UnaryNegation(normal1.$clone()))):convex2?(front=offset2>=0||offset0>=0&&offset1>=0,front?(normal=normal1.$clone(),lowerLimit=normal1.$clone(),upperLimit=normal2.$clone()):(normal=Microsoft.Xna.Framework.Vector2.op_UnaryNegation(normal1.$clone()),lowerLimit=Microsoft.Xna.Framework.Vector2.op_UnaryNegation(normal1.$clone()),upperLimit=Microsoft.Xna.Framework.Vector2.op_UnaryNegation(normal0.$clone()))):(front=offset0>=0&&offset1>=0&&offset2>=0,front?(normal=normal1.$clone(),lowerLimit=normal1.$clone(),upperLimit=normal1.$clone()):(normal=Microsoft.Xna.Framework.Vector2.op_UnaryNegation(normal1.$clone()),lowerLimit=Microsoft.Xna.Framework.Vector2.op_UnaryNegation(normal2.$clone()),upperLimit=Microsoft.Xna.Framework.Vector2.op_UnaryNegation(normal0.$clone()))):hasVertex0?convex1?(front=offset0>=0||offset1>=0,front?(normal=normal1.$clone(),lowerLimit=normal0.$clone(),upperLimit=Microsoft.Xna.Framework.Vector2.op_UnaryNegation(normal1.$clone())):(normal=Microsoft.Xna.Framework.Vector2.op_UnaryNegation(normal1.$clone()),lowerLimit=normal1.$clone(),upperLimit=Microsoft.Xna.Framework.Vector2.op_UnaryNegation(normal1.$clone()))):(front=offset0>=0&&offset1>=0,front?(normal=normal1.$clone(),lowerLimit=normal1.$clone(),upperLimit=Microsoft.Xna.Framework.Vector2.op_UnaryNegation(normal1.$clone())):(normal=Microsoft.Xna.Framework.Vector2.op_UnaryNegation(normal1.$clone()),lowerLimit=normal1.$clone(),upperLimit=Microsoft.Xna.Framework.Vector2.op_UnaryNegation(normal0.$clone()))):hasVertex3?convex2?(front=offset1>=0||offset2>=0,front?(normal=normal1.$clone(),lowerLimit=Microsoft.Xna.Framework.Vector2.op_UnaryNegation(normal1.$clone()),upperLimit=normal2.$clone()):(normal=Microsoft.Xna.Framework.Vector2.op_UnaryNegation(normal1.$clone()),lowerLimit=Microsoft.Xna.Framework.Vector2.op_UnaryNegation(normal1.$clone()),upperLimit=normal1.$clone())):(front=offset1>=0&&offset2>=0,front?(normal=normal1.$clone(),lowerLimit=Microsoft.Xna.Framework.Vector2.op_UnaryNegation(normal1.$clone()),upperLimit=normal1.$clone()):(normal=Microsoft.Xna.Framework.Vector2.op_UnaryNegation(normal1.$clone()),lowerLimit=Microsoft.Xna.Framework.Vector2.op_UnaryNegation(normal2.$clone()),upperLimit=normal1.$clone())):(front=offset1>=0,front?(normal=normal1.$clone(),lowerLimit=Microsoft.Xna.Framework.Vector2.op_UnaryNegation(normal1.$clone()),upperLimit=Microsoft.Xna.Framework.Vector2.op_UnaryNegation(normal1.$clone())):(normal=Microsoft.Xna.Framework.Vector2.op_UnaryNegation(normal1.$clone()),lowerLimit=normal1.$clone(),upperLimit=normal1.$clone()));var normals=System.Array.init(VelcroPhysics.Settings.MaxPolygonVertices,function(){return new Microsoft.Xna.Framework.Vector2},Microsoft.Xna.Framework.Vector2),vertices=System.Array.init(VelcroPhysics.Settings.MaxPolygonVertices,function(){return new Microsoft.Xna.Framework.Vector2},Microsoft.Xna.Framework.Vector2),count=polygonB.Vertices.Count;for(i=0;i<polygonB.Vertices.Count;i=i+1|0)vertices[i]=VelcroPhysics.Utilities.MathUtils.Mul$4(xf,polygonB.Vertices.getItem(i).$clone()),normals[i]=VelcroPhysics.Utilities.MathUtils.Mul$2(xf.v.q.$clone(),polygonB.Normals.getItem(i).$clone());for(radius=polygonB.Radius+edgeA.Radius,manifold.v.PointCount=0,edgeAxis=new VelcroPhysics.Collision.Narrowphase.EPAxis,edgeAxis.Type=VelcroPhysics.Collision.Narrowphase.EPAxisType.EdgeA,edgeAxis.Index=front?0:1,edgeAxis.Separation=VelcroPhysics.Settings.MaxFloat,i1=0;i1<count;i1=i1+1|0)s=Microsoft.Xna.Framework.Vector2.Dot(normal.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(vertices[i1].$clone(),v1.$clone())),s<edgeAxis.Separation&&(edgeAxis.Separation=s);if(edgeAxis.Type!==VelcroPhysics.Collision.Narrowphase.EPAxisType.Unknown&&!(edgeAxis.Separation>radius)){for(polygonAxis=new VelcroPhysics.Collision.Narrowphase.EPAxis,polygonAxis.Type=VelcroPhysics.Collision.Narrowphase.EPAxisType.Unknown,polygonAxis.Index=-1,polygonAxis.Separation=-340282347e30,perp=new Microsoft.Xna.Framework.Vector2.$ctor2(-normal.Y,normal.X),i2=0;i2<count;i2=i2+1|0){var n=Microsoft.Xna.Framework.Vector2.op_UnaryNegation(normals[i2].$clone()),s1=Microsoft.Xna.Framework.Vector2.Dot(n.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(vertices[i2].$clone(),v1.$clone())),s2=Microsoft.Xna.Framework.Vector2.Dot(n.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(vertices[i2].$clone(),v2.$clone())),s3=Math.min(s1,s2);if(s3>radius){polygonAxis.Type=VelcroPhysics.Collision.Narrowphase.EPAxisType.EdgeB;polygonAxis.Index=i2;polygonAxis.Separation=s3;break}if(Microsoft.Xna.Framework.Vector2.Dot(n.$clone(),perp.$clone())>=0){if(Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(n.$clone(),upperLimit.$clone()),normal.$clone())<-.03490659)continue}else if(Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(n.$clone(),lowerLimit.$clone()),normal.$clone())<-.03490659)continue;s3>polygonAxis.Separation&&(polygonAxis.Type=VelcroPhysics.Collision.Narrowphase.EPAxisType.EdgeB,polygonAxis.Index=i2,polygonAxis.Separation=s3)}if(polygonAxis.Type===VelcroPhysics.Collision.Narrowphase.EPAxisType.Unknown||!(polygonAxis.Separation>radius)){var k_relativeTol=.98,k_absoluteTol=.001,primaryAxis=new VelcroPhysics.Collision.Narrowphase.EPAxis;if(primaryAxis=polygonAxis.Type===VelcroPhysics.Collision.Narrowphase.EPAxisType.Unknown?edgeAxis.$clone():polygonAxis.Separation>k_relativeTol*edgeAxis.Separation+k_absoluteTol?polygonAxis.$clone():edgeAxis.$clone(),ie={v:new(VelcroPhysics.Shared.Optimization.FixedArray2$1(VelcroPhysics.Collision.Narrowphase.ClipVertex))},rf=new VelcroPhysics.Collision.Narrowphase.ReferenceFace,primaryAxis.Type===VelcroPhysics.Collision.Narrowphase.EPAxisType.EdgeA){for(manifold.v.Type=VelcroPhysics.Collision.Narrowphase.ManifoldType.FaceA,bestIndex=0,bestValue=Microsoft.Xna.Framework.Vector2.Dot(normal.$clone(),normals[0].$clone()),i3=1;i3<count;i3=i3+1|0)value=Microsoft.Xna.Framework.Vector2.Dot(normal.$clone(),normals[i3].$clone()),value<bestValue&&(bestValue=value,bestIndex=i3);i1=bestIndex;i2=(i1+1|0)<count?i1+1|0:0;ie.v.Value0.V=vertices[i1].$clone();ie.v.Value0.ID.ContactFeature.IndexA=0;ie.v.Value0.ID.ContactFeature.IndexB=i1&255;ie.v.Value0.ID.ContactFeature.TypeA=VelcroPhysics.Collision.ContactSystem.ContactFeatureType.Face;ie.v.Value0.ID.ContactFeature.TypeB=VelcroPhysics.Collision.ContactSystem.ContactFeatureType.Vertex;ie.v.Value1.V=vertices[i2].$clone();ie.v.Value1.ID.ContactFeature.IndexA=0;ie.v.Value1.ID.ContactFeature.IndexB=i2&255;ie.v.Value1.ID.ContactFeature.TypeA=VelcroPhysics.Collision.ContactSystem.ContactFeatureType.Face;ie.v.Value1.ID.ContactFeature.TypeB=VelcroPhysics.Collision.ContactSystem.ContactFeatureType.Vertex;front?(rf.i1=0,rf.i2=1,rf.v1=v1.$clone(),rf.v2=v2.$clone(),rf.Normal=normal1.$clone()):(rf.i1=1,rf.i2=0,rf.v1=v2.$clone(),rf.v2=v1.$clone(),rf.Normal=Microsoft.Xna.Framework.Vector2.op_UnaryNegation(normal1.$clone()))}else manifold.v.Type=VelcroPhysics.Collision.Narrowphase.ManifoldType.FaceB,ie.v.Value0.V=v1.$clone(),ie.v.Value0.ID.ContactFeature.IndexA=0,ie.v.Value0.ID.ContactFeature.IndexB=primaryAxis.Index&255,ie.v.Value0.ID.ContactFeature.TypeA=VelcroPhysics.Collision.ContactSystem.ContactFeatureType.Vertex,ie.v.Value0.ID.ContactFeature.TypeB=VelcroPhysics.Collision.ContactSystem.ContactFeatureType.Face,ie.v.Value1.V=v2.$clone(),ie.v.Value1.ID.ContactFeature.IndexA=0,ie.v.Value1.ID.ContactFeature.IndexB=primaryAxis.Index&255,ie.v.Value1.ID.ContactFeature.TypeA=VelcroPhysics.Collision.ContactSystem.ContactFeatureType.Vertex,ie.v.Value1.ID.ContactFeature.TypeB=VelcroPhysics.Collision.ContactSystem.ContactFeatureType.Face,rf.i1=primaryAxis.Index,rf.i2=(rf.i1+1|0)<count?rf.i1+1|0:0,rf.v1=vertices[rf.i1].$clone(),rf.v2=vertices[rf.i2].$clone(),rf.Normal=normals[rf.i1].$clone();if((rf.SideNormal1=new Microsoft.Xna.Framework.Vector2.$ctor2(rf.Normal.Y,-rf.Normal.X),rf.SideNormal2=Microsoft.Xna.Framework.Vector2.op_UnaryNegation(rf.SideNormal1.$clone()),rf.SideOffset1=Microsoft.Xna.Framework.Vector2.Dot(rf.SideNormal1.$clone(),rf.v1.$clone()),rf.SideOffset2=Microsoft.Xna.Framework.Vector2.Dot(rf.SideNormal2.$clone(),rf.v2.$clone()),clipPoints1={v:new(VelcroPhysics.Shared.Optimization.FixedArray2$1(VelcroPhysics.Collision.Narrowphase.ClipVertex))},clipPoints2={v:new(VelcroPhysics.Shared.Optimization.FixedArray2$1(VelcroPhysics.Collision.Narrowphase.ClipVertex))},np=VelcroPhysics.Collision.Narrowphase.Collision.ClipSegmentToLine(clipPoints1,ie,rf.SideNormal1.$clone(),rf.SideOffset1,rf.i1),!(np<VelcroPhysics.Settings.MaxManifoldPoints))&&(np=VelcroPhysics.Collision.Narrowphase.Collision.ClipSegmentToLine(clipPoints2,clipPoints1,rf.SideNormal2.$clone(),rf.SideOffset2,rf.i2),!(np<VelcroPhysics.Settings.MaxManifoldPoints))){for(primaryAxis.Type===VelcroPhysics.Collision.Narrowphase.EPAxisType.EdgeA?(manifold.v.LocalNormal=rf.Normal.$clone(),manifold.v.LocalPoint=rf.v1.$clone()):(manifold.v.LocalNormal=polygonB.Normals.getItem(rf.i1).$clone(),manifold.v.LocalPoint=polygonB.Vertices.getItem(rf.i1).$clone()),pointCount=0,i4=0;i4<VelcroPhysics.Settings.MaxManifoldPoints;i4=i4+1|0)separation=Microsoft.Xna.Framework.Vector2.Dot(rf.Normal.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(clipPoints2.v.getItem(i4).$clone().V.$clone(),rf.v1.$clone())),separation<=radius&&(cp=manifold.v.Points.getItem(pointCount).$clone(),primaryAxis.Type===VelcroPhysics.Collision.Narrowphase.EPAxisType.EdgeA?(cp.LocalPoint=VelcroPhysics.Utilities.MathUtils.MulT$5(xf,clipPoints2.v.getItem(i4).$clone().V.$clone()),cp.Id=clipPoints2.v.getItem(i4).$clone().ID.$clone()):(cp.LocalPoint=clipPoints2.v.getItem(i4).$clone().V.$clone(),cp.Id.ContactFeature.TypeA=clipPoints2.v.getItem(i4).$clone().ID.ContactFeature.TypeB,cp.Id.ContactFeature.TypeB=clipPoints2.v.getItem(i4).$clone().ID.ContactFeature.TypeA,cp.Id.ContactFeature.IndexA=clipPoints2.v.getItem(i4).$clone().ID.ContactFeature.IndexB,cp.Id.ContactFeature.IndexB=clipPoints2.v.getItem(i4).$clone().ID.ContactFeature.IndexA),manifold.v.Points.setItem(pointCount,cp.$clone()),pointCount=pointCount+1|0);manifold.v.PointCount=pointCount}}}}}}});Bridge.define("VelcroPhysics.Collision.Narrowphase.Manifold",{$kind:"struct",statics:{methods:{getDefaultValue:function(){return new VelcroPhysics.Collision.Narrowphase.Manifold}}},fields:{LocalNormal:null,LocalPoint:null,PointCount:0,Points:null,Type:0},ctors:{init:function(){this.LocalNormal=new Microsoft.Xna.Framework.Vector2;this.LocalPoint=new Microsoft.Xna.Framework.Vector2;this.Points=new(VelcroPhysics.Shared.Optimization.FixedArray2$1(VelcroPhysics.Collision.Narrowphase.ManifoldPoint))},ctor:function(){this.$initialize()}},methods:{getHashCode:function(){return Bridge.addHash([3453669555,this.LocalNormal,this.LocalPoint,this.PointCount,this.Points,this.Type])},equals:function(o){return Bridge.is(o,VelcroPhysics.Collision.Narrowphase.Manifold)?Bridge.equals(this.LocalNormal,o.LocalNormal)&&Bridge.equals(this.LocalPoint,o.LocalPoint)&&Bridge.equals(this.PointCount,o.PointCount)&&Bridge.equals(this.Points,o.Points)&&Bridge.equals(this.Type,o.Type):!1},$clone:function(to){var s=to||new VelcroPhysics.Collision.Narrowphase.Manifold;return s.LocalNormal=this.LocalNormal.$clone(),s.LocalPoint=this.LocalPoint.$clone(),s.PointCount=this.PointCount,s.Points=this.Points.$clone(),s.Type=this.Type,s}}});Bridge.define("VelcroPhysics.Collision.Narrowphase.ManifoldPoint",{$kind:"struct",statics:{methods:{getDefaultValue:function(){return new VelcroPhysics.Collision.Narrowphase.ManifoldPoint}}},fields:{Id:null,LocalPoint:null,NormalImpulse:0,TangentImpulse:0},ctors:{init:function(){this.Id=new VelcroPhysics.Collision.ContactSystem.ContactID;this.LocalPoint=new Microsoft.Xna.Framework.Vector2},ctor:function(){this.$initialize()}},methods:{getHashCode:function(){return Bridge.addHash([5306073207,this.Id,this.LocalPoint,this.NormalImpulse,this.TangentImpulse])},equals:function(o){return Bridge.is(o,VelcroPhysics.Collision.Narrowphase.ManifoldPoint)?Bridge.equals(this.Id,o.Id)&&Bridge.equals(this.LocalPoint,o.LocalPoint)&&Bridge.equals(this.NormalImpulse,o.NormalImpulse)&&Bridge.equals(this.TangentImpulse,o.TangentImpulse):!1},$clone:function(to){var s=to||new VelcroPhysics.Collision.Narrowphase.ManifoldPoint;return s.Id=this.Id.$clone(),s.LocalPoint=this.LocalPoint.$clone(),s.NormalImpulse=this.NormalImpulse,s.TangentImpulse=this.TangentImpulse,s}}});Bridge.define("VelcroPhysics.Collision.Narrowphase.ManifoldType",{$kind:"enum",statics:{fields:{Circles:0,FaceA:1,FaceB:2}}});Bridge.define("VelcroPhysics.Collision.Narrowphase.PointState",{$kind:"enum",statics:{fields:{Null:0,Add:1,Persist:2,Remove:3}}});Bridge.define("VelcroPhysics.Collision.Narrowphase.ReferenceFace",{$kind:"struct",statics:{methods:{getDefaultValue:function(){return new VelcroPhysics.Collision.Narrowphase.ReferenceFace}}},fields:{i1:0,i2:0,v1:null,v2:null,Normal:null,SideNormal1:null,SideOffset1:0,SideNormal2:null,SideOffset2:0},ctors:{init:function(){this.v1=new Microsoft.Xna.Framework.Vector2;this.v2=new Microsoft.Xna.Framework.Vector2;this.Normal=new Microsoft.Xna.Framework.Vector2;this.SideNormal1=new Microsoft.Xna.Framework.Vector2;this.SideNormal2=new Microsoft.Xna.Framework.Vector2},ctor:function(){this.$initialize()}},methods:{getHashCode:function(){return Bridge.addHash([5036708238,this.i1,this.i2,this.v1,this.v2,this.Normal,this.SideNormal1,this.SideOffset1,this.SideNormal2,this.SideOffset2])},equals:function(o){return Bridge.is(o,VelcroPhysics.Collision.Narrowphase.ReferenceFace)?Bridge.equals(this.i1,o.i1)&&Bridge.equals(this.i2,o.i2)&&Bridge.equals(this.v1,o.v1)&&Bridge.equals(this.v2,o.v2)&&Bridge.equals(this.Normal,o.Normal)&&Bridge.equals(this.SideNormal1,o.SideNormal1)&&Bridge.equals(this.SideOffset1,o.SideOffset1)&&Bridge.equals(this.SideNormal2,o.SideNormal2)&&Bridge.equals(this.SideOffset2,o.SideOffset2):!1},$clone:function(to){var s=to||new VelcroPhysics.Collision.Narrowphase.ReferenceFace;return s.i1=this.i1,s.i2=this.i2,s.v1=this.v1.$clone(),s.v2=this.v2.$clone(),s.Normal=this.Normal.$clone(),s.SideNormal1=this.SideNormal1.$clone(),s.SideOffset1=this.SideOffset1,s.SideNormal2=this.SideNormal2.$clone(),s.SideOffset2=this.SideOffset2,s}}});Bridge.define("VelcroPhysics.Collision.Narrowphase.Simplex",{$kind:"struct",statics:{methods:{getDefaultValue:function(){return new VelcroPhysics.Collision.Narrowphase.Simplex}}},fields:{Count:0,V:null},ctors:{init:function(){this.V=new(VelcroPhysics.Shared.Optimization.FixedArray3$1(VelcroPhysics.Collision.Narrowphase.SimplexVertex))},ctor:function(){this.$initialize()}},methods:{ReadCache:function(cache,proxyA,transformA,proxyB,transformB){var i,v,wALocal,wBLocal,metric1,metric2,v1,wALocal1,wBLocal1;for(System.Diagnostics.Debug.Assert(cache.v.Count<=3),this.Count=cache.v.Count,i=0;i<this.Count;i=i+1|0)v=this.V.getItem(i).$clone(),v.IndexA=cache.v.IndexA.getItem(i),v.IndexB=cache.v.IndexB.getItem(i),wALocal=proxyA.v.Vertices[v.IndexA].$clone(),wBLocal=proxyB.v.Vertices[v.IndexB].$clone(),v.WA=VelcroPhysics.Utilities.MathUtils.Mul$4(transformA,wALocal.$clone()),v.WB=VelcroPhysics.Utilities.MathUtils.Mul$4(transformB,wBLocal.$clone()),v.W=Microsoft.Xna.Framework.Vector2.op_Subtraction(v.WB.$clone(),v.WA.$clone()),v.A=0,this.V.setItem(i,v.$clone());this.Count>1&&(metric1=cache.v.Metric,metric2=this.GetMetric(),(metric2<.5*metric1||2*metric1<metric2||metric2<VelcroPhysics.Settings.Epsilon)&&(this.Count=0));this.Count===0&&(v1=this.V.getItem(0).$clone(),v1.IndexA=0,v1.IndexB=0,wALocal1=proxyA.v.Vertices[0].$clone(),wBLocal1=proxyB.v.Vertices[0].$clone(),v1.WA=VelcroPhysics.Utilities.MathUtils.Mul$4(transformA,wALocal1.$clone()),v1.WB=VelcroPhysics.Utilities.MathUtils.Mul$4(transformB,wBLocal1.$clone()),v1.W=Microsoft.Xna.Framework.Vector2.op_Subtraction(v1.WB.$clone(),v1.WA.$clone()),v1.A=1,this.V.setItem(0,v1.$clone()),this.Count=1)},WriteCache:function(cache){cache.v.Metric=this.GetMetric();cache.v.Count=this.Count&65535;for(var i=0;i<this.Count;i=i+1|0)cache.v.IndexA.setItem(i,this.V.getItem(i).$clone().IndexA&255),cache.v.IndexB.setItem(i,this.V.getItem(i).$clone().IndexB&255)},GetSearchDirection:function(){switch(this.Count){case 1:return Microsoft.Xna.Framework.Vector2.op_UnaryNegation(this.V.getItem(0).$clone().W.$clone());case 2:var e12=Microsoft.Xna.Framework.Vector2.op_Subtraction(this.V.getItem(1).$clone().W.$clone(),this.V.getItem(0).$clone().W.$clone()),sgn=VelcroPhysics.Utilities.MathUtils.Cross$3(e12.$clone(),Microsoft.Xna.Framework.Vector2.op_UnaryNegation(this.V.getItem(0).$clone().W.$clone()));return sgn>0?VelcroPhysics.Utilities.MathUtils.Cross$1(1,e12.$clone()):VelcroPhysics.Utilities.MathUtils.Cross(e12.$clone(),1);default:return System.Diagnostics.Debug.Assert(!1),Microsoft.Xna.Framework.Vector2.Zero.$clone()}},GetClosestPoint:function(){switch(this.Count){case 0:return System.Diagnostics.Debug.Assert(!1),Microsoft.Xna.Framework.Vector2.Zero.$clone();case 1:return this.V.getItem(0).$clone().W.$clone();case 2:return Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.V.getItem(0).$clone().A,this.V.getItem(0).$clone().W.$clone()),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.V.getItem(1).$clone().A,this.V.getItem(1).$clone().W.$clone()));case 3:return Microsoft.Xna.Framework.Vector2.Zero.$clone();default:return System.Diagnostics.Debug.Assert(!1),Microsoft.Xna.Framework.Vector2.Zero.$clone()}},GetWitnessPoints:function(pA,pB){switch(this.Count){case 0:pA.v=Microsoft.Xna.Framework.Vector2.Zero.$clone();pB.v=Microsoft.Xna.Framework.Vector2.Zero.$clone();System.Diagnostics.Debug.Assert(!1);break;case 1:pA.v=this.V.getItem(0).$clone().WA.$clone();pB.v=this.V.getItem(0).$clone().WB.$clone();break;case 2:pA.v=Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.V.getItem(0).$clone().A,this.V.getItem(0).$clone().WA.$clone()),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.V.getItem(1).$clone().A,this.V.getItem(1).$clone().WA.$clone()));pB.v=Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.V.getItem(0).$clone().A,this.V.getItem(0).$clone().WB.$clone()),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.V.getItem(1).$clone().A,this.V.getItem(1).$clone().WB.$clone()));break;case 3:pA.v=Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.V.getItem(0).$clone().A,this.V.getItem(0).$clone().WA.$clone()),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.V.getItem(1).$clone().A,this.V.getItem(1).$clone().WA.$clone())),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.V.getItem(2).$clone().A,this.V.getItem(2).$clone().WA.$clone()));pB.v=pA.v.$clone();break;default:throw new System.Exception;}},GetMetric:function(){switch(this.Count){case 0:return System.Diagnostics.Debug.Assert(!1),0;case 1:return 0;case 2:return Microsoft.Xna.Framework.Vector2.op_Subtraction(this.V.getItem(0).$clone().W.$clone(),this.V.getItem(1).$clone().W.$clone()).Length();case 3:return VelcroPhysics.Utilities.MathUtils.Cross$3(Microsoft.Xna.Framework.Vector2.op_Subtraction(this.V.getItem(1).$clone().W.$clone(),this.V.getItem(0).$clone().W.$clone()),Microsoft.Xna.Framework.Vector2.op_Subtraction(this.V.getItem(2).$clone().W.$clone(),this.V.getItem(0).$clone().W.$clone()));default:return System.Diagnostics.Debug.Assert(!1),0}},Solve2:function(){var w1=this.V.getItem(0).$clone().W.$clone(),w2=this.V.getItem(1).$clone().W.$clone(),e12=Microsoft.Xna.Framework.Vector2.op_Subtraction(w2.$clone(),w1.$clone()),d12_2=-Microsoft.Xna.Framework.Vector2.Dot(w1.$clone(),e12.$clone()),d12_1,inv_d12;if(d12_2<=0){this.V.Value0.A=1;this.Count=1;return}if(d12_1=Microsoft.Xna.Framework.Vector2.Dot(w2.$clone(),e12.$clone()),d12_1<=0){this.V.Value1.A=1;this.Count=1;this.V.Value0=this.V.Value1.$clone();return}inv_d12=1/(d12_1+d12_2);this.V.Value0.A=d12_1*inv_d12;this.V.Value1.A=d12_2*inv_d12;this.Count=2},Solve3:function(){var w1=this.V.getItem(0).$clone().W.$clone(),w2=this.V.getItem(1).$clone().W.$clone(),w3=this.V.getItem(2).$clone().W.$clone(),e12=Microsoft.Xna.Framework.Vector2.op_Subtraction(w2.$clone(),w1.$clone()),w1e12=Microsoft.Xna.Framework.Vector2.Dot(w1.$clone(),e12.$clone()),w2e12=Microsoft.Xna.Framework.Vector2.Dot(w2.$clone(),e12.$clone()),d12_1=w2e12,d12_2=-w1e12,e13=Microsoft.Xna.Framework.Vector2.op_Subtraction(w3.$clone(),w1.$clone()),w1e13=Microsoft.Xna.Framework.Vector2.Dot(w1.$clone(),e13.$clone()),w3e13=Microsoft.Xna.Framework.Vector2.Dot(w3.$clone(),e13.$clone()),d13_1=w3e13,d13_2=-w1e13,e23=Microsoft.Xna.Framework.Vector2.op_Subtraction(w3.$clone(),w2.$clone()),w2e23=Microsoft.Xna.Framework.Vector2.Dot(w2.$clone(),e23.$clone()),w3e23=Microsoft.Xna.Framework.Vector2.Dot(w3.$clone(),e23.$clone()),d23_1=w3e23,d23_2=-w2e23,n123=VelcroPhysics.Utilities.MathUtils.Cross$3(e12.$clone(),e13.$clone()),d123_1=n123*VelcroPhysics.Utilities.MathUtils.Cross$3(w2.$clone(),w3.$clone()),d123_2=n123*VelcroPhysics.Utilities.MathUtils.Cross$3(w3.$clone(),w1.$clone()),d123_3=n123*VelcroPhysics.Utilities.MathUtils.Cross$3(w1.$clone(),w2.$clone()),inv_d12,inv_d13,inv_d23,inv_d123;if(d12_2<=0&&d13_2<=0){this.V.Value0.A=1;this.Count=1;return}if(d12_1>0&&d12_2>0&&d123_3<=0){inv_d12=1/(d12_1+d12_2);this.V.Value0.A=d12_1*inv_d12;this.V.Value1.A=d12_2*inv_d12;this.Count=2;return}if(d13_1>0&&d13_2>0&&d123_2<=0){inv_d13=1/(d13_1+d13_2);this.V.Value0.A=d13_1*inv_d13;this.V.Value2.A=d13_2*inv_d13;this.Count=2;this.V.Value1=this.V.Value2.$clone();return}if(d12_1<=0&&d23_2<=0){this.V.Value1.A=1;this.Count=1;this.V.Value0=this.V.Value1.$clone();return}if(d13_1<=0&&d23_1<=0){this.V.Value2.A=1;this.Count=1;this.V.Value0=this.V.Value2.$clone();return}if(d23_1>0&&d23_2>0&&d123_1<=0){inv_d23=1/(d23_1+d23_2);this.V.Value1.A=d23_1*inv_d23;this.V.Value2.A=d23_2*inv_d23;this.Count=2;this.V.Value0=this.V.Value2.$clone();return}inv_d123=1/(d123_1+d123_2+d123_3);this.V.Value0.A=d123_1*inv_d123;this.V.Value1.A=d123_2*inv_d123;this.V.Value2.A=d123_3*inv_d123;this.Count=3},getHashCode:function(){return Bridge.addHash([1894108863,this.Count,this.V])},equals:function(o){return Bridge.is(o,VelcroPhysics.Collision.Narrowphase.Simplex)?Bridge.equals(this.Count,o.Count)&&Bridge.equals(this.V,o.V):!1},$clone:function(to){var s=to||new VelcroPhysics.Collision.Narrowphase.Simplex;return s.Count=this.Count,s.V=this.V.$clone(),s}}});Bridge.define("VelcroPhysics.Collision.Narrowphase.SimplexCache",{$kind:"struct",statics:{methods:{getDefaultValue:function(){return new VelcroPhysics.Collision.Narrowphase.SimplexCache}}},fields:{Count:0,IndexA:null,IndexB:null,Metric:0},ctors:{init:function(){this.IndexA=new(VelcroPhysics.Shared.Optimization.FixedArray3$1(System.Byte));this.IndexB=new(VelcroPhysics.Shared.Optimization.FixedArray3$1(System.Byte))},ctor:function(){this.$initialize()}},methods:{getHashCode:function(){return Bridge.addHash([4719522336,this.Count,this.IndexA,this.IndexB,this.Metric])},equals:function(o){return Bridge.is(o,VelcroPhysics.Collision.Narrowphase.SimplexCache)?Bridge.equals(this.Count,o.Count)&&Bridge.equals(this.IndexA,o.IndexA)&&Bridge.equals(this.IndexB,o.IndexB)&&Bridge.equals(this.Metric,o.Metric):!1},$clone:function(to){var s=to||new VelcroPhysics.Collision.Narrowphase.SimplexCache;return s.Count=this.Count,s.IndexA=this.IndexA.$clone(),s.IndexB=this.IndexB.$clone(),s.Metric=this.Metric,s}}});Bridge.define("VelcroPhysics.Collision.Narrowphase.SimplexVertex",{$kind:"struct",statics:{methods:{getDefaultValue:function(){return new VelcroPhysics.Collision.Narrowphase.SimplexVertex}}},fields:{A:0,IndexA:0,IndexB:0,W:null,WA:null,WB:null},ctors:{init:function(){this.W=new Microsoft.Xna.Framework.Vector2;this.WA=new Microsoft.Xna.Framework.Vector2;this.WB=new Microsoft.Xna.Framework.Vector2},ctor:function(){this.$initialize()}},methods:{getHashCode:function(){return Bridge.addHash([5039079836,this.A,this.IndexA,this.IndexB,this.W,this.WA,this.WB])},equals:function(o){return Bridge.is(o,VelcroPhysics.Collision.Narrowphase.SimplexVertex)?Bridge.equals(this.A,o.A)&&Bridge.equals(this.IndexA,o.IndexA)&&Bridge.equals(this.IndexB,o.IndexB)&&Bridge.equals(this.W,o.W)&&Bridge.equals(this.WA,o.WA)&&Bridge.equals(this.WB,o.WB):!1},$clone:function(to){var s=to||new VelcroPhysics.Collision.Narrowphase.SimplexVertex;return s.A=this.A,s.IndexA=this.IndexA,s.IndexB=this.IndexB,s.W=this.W.$clone(),s.WA=this.WA.$clone(),s.WB=this.WB.$clone(),s}}});Bridge.define("VelcroPhysics.Collision.Narrowphase.WorldManifold",{statics:{methods:{Initialize:function(manifold,xfA,radiusA,xfB,radiusB,normal,points,separations){var pointA,pointB,cA,cB,planePoint,i,planePoint1,i1;if(normal.v=Microsoft.Xna.Framework.Vector2.Zero.$clone(),points.v=new(VelcroPhysics.Shared.Optimization.FixedArray2$1(Microsoft.Xna.Framework.Vector2)),separations.v=new(VelcroPhysics.Shared.Optimization.FixedArray2$1(System.Single)),manifold.v.PointCount!==0)switch(manifold.v.Type){case VelcroPhysics.Collision.Narrowphase.ManifoldType.Circles:normal.v=new Microsoft.Xna.Framework.Vector2.$ctor2(1,0);pointA=VelcroPhysics.Utilities.MathUtils.Mul$4(xfA,manifold.v.LocalPoint.$clone());pointB=VelcroPhysics.Utilities.MathUtils.Mul$4(xfB,manifold.v.Points.Value0.LocalPoint.$clone());Microsoft.Xna.Framework.Vector2.DistanceSquared(pointA.$clone(),pointB.$clone())>142108547e-22&&(normal.v=Microsoft.Xna.Framework.Vector2.op_Subtraction(pointB.$clone(),pointA.$clone()),normal.v.Normalize());cA=Microsoft.Xna.Framework.Vector2.op_Addition(pointA.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(radiusA,normal.v.$clone()));cB=Microsoft.Xna.Framework.Vector2.op_Subtraction(pointB.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(radiusB,normal.v.$clone()));points.v.Value0=Microsoft.Xna.Framework.Vector2.op_Multiply$2(.5,Microsoft.Xna.Framework.Vector2.op_Addition(cA.$clone(),cB.$clone()));separations.v.Value0=Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(cB.$clone(),cA.$clone()),normal.v.$clone());break;case VelcroPhysics.Collision.Narrowphase.ManifoldType.FaceA:for(normal.v=VelcroPhysics.Utilities.MathUtils.Mul$2(xfA.v.q.$clone(),manifold.v.LocalNormal.$clone()),planePoint=VelcroPhysics.Utilities.MathUtils.Mul$4(xfA,manifold.v.LocalPoint.$clone()),i=0;i<manifold.v.PointCount;i=i+1|0){var clipPoint=VelcroPhysics.Utilities.MathUtils.Mul$4(xfB,manifold.v.Points.getItem(i).$clone().LocalPoint.$clone()),cA1=Microsoft.Xna.Framework.Vector2.op_Addition(clipPoint.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(radiusA-Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(clipPoint.$clone(),planePoint.$clone()),normal.v.$clone()),normal.v.$clone())),cB1=Microsoft.Xna.Framework.Vector2.op_Subtraction(clipPoint.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(radiusB,normal.v.$clone()));points.v.setItem(i,Microsoft.Xna.Framework.Vector2.op_Multiply$2(.5,Microsoft.Xna.Framework.Vector2.op_Addition(cA1.$clone(),cB1.$clone())));separations.v.setItem(i,Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(cB1.$clone(),cA1.$clone()),normal.v.$clone()))}break;case VelcroPhysics.Collision.Narrowphase.ManifoldType.FaceB:for(normal.v=VelcroPhysics.Utilities.MathUtils.Mul$2(xfB.v.q.$clone(),manifold.v.LocalNormal.$clone()),planePoint1=VelcroPhysics.Utilities.MathUtils.Mul$4(xfB,manifold.v.LocalPoint.$clone()),i1=0;i1<manifold.v.PointCount;i1=i1+1|0){var clipPoint1=VelcroPhysics.Utilities.MathUtils.Mul$4(xfA,manifold.v.Points.getItem(i1).$clone().LocalPoint.$clone()),cB2=Microsoft.Xna.Framework.Vector2.op_Addition(clipPoint1.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(radiusB-Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(clipPoint1.$clone(),planePoint1.$clone()),normal.v.$clone()),normal.v.$clone())),cA2=Microsoft.Xna.Framework.Vector2.op_Subtraction(clipPoint1.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(radiusA,normal.v.$clone()));points.v.setItem(i1,Microsoft.Xna.Framework.Vector2.op_Multiply$2(.5,Microsoft.Xna.Framework.Vector2.op_Addition(cA2.$clone(),cB2.$clone())));separations.v.setItem(i1,Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(cA2.$clone(),cB2.$clone()),normal.v.$clone()))}normal.v=Microsoft.Xna.Framework.Vector2.op_UnaryNegation(normal.v.$clone());break}}}}});Bridge.define("VelcroPhysics.Collision.RayCast.RayCastHelper",{statics:{methods:{RayCastEdge:function(start,end,input,transform,output){var numerator,denominator,t,s;output.v=new VelcroPhysics.Collision.RayCast.RayCastOutput;var p1=VelcroPhysics.Utilities.MathUtils.MulT$2(transform.v.q.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(input.v.Point1.$clone(),transform.v.p.$clone())),p2=VelcroPhysics.Utilities.MathUtils.MulT$2(transform.v.q.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(input.v.Point2.$clone(),transform.v.p.$clone())),d=Microsoft.Xna.Framework.Vector2.op_Subtraction(p2.$clone(),p1.$clone()),v1=start.v.$clone(),v2=end.v.$clone(),e=Microsoft.Xna.Framework.Vector2.op_Subtraction(v2.$clone(),v1.$clone()),normal=new Microsoft.Xna.Framework.Vector2.$ctor2(e.Y,-e.X);if((normal.Normalize(),numerator=Microsoft.Xna.Framework.Vector2.Dot(normal.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(v1.$clone(),p1.$clone())),denominator=Microsoft.Xna.Framework.Vector2.Dot(normal.$clone(),d.$clone()),denominator===0)||(t=numerator/denominator,t<0||input.v.MaxFraction<t))return!1;var q=Microsoft.Xna.Framework.Vector2.op_Addition(p1.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(t,d.$clone())),r=Microsoft.Xna.Framework.Vector2.op_Subtraction(v2.$clone(),v1.$clone()),rr=Microsoft.Xna.Framework.Vector2.Dot(r.$clone(),r.$clone());return rr===0?!1:(s=Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(q.$clone(),v1.$clone()),r.$clone())/rr,s<0||1<s)?!1:(output.v.Fraction=t,output.v.Normal=numerator>0?Microsoft.Xna.Framework.Vector2.op_UnaryNegation(VelcroPhysics.Utilities.MathUtils.MulT$2(transform.v.q.$clone(),normal.$clone())):VelcroPhysics.Utilities.MathUtils.MulT$2(transform.v.q.$clone(),normal.$clone()),!0)},RayCastCircle:function(pos,radius,input,transform,output){var a;output.v=new VelcroPhysics.Collision.RayCast.RayCastOutput;var position=Microsoft.Xna.Framework.Vector2.op_Addition(transform.v.p.$clone(),VelcroPhysics.Utilities.MathUtils.Mul$2(transform.v.q.$clone(),pos.v.$clone())),s=Microsoft.Xna.Framework.Vector2.op_Subtraction(input.v.Point1.$clone(),position.$clone()),b=Microsoft.Xna.Framework.Vector2.Dot(s.$clone(),s.$clone())-radius*radius,r=Microsoft.Xna.Framework.Vector2.op_Subtraction(input.v.Point2.$clone(),input.v.Point1.$clone()),c=Microsoft.Xna.Framework.Vector2.Dot(s.$clone(),r.$clone()),rr=Microsoft.Xna.Framework.Vector2.Dot(r.$clone(),r.$clone()),sigma=c*c-rr*b;return sigma<0||rr<VelcroPhysics.Settings.Epsilon?!1:(a=-(c+Math.sqrt(sigma)),0<=a&&a<=input.v.MaxFraction*rr)?(a/=rr,output.v.Fraction=a,output.v.Normal=Microsoft.Xna.Framework.Vector2.op_Addition(s.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(a,r.$clone())),output.v.Normal.Normalize(),!0):!1},RayCastPolygon:function(vertices,normals,input,transform,output){var i,numerator,denominator;output.v=new VelcroPhysics.Collision.RayCast.RayCastOutput;var p1=VelcroPhysics.Utilities.MathUtils.MulT$2(transform.v.q.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(input.v.Point1.$clone(),transform.v.p.$clone())),p2=VelcroPhysics.Utilities.MathUtils.MulT$2(transform.v.q.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(input.v.Point2.$clone(),transform.v.p.$clone())),d=Microsoft.Xna.Framework.Vector2.op_Subtraction(p2.$clone(),p1.$clone()),lower=0,upper=input.v.MaxFraction,index=-1;for(i=0;i<vertices.Count;i=i+1|0){if(numerator=Microsoft.Xna.Framework.Vector2.Dot(normals.getItem(i).$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(vertices.getItem(i).$clone(),p1.$clone())),denominator=Microsoft.Xna.Framework.Vector2.Dot(normals.getItem(i).$clone(),d.$clone()),denominator===0){if(numerator<0)return!1}else denominator<0&&numerator<lower*denominator?(lower=numerator/denominator,index=i):denominator>0&&numerator<upper*denominator&&(upper=numerator/denominator);if(upper<lower)return!1}return(System.Diagnostics.Debug.Assert(0<=lower&&lower<=input.v.MaxFraction),index>=0)?(output.v.Fraction=lower,output.v.Normal=VelcroPhysics.Utilities.MathUtils.Mul$2(transform.v.q.$clone(),normals.getItem(index).$clone()),!0):!1}}}});Bridge.define("VelcroPhysics.Collision.RayCast.RayCastInput",{$kind:"struct",statics:{methods:{getDefaultValue:function(){return new VelcroPhysics.Collision.RayCast.RayCastInput}}},fields:{MaxFraction:0,Point1:null,Point2:null},ctors:{init:function(){this.Point1=new Microsoft.Xna.Framework.Vector2;this.Point2=new Microsoft.Xna.Framework.Vector2},ctor:function(){this.$initialize()}},methods:{getHashCode:function(){return Bridge.addHash([4318250273,this.MaxFraction,this.Point1,this.Point2])},equals:function(o){return Bridge.is(o,VelcroPhysics.Collision.RayCast.RayCastInput)?Bridge.equals(this.MaxFraction,o.MaxFraction)&&Bridge.equals(this.Point1,o.Point1)&&Bridge.equals(this.Point2,o.Point2):!1},$clone:function(to){var s=to||new VelcroPhysics.Collision.RayCast.RayCastInput;return s.MaxFraction=this.MaxFraction,s.Point1=this.Point1.$clone(),s.Point2=this.Point2.$clone(),s}}});Bridge.define("VelcroPhysics.Collision.RayCast.RayCastOutput",{$kind:"struct",statics:{methods:{getDefaultValue:function(){return new VelcroPhysics.Collision.RayCast.RayCastOutput}}},fields:{Fraction:0,Normal:null},ctors:{init:function(){this.Normal=new Microsoft.Xna.Framework.Vector2},ctor:function(){this.$initialize()}},methods:{getHashCode:function(){return Bridge.addHash([4435364252,this.Fraction,this.Normal])},equals:function(o){return Bridge.is(o,VelcroPhysics.Collision.RayCast.RayCastOutput)?Bridge.equals(this.Fraction,o.Fraction)&&Bridge.equals(this.Normal,o.Normal):!1},$clone:function(to){var s=to||new VelcroPhysics.Collision.RayCast.RayCastOutput;return s.Fraction=this.Fraction,s.Normal=this.Normal.$clone(),s}}});Bridge.define("VelcroPhysics.Collision.Shapes.Shape",{fields:{_2radius:0,_density:0,_radius:0,MassData:null,ShapeType:0},props:{Density:{get:function(){return this._density},set:function(value){System.Diagnostics.Debug.Assert(value>=0);this._density=value;this.ComputeProperties()}},Radius:{get:function(){return this._radius},set:function(value){System.Diagnostics.Debug.Assert(value>=0);this._radius=value;this._2radius=this._radius*this._radius;this.ComputeProperties()}}},ctors:{init:function(){this.MassData=new VelcroPhysics.Collision.Shapes.MassData},ctor:function(type,radius,density){radius===void 0&&(radius=0);density===void 0&&(density=0);this.$initialize();System.Diagnostics.Debug.Assert(radius>=0);System.Diagnostics.Debug.Assert(density>=0);this.ShapeType=type;this._radius=radius;this._2radius=this._radius*this._radius;this._density=density}}});Bridge.define("VelcroPhysics.Collision.Shapes.MassData",{inherits:function(){return[System.IEquatable$1(VelcroPhysics.Collision.Shapes.MassData)]},$kind:"struct",statics:{methods:{op_Equality:function(left,right){return left.Area===right.Area&&left.Mass===right.Mass&&Microsoft.Xna.Framework.Vector2.op_Equality(left.Centroid.$clone(),right.Centroid.$clone())&&left.Inertia===right.Inertia},op_Inequality:function(left,right){return!VelcroPhysics.Collision.Shapes.MassData.op_Equality(left.$clone(),right.$clone())},getDefaultValue:function(){return new VelcroPhysics.Collision.Shapes.MassData}}},fields:{Area:0,Centroid:null,Inertia:0,Mass:0},alias:["equalsT","System$IEquatable$1$VelcroPhysics$Collision$Shapes$MassData$equalsT"],ctors:{init:function(){this.Centroid=new Microsoft.Xna.Framework.Vector2},ctor:function(){this.$initialize()}},methods:{equalsT:function(other){return VelcroPhysics.Collision.Shapes.MassData.op_Equality(this,other.$clone())},equals:function(obj){return Bridge.referenceEquals(null,obj)?!1:Bridge.referenceEquals(Bridge.getType(obj),VelcroPhysics.Collision.Shapes.MassData)?this.equalsT(Bridge.cast(obj,VelcroPhysics.Collision.Shapes.MassData)):!1},getHashCode:function(){var result=System.Single.getHashCode(this.Area);return result=Bridge.Int.mul(result,397)^this.Centroid.getHashCode(),result=Bridge.Int.mul(result,397)^System.Single.getHashCode(this.Inertia),Bridge.Int.mul(result,397)^System.Single.getHashCode(this.Mass)},$clone:function(to){var s=to||new VelcroPhysics.Collision.Shapes.MassData;return s.Area=this.Area,s.Centroid=this.Centroid.$clone(),s.Inertia=this.Inertia,s.Mass=this.Mass,s}}});Bridge.define("VelcroPhysics.Collision.Shapes.ShapeType",{$kind:"enum",statics:{fields:{Unknown:-1,Circle:0,Edge:1,Polygon:2,Chain:3,TypeCount:4}}});Bridge.define("VelcroPhysics.Collision.TestPointHelper",{statics:{methods:{TestPointCircle:function(pos,radius,point,transform){var center=Microsoft.Xna.Framework.Vector2.op_Addition(transform.v.p.$clone(),VelcroPhysics.Utilities.MathUtils.Mul$2(transform.v.q.$clone(),pos.v.$clone())),d=Microsoft.Xna.Framework.Vector2.op_Subtraction(point.v.$clone(),center.$clone());return Microsoft.Xna.Framework.Vector2.Dot(d.$clone(),d.$clone())<=radius*radius},TestPointPolygon:function(vertices,normals,point,transform){for(var dot,pLocal=VelcroPhysics.Utilities.MathUtils.MulT$2(transform.v.q.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(point.v.$clone(),transform.v.p.$clone())),i=0;i<vertices.Count;i=i+1|0)if(dot=Microsoft.Xna.Framework.Vector2.Dot(normals.getItem(i).$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(pLocal.$clone(),vertices.getItem(i).$clone())),dot>0)return!1;return!0}}}});Bridge.define("VelcroPhysics.Collision.TOI.SeparationFunction",{statics:{methods:{Initialize:function(cache,proxyA,sweepA,proxyB,sweepB,t1,axis,localPoint,type){var count=cache.v.Count,xfA,xfB,normal,normal1;if(System.Diagnostics.Debug.Assert(0<count&&count<3),xfA={v:new VelcroPhysics.Shared.Transform},xfB={v:new VelcroPhysics.Shared.Transform},sweepA.v.GetTransform(xfA,t1),sweepB.v.GetTransform(xfB,t1),count===1){localPoint.v=Microsoft.Xna.Framework.Vector2.Zero.$clone();type.v=VelcroPhysics.Collision.TOI.SeparationFunctionType.Points;var localPointA=proxyA.Vertices[cache.v.IndexA.getItem(0)].$clone(),localPointB=proxyB.Vertices[cache.v.IndexB.getItem(0)].$clone(),pointA=VelcroPhysics.Utilities.MathUtils.Mul$4(xfA,localPointA.$clone()),pointB=VelcroPhysics.Utilities.MathUtils.Mul$4(xfB,localPointB.$clone());axis.v=Microsoft.Xna.Framework.Vector2.op_Subtraction(pointB.$clone(),pointA.$clone());axis.v.Normalize()}else if(cache.v.IndexA.getItem(0)===cache.v.IndexA.getItem(1)){type.v=VelcroPhysics.Collision.TOI.SeparationFunctionType.FaceB;var localPointB1=proxyB.Vertices[cache.v.IndexB.getItem(0)].$clone(),localPointB2=proxyB.Vertices[cache.v.IndexB.getItem(1)].$clone(),a=Microsoft.Xna.Framework.Vector2.op_Subtraction(localPointB2.$clone(),localPointB1.$clone());axis.v=new Microsoft.Xna.Framework.Vector2.$ctor2(a.Y,-a.X);axis.v.Normalize();normal=VelcroPhysics.Utilities.MathUtils.Mul$3(Bridge.ref(xfB.v,"q"),axis.v.$clone());localPoint.v=Microsoft.Xna.Framework.Vector2.op_Multiply$2(.5,Microsoft.Xna.Framework.Vector2.op_Addition(localPointB1.$clone(),localPointB2.$clone()));var pointB1=VelcroPhysics.Utilities.MathUtils.Mul$4(xfB,localPoint.v.$clone()),localPointA1=proxyA.Vertices[cache.v.IndexA.getItem(0)].$clone(),pointA1=VelcroPhysics.Utilities.MathUtils.Mul$4(xfA,localPointA1.$clone()),s=Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(pointA1.$clone(),pointB1.$clone()),normal.$clone());s<0&&(axis.v=Microsoft.Xna.Framework.Vector2.op_UnaryNegation(axis.v.$clone()))}else{type.v=VelcroPhysics.Collision.TOI.SeparationFunctionType.FaceA;var localPointA11=proxyA.Vertices[cache.v.IndexA.getItem(0)].$clone(),localPointA2=proxyA.Vertices[cache.v.IndexA.getItem(1)].$clone(),a1=Microsoft.Xna.Framework.Vector2.op_Subtraction(localPointA2.$clone(),localPointA11.$clone());axis.v=new Microsoft.Xna.Framework.Vector2.$ctor2(a1.Y,-a1.X);axis.v.Normalize();normal1=VelcroPhysics.Utilities.MathUtils.Mul$3(Bridge.ref(xfA.v,"q"),axis.v.$clone());localPoint.v=Microsoft.Xna.Framework.Vector2.op_Multiply$2(.5,Microsoft.Xna.Framework.Vector2.op_Addition(localPointA11.$clone(),localPointA2.$clone()));var pointA2=VelcroPhysics.Utilities.MathUtils.Mul$4(xfA,localPoint.v.$clone()),localPointB3=proxyB.Vertices[cache.v.IndexB.getItem(0)].$clone(),pointB2=VelcroPhysics.Utilities.MathUtils.Mul$4(xfB,localPointB3.$clone()),s1=Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(pointB2.$clone(),pointA2.$clone()),normal1.$clone());s1<0&&(axis.v=Microsoft.Xna.Framework.Vector2.op_UnaryNegation(axis.v.$clone()))}},FindMinSeparation:function(indexA,indexB,t,proxyA,sweepA,proxyB,sweepB,axis,localPoint,type){var xfA={v:new VelcroPhysics.Shared.Transform},xfB={v:new VelcroPhysics.Shared.Transform},axisA,axisB;sweepA.v.GetTransform(xfA,t);sweepB.v.GetTransform(xfB,t);switch(type){case VelcroPhysics.Collision.TOI.SeparationFunctionType.Points:axisA=VelcroPhysics.Utilities.MathUtils.MulT$3(Bridge.ref(xfA.v,"q"),axis.v.$clone());axisB=VelcroPhysics.Utilities.MathUtils.MulT$3(Bridge.ref(xfB.v,"q"),Microsoft.Xna.Framework.Vector2.op_UnaryNegation(axis.v.$clone()));indexA.v=proxyA.GetSupport(axisA.$clone());indexB.v=proxyB.GetSupport(axisB.$clone());var localPointA=proxyA.Vertices[indexA.v].$clone(),localPointB=proxyB.Vertices[indexB.v].$clone(),pointA=VelcroPhysics.Utilities.MathUtils.Mul$4(xfA,localPointA.$clone()),pointB=VelcroPhysics.Utilities.MathUtils.Mul$4(xfB,localPointB.$clone());return Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(pointB.$clone(),pointA.$clone()),axis.v.$clone());case VelcroPhysics.Collision.TOI.SeparationFunctionType.FaceA:var normal=VelcroPhysics.Utilities.MathUtils.Mul$3(Bridge.ref(xfA.v,"q"),axis.v.$clone()),pointA1=VelcroPhysics.Utilities.MathUtils.Mul$4(xfA,localPoint.v.$clone()),axisB1=VelcroPhysics.Utilities.MathUtils.MulT$3(Bridge.ref(xfB.v,"q"),Microsoft.Xna.Framework.Vector2.op_UnaryNegation(normal.$clone()));indexA.v=-1;indexB.v=proxyB.GetSupport(axisB1.$clone());var localPointB1=proxyB.Vertices[indexB.v].$clone(),pointB1=VelcroPhysics.Utilities.MathUtils.Mul$4(xfB,localPointB1.$clone());return Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(pointB1.$clone(),pointA1.$clone()),normal.$clone());case VelcroPhysics.Collision.TOI.SeparationFunctionType.FaceB:var normal1=VelcroPhysics.Utilities.MathUtils.Mul$3(Bridge.ref(xfB.v,"q"),axis.v.$clone()),pointB2=VelcroPhysics.Utilities.MathUtils.Mul$4(xfB,localPoint.v.$clone()),axisA1=VelcroPhysics.Utilities.MathUtils.MulT$3(Bridge.ref(xfA.v,"q"),Microsoft.Xna.Framework.Vector2.op_UnaryNegation(normal1.$clone()));indexB.v=-1;indexA.v=proxyA.GetSupport(axisA1.$clone());var localPointA1=proxyA.Vertices[indexA.v].$clone(),pointA2=VelcroPhysics.Utilities.MathUtils.Mul$4(xfA,localPointA1.$clone());return Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(pointA2.$clone(),pointB2.$clone()),normal1.$clone());default:return System.Diagnostics.Debug.Assert(!1),indexA.v=-1,indexB.v=-1,0}},Evaluate:function(indexA,indexB,t,proxyA,sweepA,proxyB,sweepB,axis,localPoint,type){var xfA={v:new VelcroPhysics.Shared.Transform},xfB={v:new VelcroPhysics.Shared.Transform};sweepA.v.GetTransform(xfA,t);sweepB.v.GetTransform(xfB,t);switch(type){case VelcroPhysics.Collision.TOI.SeparationFunctionType.Points:var localPointA=proxyA.Vertices[indexA].$clone(),localPointB=proxyB.Vertices[indexB].$clone(),pointA=VelcroPhysics.Utilities.MathUtils.Mul$4(xfA,localPointA.$clone()),pointB=VelcroPhysics.Utilities.MathUtils.Mul$4(xfB,localPointB.$clone());return Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(pointB.$clone(),pointA.$clone()),axis.v.$clone());case VelcroPhysics.Collision.TOI.SeparationFunctionType.FaceA:var normal=VelcroPhysics.Utilities.MathUtils.Mul$3(Bridge.ref(xfA.v,"q"),axis.v.$clone()),pointA1=VelcroPhysics.Utilities.MathUtils.Mul$4(xfA,localPoint.v.$clone()),localPointB1=proxyB.Vertices[indexB].$clone(),pointB1=VelcroPhysics.Utilities.MathUtils.Mul$4(xfB,localPointB1.$clone());return Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(pointB1.$clone(),pointA1.$clone()),normal.$clone());case VelcroPhysics.Collision.TOI.SeparationFunctionType.FaceB:var normal1=VelcroPhysics.Utilities.MathUtils.Mul$3(Bridge.ref(xfB.v,"q"),axis.v.$clone()),pointB2=VelcroPhysics.Utilities.MathUtils.Mul$4(xfB,localPoint.v.$clone()),localPointA1=proxyA.Vertices[indexA].$clone(),pointA2=VelcroPhysics.Utilities.MathUtils.Mul$4(xfA,localPointA1.$clone());return Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(pointA2.$clone(),pointB2.$clone()),normal1.$clone());default:return System.Diagnostics.Debug.Assert(!1),0}}}}});Bridge.define("VelcroPhysics.Collision.TOI.SeparationFunctionType",{$kind:"enum",statics:{fields:{Points:0,FaceA:1,FaceB:2}}});Bridge.define("VelcroPhysics.Collision.TOI.Sweep",{$kind:"struct",statics:{methods:{getDefaultValue:function(){return new VelcroPhysics.Collision.TOI.Sweep}}},fields:{A:0,A0:0,Alpha0:0,C:null,C0:null,LocalCenter:null},ctors:{init:function(){this.C=new Microsoft.Xna.Framework.Vector2;this.C0=new Microsoft.Xna.Framework.Vector2;this.LocalCenter=new Microsoft.Xna.Framework.Vector2},ctor:function(){this.$initialize()}},methods:{GetTransform:function(xfb,beta){xfb.v=new VelcroPhysics.Shared.Transform.ctor;xfb.v.p.X=(1-beta)*this.C0.X+beta*this.C.X;xfb.v.p.Y=(1-beta)*this.C0.Y+beta*this.C.Y;var angle=(1-beta)*this.A0+beta*this.A;xfb.v.q.Set(angle);xfb.v.p=Microsoft.Xna.Framework.Vector2.op_Subtraction(xfb.v.p.$clone(),VelcroPhysics.Utilities.MathUtils.Mul$2(xfb.v.q.$clone(),this.LocalCenter.$clone()))},Advance:function(alpha){System.Diagnostics.Debug.Assert(this.Alpha0<1);var beta=(alpha-this.Alpha0)/(1-this.Alpha0);this.C0=Microsoft.Xna.Framework.Vector2.op_Addition(this.C0.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(beta,Microsoft.Xna.Framework.Vector2.op_Subtraction(this.C.$clone(),this.C0.$clone())));this.A0+=beta*(this.A-this.A0);this.Alpha0=alpha},Normalize:function(){var d=Microsoft.Xna.Framework.MathHelper.TwoPi*Math.floor(this.A0/Microsoft.Xna.Framework.MathHelper.TwoPi);this.A0-=d;this.A-=d},getHashCode:function(){return Bridge.addHash([1701148611,this.A,this.A0,this.Alpha0,this.C,this.C0,this.LocalCenter])},equals:function(o){return Bridge.is(o,VelcroPhysics.Collision.TOI.Sweep)?Bridge.equals(this.A,o.A)&&Bridge.equals(this.A0,o.A0)&&Bridge.equals(this.Alpha0,o.Alpha0)&&Bridge.equals(this.C,o.C)&&Bridge.equals(this.C0,o.C0)&&Bridge.equals(this.LocalCenter,o.LocalCenter):!1},$clone:function(to){var s=to||new VelcroPhysics.Collision.TOI.Sweep;return s.A=this.A,s.A0=this.A0,s.Alpha0=this.Alpha0,s.C=this.C.$clone(),s.C0=this.C0.$clone(),s.LocalCenter=this.LocalCenter.$clone(),s}}});Bridge.define("VelcroPhysics.Collision.TOI.TimeOfImpact",{statics:{fields:{TOICalls:0,TOIIters:0,TOIMaxIters:0,TOIRootIters:0,TOIMaxRootIters:0},methods:{CalculateTimeOfImpact:function(input,output){var sweepA,sweepB,xfA,xfB,distanceOutput,cache,s1,t,s;VelcroPhysics.Settings.EnableDiagnostics&&(VelcroPhysics.Collision.TOI.TimeOfImpact.TOICalls=VelcroPhysics.Collision.TOI.TimeOfImpact.TOICalls+1|0);output.v=new VelcroPhysics.Collision.TOI.TOIOutput;output.v.State=VelcroPhysics.Collision.TOI.TOIOutputState.Unknown;output.v.T=input.v.TMax;sweepA={v:input.v.SweepA.$clone()};sweepB={v:input.v.SweepB.$clone()};sweepA.v.Normalize();sweepB.v.Normalize();var tMax=input.v.TMax,totalRadius=input.v.ProxyA.Radius+input.v.ProxyB.Radius,target=Math.max(VelcroPhysics.Settings.LinearSlop,totalRadius-.015),tolerance=.00125;System.Diagnostics.Debug.Assert(target>tolerance);var t1=0,k_maxIterations=20,iter=0,distanceInput={v:new VelcroPhysics.Collision.Distance.DistanceInput};for(distanceInput.v.ProxyA=input.v.ProxyA,distanceInput.v.ProxyB=input.v.ProxyB,distanceInput.v.UseRadii=!1;;){if(xfA={v:new VelcroPhysics.Shared.Transform},xfB={v:new VelcroPhysics.Shared.Transform},sweepA.v.GetTransform(xfA,t1),sweepB.v.GetTransform(xfB,t1),distanceInput.v.TransformA=xfA.v.$clone(),distanceInput.v.TransformB=xfB.v.$clone(),distanceOutput={v:new VelcroPhysics.Collision.Distance.DistanceOutput},cache={v:new VelcroPhysics.Collision.Narrowphase.SimplexCache},VelcroPhysics.Collision.Distance.DistanceGJK.ComputeDistance(distanceInput,distanceOutput,cache),distanceOutput.v.Distance<=0){output.v.State=VelcroPhysics.Collision.TOI.TOIOutputState.Overlapped;output.v.T=0;break}if(distanceOutput.v.Distance<target+tolerance){output.v.State=VelcroPhysics.Collision.TOI.TOIOutputState.Touching;output.v.T=t1;break}var axis={v:new Microsoft.Xna.Framework.Vector2},localPoint={v:new Microsoft.Xna.Framework.Vector2},type={v:new VelcroPhysics.Collision.TOI.SeparationFunctionType};VelcroPhysics.Collision.TOI.SeparationFunction.Initialize(cache,input.v.ProxyA,sweepA,input.v.ProxyB,sweepB,t1,axis,localPoint,type);for(var done=!1,t2=tMax,pushBackIter=0;;){var indexA={},indexB={},s2=VelcroPhysics.Collision.TOI.SeparationFunction.FindMinSeparation(indexA,indexB,t2,input.v.ProxyA,sweepA,input.v.ProxyB,sweepB,axis,localPoint,type.v);if(s2>target+tolerance){output.v.State=VelcroPhysics.Collision.TOI.TOIOutputState.Seperated;output.v.T=tMax;done=!0;break}if(s2>target-tolerance){t1=t2;break}if(s1=VelcroPhysics.Collision.TOI.SeparationFunction.Evaluate(indexA.v,indexB.v,t1,input.v.ProxyA,sweepA,input.v.ProxyB,sweepB,axis,localPoint,type.v),s1<target-tolerance){output.v.State=VelcroPhysics.Collision.TOI.TOIOutputState.Failed;output.v.T=t1;done=!0;break}if(s1<=target+tolerance){output.v.State=VelcroPhysics.Collision.TOI.TOIOutputState.Touching;output.v.T=t1;done=!0;break}for(var rootIterCount=0,a1=t1,a2=t2;;){if(t=(rootIterCount&1)!=0?a1+(target-s1)*(a2-a1)/(s2-s1):.5*(a1+a2),rootIterCount=rootIterCount+1|0,VelcroPhysics.Settings.EnableDiagnostics&&(VelcroPhysics.Collision.TOI.TimeOfImpact.TOIRootIters=VelcroPhysics.Collision.TOI.TimeOfImpact.TOIRootIters+1|0),s=VelcroPhysics.Collision.TOI.SeparationFunction.Evaluate(indexA.v,indexB.v,t,input.v.ProxyA,sweepA,input.v.ProxyB,sweepB,axis,localPoint,type.v),Math.abs(s-target)<tolerance){t2=t;break}if(s>target?(a1=t,s1=s):(a2=t,s2=s),rootIterCount===50)break}if(VelcroPhysics.Settings.EnableDiagnostics&&(VelcroPhysics.Collision.TOI.TimeOfImpact.TOIMaxRootIters=Math.max(VelcroPhysics.Collision.TOI.TimeOfImpact.TOIMaxRootIters,rootIterCount)),pushBackIter=pushBackIter+1|0,pushBackIter===VelcroPhysics.Settings.MaxPolygonVertices)break}if(iter=iter+1|0,VelcroPhysics.Settings.EnableDiagnostics&&(VelcroPhysics.Collision.TOI.TimeOfImpact.TOIIters=VelcroPhysics.Collision.TOI.TimeOfImpact.TOIIters+1|0),done)break;if(iter===k_maxIterations){output.v.State=VelcroPhysics.Collision.TOI.TOIOutputState.Failed;output.v.T=t1;break}}VelcroPhysics.Settings.EnableDiagnostics&&(VelcroPhysics.Collision.TOI.TimeOfImpact.TOIMaxIters=Math.max(VelcroPhysics.Collision.TOI.TimeOfImpact.TOIMaxIters,iter))}}}});Bridge.define("VelcroPhysics.Collision.TOI.TOIInput",{$kind:"struct",statics:{methods:{getDefaultValue:function(){return new VelcroPhysics.Collision.TOI.TOIInput}}},fields:{ProxyA:null,ProxyB:null,SweepA:null,SweepB:null,TMax:0},ctors:{init:function(){this.ProxyA=new VelcroPhysics.Collision.Distance.DistanceProxy;this.ProxyB=new VelcroPhysics.Collision.Distance.DistanceProxy;this.SweepA=new VelcroPhysics.Collision.TOI.Sweep;this.SweepB=new VelcroPhysics.Collision.TOI.Sweep},ctor:function(){this.$initialize()}},methods:{getHashCode:function(){return Bridge.addHash([3183394754,this.ProxyA,this.ProxyB,this.SweepA,this.SweepB,this.TMax])},equals:function(o){return Bridge.is(o,VelcroPhysics.Collision.TOI.TOIInput)?Bridge.equals(this.ProxyA,o.ProxyA)&&Bridge.equals(this.ProxyB,o.ProxyB)&&Bridge.equals(this.SweepA,o.SweepA)&&Bridge.equals(this.SweepB,o.SweepB)&&Bridge.equals(this.TMax,o.TMax):!1},$clone:function(to){var s=to||new VelcroPhysics.Collision.TOI.TOIInput;return s.ProxyA=this.ProxyA,s.ProxyB=this.ProxyB,s.SweepA=this.SweepA.$clone(),s.SweepB=this.SweepB.$clone(),s.TMax=this.TMax,s}}});Bridge.define("VelcroPhysics.Collision.TOI.TOIOutput",{$kind:"struct",statics:{methods:{getDefaultValue:function(){return new VelcroPhysics.Collision.TOI.TOIOutput}}},fields:{State:0,T:0},ctors:{ctor:function(){this.$initialize()}},methods:{getHashCode:function(){return Bridge.addHash([3300508733,this.State,this.T])},equals:function(o){return Bridge.is(o,VelcroPhysics.Collision.TOI.TOIOutput)?Bridge.equals(this.State,o.State)&&Bridge.equals(this.T,o.T):!1},$clone:function(to){var s=to||new VelcroPhysics.Collision.TOI.TOIOutput;return s.State=this.State,s.T=this.T,s}}});Bridge.define("VelcroPhysics.Collision.TOI.TOIOutputState",{$kind:"enum",statics:{fields:{Unknown:0,Failed:1,Overlapped:2,Touching:3,Seperated:4}}});Bridge.define("VelcroPhysics.Dynamics.Body",{fields:{_type:0,_inertia:0,_mass:0,_flags:0,_invI:0,_invMass:0,_force:null,_linearVelocity:null,_angularVelocity:0,_sweep:null,_torque:0,_world:null,_xf:null,ControllerFilter:null,PhysicsLogicFilter:null,BodyId:0,SleepTime:0,IslandIndex:0,GravityScale:0,UserData:null,LinearDamping:0,AngularDamping:0,FixtureList:null,JointList:null,ContactList:null},props:{Revolutions:{get:function(){return this.Rotation/3.14159274}},BodyType:{get:function(){return this._type},set:function(value){var $t,ce,ce0,broadPhase,fixture,proxyCount,j;if(value!==this._type){for(this._type=value,this.ResetMassData(),this._type===VelcroPhysics.Dynamics.BodyType.Static&&(this._linearVelocity=Microsoft.Xna.Framework.Vector2.Zero.$clone(),this._angularVelocity=0,this._sweep.A0=this._sweep.A,this._sweep.C0=this._sweep.C.$clone(),this.SynchronizeFixtures()),this.Awake=!0,this._force=Microsoft.Xna.Framework.Vector2.Zero.$clone(),this._torque=0,ce=this.ContactList;ce!=null;)ce0=ce,ce=ce.Next,this._world.ContactManager.Destroy(ce0.Contact);this.ContactList=null;broadPhase=this._world.ContactManager.BroadPhase;$t=Bridge.getEnumerator(this.FixtureList);try{while($t.moveNext())for(fixture=$t.Current,proxyCount=fixture.ProxyCount,j=0;j<proxyCount;j=j+1|0)broadPhase.VelcroPhysics$Collision$Broadphase$IBroadPhase$TouchProxy(fixture.Proxies[j].ProxyId)}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}}}},LinearVelocity:{get:function(){return this._linearVelocity.$clone()},set:function(value){(System.Diagnostics.Debug.Assert(!isNaN(value.X)&&!isNaN(value.Y)),this._type!==VelcroPhysics.Dynamics.BodyType.Static)&&(Microsoft.Xna.Framework.Vector2.Dot(value.$clone(),value.$clone())>0&&(this.Awake=!0),this._linearVelocity=value.$clone())}},AngularVelocity:{get:function(){return this._angularVelocity},set:function(value){(System.Diagnostics.Debug.Assert(!isNaN(value)),this._type!==VelcroPhysics.Dynamics.BodyType.Static)&&(value*value>0&&(this.Awake=!0),this._angularVelocity=value)}},IsBullet:{get:function(){return(this._flags&VelcroPhysics.Dynamics.BodyFlags.BulletFlag&255)===VelcroPhysics.Dynamics.BodyFlags.BulletFlag},set:function(value){value?this._flags|=VelcroPhysics.Dynamics.BodyFlags.BulletFlag&255:this._flags&=247}},SleepingAllowed:{get:function(){return(this._flags&VelcroPhysics.Dynamics.BodyFlags.AutoSleepFlag&255)===VelcroPhysics.Dynamics.BodyFlags.AutoSleepFlag},set:function(value){value?this._flags|=VelcroPhysics.Dynamics.BodyFlags.AutoSleepFlag&255:(this._flags&=251,this.Awake=!0)}},Awake:{get:function(){return(this._flags&VelcroPhysics.Dynamics.BodyFlags.AwakeFlag&255)===VelcroPhysics.Dynamics.BodyFlags.AwakeFlag},set:function(value){value?(this._flags|=VelcroPhysics.Dynamics.BodyFlags.AwakeFlag&255,this.SleepTime=0):(this._flags&=253,this.ResetDynamics(),this.SleepTime=0)}},Enabled:{get:function(){return(this._flags&VelcroPhysics.Dynamics.BodyFlags.Enabled&255)===VelcroPhysics.Dynamics.BodyFlags.Enabled},set:function(value){var broadPhase,i,broadPhase1,i1,ce,ce0;if(value!==this.Enabled)if(value)for(this._flags|=VelcroPhysics.Dynamics.BodyFlags.Enabled&255,broadPhase=this._world.ContactManager.BroadPhase,i=0;i<this.FixtureList.Count;i=i+1|0)this.FixtureList.getItem(i).CreateProxies(broadPhase,Bridge.ref(this,"_xf"));else{for(this._flags&=223,broadPhase1=this._world.ContactManager.BroadPhase,i1=0;i1<this.FixtureList.Count;i1=i1+1|0)this.FixtureList.getItem(i1).DestroyProxies(broadPhase1);for(ce=this.ContactList;ce!=null;)ce0=ce,ce=ce.Next,this._world.ContactManager.Destroy(ce0.Contact);this.ContactList=null}}},FixedRotation:{get:function(){return(this._flags&VelcroPhysics.Dynamics.BodyFlags.FixedRotationFlag&255)===VelcroPhysics.Dynamics.BodyFlags.FixedRotationFlag},set:function(value){value!==this.FixedRotation&&(value?this._flags|=VelcroPhysics.Dynamics.BodyFlags.FixedRotationFlag&255:this._flags&=239,this._angularVelocity=0,this.ResetMassData())}},Position:{get:function(){return this._xf.p.$clone()},set:function(value){value={v:value};System.Diagnostics.Debug.Assert(!isNaN(value.v.X)&&!isNaN(value.v.Y));this.SetTransform$1(value,this.Rotation)}},Rotation:{get:function(){return this._sweep.A},set:function(value){System.Diagnostics.Debug.Assert(!isNaN(value));this.SetTransform$1(Bridge.ref(this._xf,"p"),value)}},IsIsland:{get:function(){return(this._flags&VelcroPhysics.Dynamics.BodyFlags.IslandFlag&255)===VelcroPhysics.Dynamics.BodyFlags.IslandFlag}},IsStatic:{get:function(){return this._type===VelcroPhysics.Dynamics.BodyType.Static}},IsKinematic:{get:function(){return this._type===VelcroPhysics.Dynamics.BodyType.Kinematic}},IsDynamic:{get:function(){return this._type===VelcroPhysics.Dynamics.BodyType.Dynamic}},IgnoreGravity:{get:function(){return(this._flags&VelcroPhysics.Dynamics.BodyFlags.IgnoreGravity&255)===VelcroPhysics.Dynamics.BodyFlags.IgnoreGravity},set:function(value){value?this._flags|=VelcroPhysics.Dynamics.BodyFlags.IgnoreGravity&255:this._flags&=191}},WorldCenter:{get:function(){return this._sweep.C.$clone()}},LocalCenter:{get:function(){return this._sweep.LocalCenter.$clone()},set:function(value){var $t,oldCenter,a;this._type===VelcroPhysics.Dynamics.BodyType.Dynamic&&(oldCenter=this._sweep.C.$clone(),this._sweep.LocalCenter=value.$clone(),this._sweep.C0=($t=VelcroPhysics.Utilities.MathUtils.Mul$5(Bridge.ref(this,"_xf"),Bridge.ref(this._sweep,"LocalCenter")),this._sweep.C=$t.$clone(),$t),a=Microsoft.Xna.Framework.Vector2.op_Subtraction(this._sweep.C.$clone(),oldCenter.$clone()),this._linearVelocity=Microsoft.Xna.Framework.Vector2.op_Addition(this._linearVelocity.$clone(),new Microsoft.Xna.Framework.Vector2.$ctor2(-this._angularVelocity*a.Y,this._angularVelocity*a.X)))}},Mass:{get:function(){return this._mass},set:function(value){(System.Diagnostics.Debug.Assert(!isNaN(value)),this._type===VelcroPhysics.Dynamics.BodyType.Dynamic)&&(this._mass=value,this._mass<=0&&(this._mass=1),this._invMass=1/this._mass)}},Inertia:{get:function(){return this._inertia+this._mass*Microsoft.Xna.Framework.Vector2.Dot(this._sweep.LocalCenter.$clone(),this._sweep.LocalCenter.$clone())},set:function(value){(System.Diagnostics.Debug.Assert(!isNaN(value)),this._type===VelcroPhysics.Dynamics.BodyType.Dynamic)&&value>0&&!this.FixedRotation&&(this._inertia=value-this._mass*Microsoft.Xna.Framework.Vector2.Dot(this._sweep.LocalCenter.$clone(),this._sweep.LocalCenter.$clone()),System.Diagnostics.Debug.Assert(this._inertia>0),this._invI=1/this._inertia)}},Restitution:{set:function(value){for(var f,i=0;i<this.FixtureList.Count;i=i+1|0)f=this.FixtureList.getItem(i),f.Restitution=value}},Friction:{set:function(value){for(var f,i=0;i<this.FixtureList.Count;i=i+1|0)f=this.FixtureList.getItem(i),f.Friction=value}},CollisionCategories:{set:function(value){for(var f,i=0;i<this.FixtureList.Count;i=i+1|0)f=this.FixtureList.getItem(i),f.CollisionCategories=value}},CollidesWith:{set:function(value){for(var f,i=0;i<this.FixtureList.Count;i=i+1|0)f=this.FixtureList.getItem(i),f.CollidesWith=value}},IgnoreCCDWith:{set:function(value){for(var f,i=0;i<this.FixtureList.Count;i=i+1|0)f=this.FixtureList.getItem(i),f.IgnoreCCDWith=value}},CollisionGroup:{set:function(value){for(var f,i=0;i<this.FixtureList.Count;i=i+1|0)f=this.FixtureList.getItem(i),f.CollisionGroup=value}},IsSensor:{set:function(value){for(var f,i=0;i<this.FixtureList.Count;i=i+1|0)f=this.FixtureList.getItem(i),f.IsSensor=value}},IgnoreCCD:{get:function(){return(this._flags&VelcroPhysics.Dynamics.BodyFlags.IgnoreCCD&255)===VelcroPhysics.Dynamics.BodyFlags.IgnoreCCD},set:function(value){value?this._flags|=VelcroPhysics.Dynamics.BodyFlags.IgnoreCCD&255:this._flags&=127}}},ctors:{init:function(){this._force=new Microsoft.Xna.Framework.Vector2;this._linearVelocity=new Microsoft.Xna.Framework.Vector2;this._sweep=new VelcroPhysics.Collision.TOI.Sweep;this._xf=new VelcroPhysics.Shared.Transform;this.ControllerFilter=new VelcroPhysics.Extensions.Controllers.ControllerBase.ControllerFilter;this.PhysicsLogicFilter=new VelcroPhysics.Extensions.PhysicsLogics.PhysicsLogicBase.PhysicsLogicFilter},ctor:function(world,template){this.$initialize();this.FixtureList=new(System.Collections.Generic.List$1(VelcroPhysics.Dynamics.Fixture).$ctor2)(1);template.AllowCCD&&(this._flags|=VelcroPhysics.Dynamics.BodyFlags.BulletFlag&255);template.AllowRotation&&(this._flags|=VelcroPhysics.Dynamics.BodyFlags.FixedRotationFlag&255);template.AllowSleep&&(this._flags|=VelcroPhysics.Dynamics.BodyFlags.AutoSleepFlag&255);template.Awake&&(this._flags|=VelcroPhysics.Dynamics.BodyFlags.AwakeFlag&255);template.Active&&(this._flags|=VelcroPhysics.Dynamics.BodyFlags.Enabled&255);this._world=world;this._xf.p=template.Position.$clone();this._xf.q.Set(template.Angle);this._sweep.C0=this._xf.p.$clone();this._sweep.C=this._xf.p.$clone();this._sweep.A0=template.Angle;this._sweep.A=template.Angle;this._linearVelocity=template.LinearVelocity.$clone();this._angularVelocity=template.AngularVelocity;this.LinearDamping=template.LinearDamping;this.AngularDamping=template.AngularDamping;this.GravityScale=1;this._type=template.Type;this._type===VelcroPhysics.Dynamics.BodyType.Dynamic?(this._mass=1,this._invMass=1):(this._mass=0,this._invMass=0);this.UserData=template.UserData}},methods:{addOnCollision:function(value){var $t,f;$t=Bridge.getEnumerator(this.FixtureList);try{while($t.moveNext())f=$t.Current,f.OnCollision=Bridge.fn.combine(f.OnCollision,value)}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}},removeOnCollision:function(value){var $t,f;$t=Bridge.getEnumerator(this.FixtureList);try{while($t.moveNext())f=$t.Current,f.OnCollision=Bridge.fn.remove(f.OnCollision,value)}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}},addOnSeparation:function(value){var $t,f;$t=Bridge.getEnumerator(this.FixtureList);try{while($t.moveNext())f=$t.Current,f.OnSeparation=Bridge.fn.combine(f.OnSeparation,value)}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}},removeOnSeparation:function(value){var $t,f;$t=Bridge.getEnumerator(this.FixtureList);try{while($t.moveNext())f=$t.Current,f.OnSeparation=Bridge.fn.remove(f.OnSeparation,value)}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}},ResetDynamics:function(){this._torque=0;this._angularVelocity=0;this._force=Microsoft.Xna.Framework.Vector2.Zero.$clone();this._linearVelocity=Microsoft.Xna.Framework.Vector2.Zero.$clone()},CreateFixture$1:function(template){var $t,f=new VelcroPhysics.Dynamics.Fixture.$ctor1(this,template);return f.FixtureId=Bridge.identity(this._world._fixtureIdCounter,($t=this._world._fixtureIdCounter+1|0,this._world._fixtureIdCounter=$t,$t)),f},CreateFixture:function(shape,userData){userData===void 0&&(userData=null);var template=new VelcroPhysics.Templates.FixtureTemplate;return template.Shape=shape,template.UserData=userData,this.CreateFixture$1(template)},DestroyFixture:function(fixture){var edge,c,fixtureA,fixtureB,broadPhase;if(fixture!=null){for(System.Diagnostics.Debug.Assert(Bridge.referenceEquals(fixture.Body,this)),System.Diagnostics.Debug.Assert(this.FixtureList.Count>0),System.Diagnostics.Debug.Assert(this.FixtureList.contains(fixture)),edge=this.ContactList;edge!=null;)c=edge.Contact,edge=edge.Next,fixtureA=c.FixtureA,fixtureB=c.FixtureB,(Bridge.referenceEquals(fixture,fixtureA)||Bridge.referenceEquals(fixture,fixtureB))&&this._world.ContactManager.Destroy(c);this.Enabled&&(broadPhase=this._world.ContactManager.BroadPhase,fixture.DestroyProxies(broadPhase));this.FixtureList.remove(fixture);fixture.Destroy();fixture.Body=null;this.ResetMassData()}},SetTransform$1:function(position,rotation){this.SetTransformIgnoreContacts(position,rotation);this._world.ContactManager.FindNewContacts()},SetTransform:function(position,rotation){position={v:position};this.SetTransform$1(position,rotation)},SetTransformIgnoreContacts:function(position,angle){var broadPhase,i;for(this._xf.q.Set(angle),this._xf.p=position.v.$clone(),this._sweep.C=VelcroPhysics.Utilities.MathUtils.Mul$4(Bridge.ref(this,"_xf"),this._sweep.LocalCenter.$clone()),this._sweep.A=angle,this._sweep.C0=this._sweep.C.$clone(),this._sweep.A0=angle,broadPhase=this._world.ContactManager.BroadPhase,i=0;i<this.FixtureList.Count;i=i+1|0)this.FixtureList.getItem(i).Synchronize(broadPhase,Bridge.ref(this,"_xf"),Bridge.ref(this,"_xf"))},GetTransform:function(transform){transform.v=this._xf.$clone()},ApplyForce$1:function(force,point){force={v:force};point={v:point};this.ApplyForce$3(force,point)},ApplyForce$2:function(force){this.ApplyForce$3(force,Bridge.ref(this._xf,"p"))},ApplyForce:function(force){force={v:force};this.ApplyForce$3(force,Bridge.ref(this._xf,"p"))},ApplyForce$3:function(force,point){(System.Diagnostics.Debug.Assert(!isNaN(force.v.X)),System.Diagnostics.Debug.Assert(!isNaN(force.v.Y)),System.Diagnostics.Debug.Assert(!isNaN(point.v.X)),System.Diagnostics.Debug.Assert(!isNaN(point.v.Y)),this._type===VelcroPhysics.Dynamics.BodyType.Dynamic)&&(this.Awake===!1&&(this.Awake=!0),this._force=Microsoft.Xna.Framework.Vector2.op_Addition(this._force.$clone(),force.v.$clone()),this._torque+=VelcroPhysics.Utilities.MathUtils.Cross$3(Microsoft.Xna.Framework.Vector2.op_Subtraction(point.v.$clone(),this._sweep.C.$clone()),force.v.$clone()))},ApplyTorque:function(torque){(System.Diagnostics.Debug.Assert(!isNaN(torque)),this.BodyType===VelcroPhysics.Dynamics.BodyType.Dynamic)&&(this.Awake===!1&&(this.Awake=!0),this._torque+=torque)},ApplyLinearImpulse:function(impulse){impulse={v:impulse};this.ApplyLinearImpulse$2(impulse)},ApplyLinearImpulse$1:function(impulse,point){impulse={v:impulse};point={v:point};this.ApplyLinearImpulse$3(impulse,point)},ApplyLinearImpulse$2:function(impulse){this._type===VelcroPhysics.Dynamics.BodyType.Dynamic&&(this.Awake===!1&&(this.Awake=!0),this._linearVelocity=Microsoft.Xna.Framework.Vector2.op_Addition(this._linearVelocity.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._invMass,impulse.v.$clone())))},ApplyLinearImpulse$3:function(impulse,point){this._type===VelcroPhysics.Dynamics.BodyType.Dynamic&&(this.Awake===!1&&(this.Awake=!0),this._linearVelocity=Microsoft.Xna.Framework.Vector2.op_Addition(this._linearVelocity.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._invMass,impulse.v.$clone())),this._angularVelocity+=this._invI*VelcroPhysics.Utilities.MathUtils.Cross$3(Microsoft.Xna.Framework.Vector2.op_Subtraction(point.v.$clone(),this._sweep.C.$clone()),impulse.v.$clone()))},ApplyAngularImpulse:function(impulse){this._type===VelcroPhysics.Dynamics.BodyType.Dynamic&&(this.Awake===!1&&(this.Awake=!0),this._angularVelocity+=this._invI*impulse)},ResetMassData:function(){var $t,$t1,$t2,localCenter,f,massData,oldCenter,a;if(this._mass=0,this._invMass=0,this._inertia=0,this._invI=0,this._sweep.LocalCenter=Microsoft.Xna.Framework.Vector2.Zero.$clone(),this.BodyType===VelcroPhysics.Dynamics.BodyType.Kinematic){this._sweep.C0=this._xf.p.$clone();this._sweep.C=this._xf.p.$clone();this._sweep.A0=this._sweep.A;return}System.Diagnostics.Debug.Assert(this.BodyType===VelcroPhysics.Dynamics.BodyType.Dynamic||this.BodyType===VelcroPhysics.Dynamics.BodyType.Static);localCenter=Microsoft.Xna.Framework.Vector2.Zero.$clone();$t=Bridge.getEnumerator(this.FixtureList);try{while($t.moveNext())(f=$t.Current,f.Shape._density!==0)&&(massData=f.Shape.MassData.$clone(),this._mass+=massData.Mass,localCenter=Microsoft.Xna.Framework.Vector2.op_Addition(localCenter.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(massData.Mass,massData.Centroid.$clone())),this._inertia+=massData.Inertia)}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}if(this.BodyType===VelcroPhysics.Dynamics.BodyType.Static){this._sweep.C0=($t1=this._xf.p.$clone(),this._sweep.C=$t1.$clone(),$t1);return}this._mass>0?(this._invMass=1/this._mass,localCenter=Microsoft.Xna.Framework.Vector2.op_Multiply$1(localCenter.$clone(),this._invMass)):(this._mass=1,this._invMass=1);this._inertia>0&&(this._flags&VelcroPhysics.Dynamics.BodyFlags.FixedRotationFlag&255)==0?(this._inertia-=this._mass*Microsoft.Xna.Framework.Vector2.Dot(localCenter.$clone(),localCenter.$clone()),System.Diagnostics.Debug.Assert(this._inertia>0),this._invI=1/this._inertia):(this._inertia=0,this._invI=0);oldCenter=this._sweep.C.$clone();this._sweep.LocalCenter=localCenter.$clone();this._sweep.C0=($t2=VelcroPhysics.Utilities.MathUtils.Mul$5(Bridge.ref(this,"_xf"),Bridge.ref(this._sweep,"LocalCenter")),this._sweep.C=$t2.$clone(),$t2);a=Microsoft.Xna.Framework.Vector2.op_Subtraction(this._sweep.C.$clone(),oldCenter.$clone());this._linearVelocity=Microsoft.Xna.Framework.Vector2.op_Addition(this._linearVelocity.$clone(),new Microsoft.Xna.Framework.Vector2.$ctor2(-this._angularVelocity*a.Y,this._angularVelocity*a.X))},GetWorldPoint$1:function(localPoint){return VelcroPhysics.Utilities.MathUtils.Mul$5(Bridge.ref(this,"_xf"),localPoint)},GetWorldPoint:function(localPoint){return localPoint={v:localPoint},this.GetWorldPoint$1(localPoint)},GetWorldVector$1:function(localVector){return VelcroPhysics.Utilities.MathUtils.Mul$3(Bridge.ref(this._xf,"q"),localVector.v.$clone())},GetWorldVector:function(localVector){return localVector={v:localVector},this.GetWorldVector$1(localVector)},GetLocalPoint$1:function(worldPoint){return VelcroPhysics.Utilities.MathUtils.MulT$5(Bridge.ref(this,"_xf"),worldPoint.v.$clone())},GetLocalPoint:function(worldPoint){return worldPoint={v:worldPoint},this.GetLocalPoint$1(worldPoint)},GetLocalVector$1:function(worldVector){return VelcroPhysics.Utilities.MathUtils.MulT$2(this._xf.q.$clone(),worldVector.v.$clone())},GetLocalVector:function(worldVector){return worldVector={v:worldVector},this.GetLocalVector$1(worldVector)},GetLinearVelocityFromWorldPoint:function(worldPoint){return worldPoint={v:worldPoint},this.GetLinearVelocityFromWorldPoint$1(worldPoint)},GetLinearVelocityFromWorldPoint$1:function(worldPoint){return Microsoft.Xna.Framework.Vector2.op_Addition(this._linearVelocity.$clone(),VelcroPhysics.Utilities.MathUtils.Cross$1(this._angularVelocity,Microsoft.Xna.Framework.Vector2.op_Subtraction(worldPoint.v.$clone(),this._sweep.C.$clone())))},GetLinearVelocityFromLocalPoint:function(localPoint){return localPoint={v:localPoint},this.GetLinearVelocityFromLocalPoint$1(localPoint)},GetLinearVelocityFromLocalPoint$1:function(localPoint){return this.GetLinearVelocityFromWorldPoint(this.GetWorldPoint$1(localPoint))},SynchronizeFixtures:function(){var xf1={v:new VelcroPhysics.Shared.Transform.ctor},broadPhase,i;for(xf1.v.q.Set(this._sweep.A0),xf1.v.p=Microsoft.Xna.Framework.Vector2.op_Subtraction(this._sweep.C0.$clone(),VelcroPhysics.Utilities.MathUtils.Mul$2(xf1.v.q.$clone(),this._sweep.LocalCenter.$clone())),broadPhase=this._world.ContactManager.BroadPhase,i=0;i<this.FixtureList.Count;i=i+1|0)this.FixtureList.getItem(i).Synchronize(broadPhase,xf1,Bridge.ref(this,"_xf"))},SynchronizeTransform:function(){this._xf.q.Set(this._sweep.A);this._xf.p=Microsoft.Xna.Framework.Vector2.op_Subtraction(this._sweep.C.$clone(),VelcroPhysics.Utilities.MathUtils.Mul$2(this._xf.q.$clone(),this._sweep.LocalCenter.$clone()))},ShouldCollide:function(other){if(this._type!==VelcroPhysics.Dynamics.BodyType.Dynamic&&other._type!==VelcroPhysics.Dynamics.BodyType.Dynamic)return!1;for(var jn=this.JointList;jn!=null;jn=jn.Next)if(Bridge.referenceEquals(jn.Other,other)&&jn.Joint.CollideConnected===!1)return!1;return!0},Advance:function(alpha){this._sweep.Advance(alpha);this._sweep.C=this._sweep.C0.$clone();this._sweep.A=this._sweep.A0;this._xf.q.Set(this._sweep.A);this._xf.p=Microsoft.Xna.Framework.Vector2.op_Subtraction(this._sweep.C.$clone(),VelcroPhysics.Utilities.MathUtils.Mul$2(this._xf.q.$clone(),this._sweep.LocalCenter.$clone()))}}});Bridge.define("VelcroPhysics.Dynamics.BodyFlags",{$kind:"enum",statics:{fields:{Unknown:0,IslandFlag:1,AwakeFlag:2,AutoSleepFlag:4,BulletFlag:8,FixedRotationFlag:16,Enabled:32,IgnoreGravity:64,IgnoreCCD:128}},$flags:!0,$utype:System.Byte});Bridge.define("VelcroPhysics.Dynamics.BodyType",{$kind:"enum",statics:{fields:{Static:0,Kinematic:1,Dynamic:2}}});Bridge.define("VelcroPhysics.Dynamics.BreakableBody",{fields:{_angularVelocitiesCache:null,_break:!1,_velocitiesCache:null,_world:null,Strength:0,Broken:!1,MainBody:null,Parts:null},ctors:{init:function(){this._angularVelocitiesCache=System.Array.init(new Float32Array(8),System.Single);this._velocitiesCache=System.Array.init(8,function(){return new Microsoft.Xna.Framework.Vector2},Microsoft.Xna.Framework.Vector2)},$ctor1:function(world,vertices,density,position,rotation){var $t;position===void 0&&(position=new Microsoft.Xna.Framework.Vector2);rotation===void 0&&(rotation=0);this.$initialize();this._world=world;this._world.ContactManager.PostSolve=Bridge.fn.combine(this._world.ContactManager.PostSolve,Bridge.fn.cacheBind(this,this.PostSolve));this.Parts=new(System.Collections.Generic.List$1(VelcroPhysics.Dynamics.Fixture).$ctor2)(8);this.MainBody=VelcroPhysics.Factories.BodyFactory.CreateBody(this._world,position.$clone(),rotation,VelcroPhysics.Dynamics.BodyType.Dynamic);this.Strength=500;$t=Bridge.getEnumerator(vertices,VelcroPhysics.Shared.Vertices);try{while($t.moveNext()){var part=$t.Current,polygonShape=new VelcroPhysics.Collision.Shapes.PolygonShape.$ctor2(part,density),fixture=this.MainBody.CreateFixture(polygonShape);this.Parts.add(fixture)}}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}},ctor:function(world,shapes,position,rotation){var $t,part,fixture;position===void 0&&(position=new Microsoft.Xna.Framework.Vector2);rotation===void 0&&(rotation=0);this.$initialize();this._world=world;this._world.ContactManager.PostSolve=Bridge.fn.combine(this._world.ContactManager.PostSolve,Bridge.fn.cacheBind(this,this.PostSolve));this.MainBody=VelcroPhysics.Factories.BodyFactory.CreateBody(this._world,position.$clone(),rotation,VelcroPhysics.Dynamics.BodyType.Dynamic);this.Parts=new(System.Collections.Generic.List$1(VelcroPhysics.Dynamics.Fixture).$ctor2)(8);$t=Bridge.getEnumerator(shapes,VelcroPhysics.Collision.Shapes.Shape);try{while($t.moveNext())part=$t.Current,fixture=this.MainBody.CreateFixture(part),this.Parts.add(fixture)}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}}},methods:{PostSolve:function(contact,impulse){var maxImpulse,count,i;if(!this.Broken&&(this.Parts.contains(contact.FixtureA)||this.Parts.contains(contact.FixtureB))){for(maxImpulse=0,count=contact.Manifold.PointCount,i=0;i<count;i=i+1|0)maxImpulse=Math.max(maxImpulse,impulse.Points[i].NormalImpulse);maxImpulse>this.Strength&&(this._break=!0)}},Update:function(){if(this._break&&(this.Decompose(),this.Broken=!0,this._break=!1),this.Broken===!1){this.Parts.Count>this._angularVelocitiesCache.length&&(this._velocitiesCache=System.Array.init(this.Parts.Count,function(){return new Microsoft.Xna.Framework.Vector2},Microsoft.Xna.Framework.Vector2),this._angularVelocitiesCache=System.Array.init(new Float32Array(this.Parts.Count),System.Single));for(var i=0;i<this.Parts.Count;i=i+1|0)this._velocitiesCache[i]=this.Parts.getItem(i).Body.LinearVelocity.$clone(),this._angularVelocitiesCache[i]=this.Parts.getItem(i).Body.AngularVelocity}},Decompose:function(){var i,body,newFixture;for(this._world.ContactManager.PostSolve=Bridge.fn.remove(this._world.ContactManager.PostSolve,Bridge.fn.cacheBind(this,this.PostSolve)),i=0;i<this.Parts.Count;i=i+1|0){var oldFixture=this.Parts.getItem(i),shape=oldFixture.Shape.Clone(),userData=oldFixture.UserData;this.MainBody.DestroyFixture(oldFixture);body=VelcroPhysics.Factories.BodyFactory.CreateBody(this._world,this.MainBody.Position.$clone(),this.MainBody.Rotation,VelcroPhysics.Dynamics.BodyType.Dynamic,this.MainBody.UserData);newFixture=body.CreateFixture(shape);newFixture.UserData=userData;this.Parts.setItem(i,newFixture);body.AngularVelocity=this._angularVelocitiesCache[i];body.LinearVelocity=this._velocitiesCache[i].$clone()}this._world.RemoveBody(this.MainBody);this._world.RemoveBreakableBody(this)},Break:function(){this._break=!0}}});Bridge.define("VelcroPhysics.Dynamics.Fixture",{fields:{_collidesWith:0,_collisionCategories:0,_collisionGroup:0,_friction:0,_isSensor:!1,_restitution:0,AfterCollision:null,BeforeCollision:null,IgnoreCCDWith:0,OnCollision:null,OnSeparation:null,Proxies:null,ProxyCount:0,Shape:null,Body:null,UserData:null,FixtureId:0},props:{CollisionGroup:{get:function(){return this._collisionGroup},set:function(value){this._collisionGroup!==value&&(this._collisionGroup=value,this.Refilter())}},CollidesWith:{get:function(){return this._collidesWith},set:function(value){this._collidesWith!==value&&(this._collidesWith=value,this.Refilter())}},CollisionCategories:{get:function(){return this._collisionCategories},set:function(value){this._collisionCategories!==value&&(this._collisionCategories=value,this.Refilter())}},IsSensor:{get:function(){return this._isSensor},set:function(value){this.Body!=null&&(this.Body.Awake=!0);this._isSensor=value}},Friction:{get:function(){return this._friction},set:function(value){System.Diagnostics.Debug.Assert(!isNaN(value));this._friction=value}},Restitution:{get:function(){return this._restitution},set:function(value){System.Diagnostics.Debug.Assert(!isNaN(value));this._restitution=value}}},ctors:{ctor:function(){this.$initialize();this._collisionCategories=VelcroPhysics.Settings.DefaultFixtureCollisionCategories;this._collidesWith=VelcroPhysics.Settings.DefaultFixtureCollidesWith;this._collisionGroup=0;this.IgnoreCCDWith=VelcroPhysics.Settings.DefaultFixtureIgnoreCCDWith},$ctor1:function(body,template){VelcroPhysics.Dynamics.Fixture.ctor.call(this);this.UserData=template.UserData;this.Friction=template.Friction;this.Restitution=template.Restitution;this.Body=body;this.IsSensor=template.IsSensor;this.Shape=template.Shape.Clone();this.RegisterFixture()}},methods:{Refilter:function(){for(var edge=this.Body.ContactList,world,broadPhase,i;edge!=null;){var contact=edge.Contact,fixtureA=contact.FixtureA,fixtureB=contact.FixtureB;(Bridge.referenceEquals(fixtureA,this)||Bridge.referenceEquals(fixtureB,this))&&(contact._flags|=VelcroPhysics.Collision.ContactSystem.ContactFlags.FilterFlag&255);edge=edge.Next}if(world=this.Body._world,world!=null)for(broadPhase=world.ContactManager.BroadPhase,i=0;i<this.ProxyCount;i=i+1|0)broadPhase.VelcroPhysics$Collision$Broadphase$IBroadPhase$TouchProxy(this.Proxies[i].ProxyId)},RegisterFixture:function(){var $t,broadPhase;this.Proxies=System.Array.init(this.Shape.ChildCount,function(){return new VelcroPhysics.Dynamics.FixtureProxy},VelcroPhysics.Dynamics.FixtureProxy);this.ProxyCount=0;this.Body.Enabled&&(broadPhase=this.Body._world.ContactManager.BroadPhase,this.CreateProxies(broadPhase,Bridge.ref(this.Body,"_xf")));this.Body.FixtureList.add(this);this.Shape._density>0&&this.Body.ResetMassData();this.Body._world._worldHasNewFixture=!0;Bridge.staticEquals($t=this.Body._world.FixtureAdded,null)?null:$t(this)},TestPoint:function(point){return this.Shape.TestPoint(Bridge.ref(this.Body,"_xf"),point)},RayCast:function(output,input,childIndex){return this.Shape.RayCast(input,Bridge.ref(this.Body,"_xf"),childIndex,output)},GetAABB:function(aabb,childIndex){System.Diagnostics.Debug.Assert(0<=childIndex&&childIndex<this.ProxyCount);aabb.v=this.Proxies[childIndex].AABB.$clone()},Destroy:function(){var $t;System.Diagnostics.Debug.Assert(this.ProxyCount===0);this.Proxies=null;this.Shape=null;this.UserData=null;this.BeforeCollision=null;this.OnCollision=null;this.OnSeparation=null;this.AfterCollision=null;Bridge.staticEquals($t=this.Body._world.FixtureRemoved,null)?null:$t(this);this.Body._world.FixtureAdded=null;this.Body._world.FixtureRemoved=null;this.OnSeparation=null;this.OnCollision=null},CreateProxies:function(broadPhase,xf){var i,proxy;for(System.Diagnostics.Debug.Assert(this.ProxyCount===0),this.ProxyCount=this.Shape.ChildCount,i=0;i<this.ProxyCount;i=i+1|0)proxy={v:new VelcroPhysics.Dynamics.FixtureProxy},this.Shape.ComputeAABB(xf,i,Bridge.ref(proxy.v,"AABB")),proxy.v.Fixture=this,proxy.v.ChildIndex=i,proxy.v.ProxyId=broadPhase.VelcroPhysics$Collision$Broadphase$IBroadPhase$AddProxy(proxy),this.Proxies[i]=proxy.v.$clone()},DestroyProxies:function(broadPhase){for(var i=0;i<this.ProxyCount;i=i+1|0)broadPhase.VelcroPhysics$Collision$Broadphase$IBroadPhase$RemoveProxy(this.Proxies[i].ProxyId),this.Proxies[i].ProxyId=-1;this.ProxyCount=0},Synchronize:function(broadPhase,transform1,transform2){var i,displacement;if(this.ProxyCount!==0)for(i=0;i<this.ProxyCount;i=i+1|0){var proxy=this.Proxies[i].$clone(),aabb1={v:new VelcroPhysics.Shared.AABB},aabb2={v:new VelcroPhysics.Shared.AABB};this.Shape.ComputeAABB(transform1,proxy.ChildIndex,aabb1);this.Shape.ComputeAABB(transform2,proxy.ChildIndex,aabb2);proxy.AABB.Combine$1(aabb1,aabb2);displacement=Microsoft.Xna.Framework.Vector2.op_Subtraction(transform2.v.p.$clone(),transform1.v.p.$clone());broadPhase.VelcroPhysics$Collision$Broadphase$IBroadPhase$MoveProxy(proxy.ProxyId,Bridge.ref(proxy,"AABB"),displacement.$clone())}}}});Bridge.define("VelcroPhysics.Dynamics.FixtureProxy",{$kind:"struct",statics:{methods:{getDefaultValue:function(){return new VelcroPhysics.Dynamics.FixtureProxy}}},fields:{AABB:null,ChildIndex:0,Fixture:null,ProxyId:0},ctors:{init:function(){this.AABB=new VelcroPhysics.Shared.AABB},ctor:function(){this.$initialize()}},methods:{getHashCode:function(){return Bridge.addHash([5340810029,this.AABB,this.ChildIndex,this.Fixture,this.ProxyId])},equals:function(o){return Bridge.is(o,VelcroPhysics.Dynamics.FixtureProxy)?Bridge.equals(this.AABB,o.AABB)&&Bridge.equals(this.ChildIndex,o.ChildIndex)&&Bridge.equals(this.Fixture,o.Fixture)&&Bridge.equals(this.ProxyId,o.ProxyId):!1},$clone:function(to){var s=to||new VelcroPhysics.Dynamics.FixtureProxy;return s.AABB=this.AABB.$clone(),s.ChildIndex=this.ChildIndex,s.Fixture=this.Fixture,s.ProxyId=this.ProxyId,s}}});Bridge.define("VelcroPhysics.Dynamics.Joints.Joint",{fields:{_breakpoint:0,_breakpointSquared:0,EdgeA:null,EdgeB:null,Enabled:!1,IslandFlag:!1,JointType:0,BodyA:null,BodyB:null,UserData:null,CollideConnected:!1},events:{Broke:null},props:{Breakpoint:{get:function(){return this._breakpoint},set:function(value){this._breakpoint=value;this._breakpointSquared=this._breakpoint*this._breakpoint}}},ctors:{init:function(){this.EdgeA=new VelcroPhysics.Dynamics.Joints.JointEdge;this.EdgeB=new VelcroPhysics.Dynamics.Joints.JointEdge;this.Enabled=!0},ctor:function(){this.$initialize();this.Breakpoint=340282347e30;this.CollideConnected=!1},$ctor2:function(bodyA,bodyB){VelcroPhysics.Dynamics.Joints.Joint.ctor.call(this);System.Diagnostics.Debug.Assert(!Bridge.referenceEquals(bodyA,bodyB));this.BodyA=bodyA;this.BodyB=bodyB},$ctor1:function(body){VelcroPhysics.Dynamics.Joints.Joint.ctor.call(this);this.BodyA=body}},methods:{WakeBodies:function(){this.BodyA!=null&&(this.BodyA.Awake=!0);this.BodyB!=null&&(this.BodyB.Awake=!0)},IsFixedType:function(){return this.JointType===VelcroPhysics.Dynamics.Joints.JointType.FixedRevolute||this.JointType===VelcroPhysics.Dynamics.Joints.JointType.FixedDistance||this.JointType===VelcroPhysics.Dynamics.Joints.JointType.FixedPrismatic||this.JointType===VelcroPhysics.Dynamics.Joints.JointType.FixedLine||this.JointType===VelcroPhysics.Dynamics.Joints.JointType.FixedMouse||this.JointType===VelcroPhysics.Dynamics.Joints.JointType.FixedAngle||this.JointType===VelcroPhysics.Dynamics.Joints.JointType.FixedFriction},Validate:function(invDt){if(this.Enabled){var jointErrorSquared=this.GetReactionForce(invDt).LengthSquared();Math.abs(jointErrorSquared)<=this._breakpointSquared||(this.Enabled=!1,Bridge.staticEquals(this.Broke,null)?null:this.Broke(this,Math.sqrt(jointErrorSquared)))}}}});Bridge.define("VelcroPhysics.Dynamics.Joints.JointEdge",{fields:{Joint:null,Next:null,Other:null,Prev:null}});Bridge.define("VelcroPhysics.Dynamics.Joints.JointType",{$kind:"enum",statics:{fields:{Unknown:0,Revolute:1,Prismatic:2,Distance:3,Pulley:4,Gear:5,Wheel:6,Weld:7,Friction:8,Rope:9,Motor:10,Angle:11,FixedMouse:12,FixedRevolute:13,FixedDistance:14,FixedLine:15,FixedPrismatic:16,FixedAngle:17,FixedFriction:18}}});Bridge.define("VelcroPhysics.Dynamics.Joints.LimitState",{$kind:"enum",statics:{fields:{Inactive:0,AtLower:1,AtUpper:2,Equal:3}}});Bridge.define("VelcroPhysics.Dynamics.Solver.ContactPositionConstraint",{fields:{IndexA:0,IndexB:0,InvIA:0,InvIB:0,InvMassA:0,InvMassB:0,LocalCenterA:null,LocalCenterB:null,LocalNormal:null,LocalPoint:null,LocalPoints:null,PointCount:0,RadiusA:0,RadiusB:0,Type:0},ctors:{init:function(){this.LocalCenterA=new Microsoft.Xna.Framework.Vector2;this.LocalCenterB=new Microsoft.Xna.Framework.Vector2;this.LocalNormal=new Microsoft.Xna.Framework.Vector2;this.LocalPoint=new Microsoft.Xna.Framework.Vector2;this.LocalPoints=System.Array.init(VelcroPhysics.Settings.MaxManifoldPoints,function(){return new Microsoft.Xna.Framework.Vector2},Microsoft.Xna.Framework.Vector2)}}});Bridge.define("VelcroPhysics.Dynamics.Solver.ContactSolver",{fields:{_contacts:null,_count:0,_positionConstraints:null,_positions:null,_step:null,_velocities:null,VelocityConstraints:null},ctors:{init:function(){this._step=new VelcroPhysics.Dynamics.TimeStep}},methods:{Reset:function(step,count,contacts,positions,velocities){var i,i1,i2,vc,pc,j,cp,vcp;if(this._step=step.$clone(),this._count=count,this._positions=positions,this._velocities=velocities,this._contacts=contacts,this.VelocityConstraints==null||this.VelocityConstraints.length<count){for(this.VelocityConstraints=System.Array.init(Bridge.Int.mul(count,2),null,VelcroPhysics.Dynamics.Solver.ContactVelocityConstraint),this._positionConstraints=System.Array.init(Bridge.Int.mul(count,2),null,VelcroPhysics.Dynamics.Solver.ContactPositionConstraint),i=0;i<this.VelocityConstraints.length;i=i+1|0)this.VelocityConstraints[i]=new VelcroPhysics.Dynamics.Solver.ContactVelocityConstraint;for(i1=0;i1<this._positionConstraints.length;i1=i1+1|0)this._positionConstraints[i1]=new VelcroPhysics.Dynamics.Solver.ContactPositionConstraint}for(i2=0;i2<this._count;i2=i2+1|0){var contact=contacts[i2],fixtureA=contact.FixtureA,fixtureB=contact.FixtureB,shapeA=fixtureA.Shape,shapeB=fixtureB.Shape,radiusA=shapeA.Radius,radiusB=shapeB.Radius,bodyA=fixtureA.Body,bodyB=fixtureB.Body,manifold=contact.Manifold.$clone(),pointCount=manifold.PointCount;for(System.Diagnostics.Debug.Assert(pointCount>0),vc=this.VelocityConstraints[i2],vc.Friction=contact.Friction,vc.Restitution=contact.Restitution,vc.TangentSpeed=contact.TangentSpeed,vc.IndexA=bodyA.IslandIndex,vc.IndexB=bodyB.IslandIndex,vc.InvMassA=bodyA._invMass,vc.InvMassB=bodyB._invMass,vc.InvIA=bodyA._invI,vc.InvIB=bodyB._invI,vc.ContactIndex=i2,vc.PointCount=pointCount,vc.K.SetZero(),vc.NormalMass.SetZero(),pc=this._positionConstraints[i2],pc.IndexA=bodyA.IslandIndex,pc.IndexB=bodyB.IslandIndex,pc.InvMassA=bodyA._invMass,pc.InvMassB=bodyB._invMass,pc.LocalCenterA=bodyA._sweep.LocalCenter.$clone(),pc.LocalCenterB=bodyB._sweep.LocalCenter.$clone(),pc.InvIA=bodyA._invI,pc.InvIB=bodyB._invI,pc.LocalNormal=manifold.LocalNormal.$clone(),pc.LocalPoint=manifold.LocalPoint.$clone(),pc.PointCount=pointCount,pc.RadiusA=radiusA,pc.RadiusB=radiusB,pc.Type=manifold.Type,j=0;j<pointCount;j=j+1|0)cp=manifold.Points.getItem(j).$clone(),vcp=vc.Points[j],VelcroPhysics.Settings.EnableWarmstarting?(vcp.NormalImpulse=this._step.dtRatio*cp.NormalImpulse,vcp.TangentImpulse=this._step.dtRatio*cp.TangentImpulse):(vcp.NormalImpulse=0,vcp.TangentImpulse=0),vcp.rA=Microsoft.Xna.Framework.Vector2.Zero.$clone(),vcp.rB=Microsoft.Xna.Framework.Vector2.Zero.$clone(),vcp.NormalMass=0,vcp.TangentMass=0,vcp.VelocityBias=0,pc.LocalPoints[j]=cp.LocalPoint.$clone()}},InitializeVelocityConstraints:function(){for(var xfA,xfB,pointCount,j,vcp,vRel,i=0;i<this._count;i=i+1|0){var vc=this.VelocityConstraints[i],pc=this._positionConstraints[i],radiusA=pc.RadiusA,radiusB=pc.RadiusB,manifold={v:this._contacts[vc.ContactIndex].Manifold.$clone()},indexA=vc.IndexA,indexB=vc.IndexB,mA=vc.InvMassA,mB=vc.InvMassB,iA=vc.InvIA,iB=vc.InvIB,localCenterA=pc.LocalCenterA.$clone(),localCenterB=pc.LocalCenterB.$clone(),cA=this._positions[indexA].C.$clone(),aA=this._positions[indexA].A,vA=this._velocities[indexA].V.$clone(),wA=this._velocities[indexA].W,cB=this._positions[indexB].C.$clone(),aB=this._positions[indexB].A,vB=this._velocities[indexB].V.$clone(),wB=this._velocities[indexB].W;System.Diagnostics.Debug.Assert(manifold.v.PointCount>0);xfA={v:new VelcroPhysics.Shared.Transform.ctor};xfB={v:new VelcroPhysics.Shared.Transform.ctor};xfA.v.q.Set(aA);xfB.v.q.Set(aB);xfA.v.p=Microsoft.Xna.Framework.Vector2.op_Subtraction(cA.$clone(),VelcroPhysics.Utilities.MathUtils.Mul$2(xfA.v.q.$clone(),localCenterA.$clone()));xfB.v.p=Microsoft.Xna.Framework.Vector2.op_Subtraction(cB.$clone(),VelcroPhysics.Utilities.MathUtils.Mul$2(xfB.v.q.$clone(),localCenterB.$clone()));var _discard1={v:new(VelcroPhysics.Shared.Optimization.FixedArray2$1(System.Single))},normal={v:new Microsoft.Xna.Framework.Vector2},points={v:new(VelcroPhysics.Shared.Optimization.FixedArray2$1(Microsoft.Xna.Framework.Vector2))};for(VelcroPhysics.Collision.Narrowphase.WorldManifold.Initialize(manifold,xfA,radiusA,xfB,radiusB,normal,points,_discard1),vc.Normal=normal.v.$clone(),pointCount=vc.PointCount,j=0;j<pointCount;j=j+1|0){vcp=vc.Points[j];vcp.rA=Microsoft.Xna.Framework.Vector2.op_Subtraction(points.v.getItem(j).$clone(),cA.$clone());vcp.rB=Microsoft.Xna.Framework.Vector2.op_Subtraction(points.v.getItem(j).$clone(),cB.$clone());var rnA=VelcroPhysics.Utilities.MathUtils.Cross$3(vcp.rA.$clone(),vc.Normal.$clone()),rnB=VelcroPhysics.Utilities.MathUtils.Cross$3(vcp.rB.$clone(),vc.Normal.$clone()),kNormal=mA+mB+iA*rnA*rnA+iB*rnB*rnB;vcp.NormalMass=kNormal>0?1/kNormal:0;var tangent=VelcroPhysics.Utilities.MathUtils.Cross(vc.Normal.$clone(),1),rtA=VelcroPhysics.Utilities.MathUtils.Cross$3(vcp.rA.$clone(),tangent.$clone()),rtB=VelcroPhysics.Utilities.MathUtils.Cross$3(vcp.rB.$clone(),tangent.$clone()),kTangent=mA+mB+iA*rtA*rtA+iB*rtB*rtB;vcp.TangentMass=kTangent>0?1/kTangent:0;vcp.VelocityBias=0;vRel=Microsoft.Xna.Framework.Vector2.Dot(vc.Normal.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(),VelcroPhysics.Utilities.MathUtils.Cross$1(wB,vcp.rB.$clone())),vA.$clone()),VelcroPhysics.Utilities.MathUtils.Cross$1(wA,vcp.rA.$clone())));vRel<-1&&(vcp.VelocityBias=-vc.Restitution*vRel)}if(vc.PointCount===2&&VelcroPhysics.Settings.BlockSolve){var vcp1=vc.Points[0],vcp2=vc.Points[1],rn1A=VelcroPhysics.Utilities.MathUtils.Cross$3(vcp1.rA.$clone(),vc.Normal.$clone()),rn1B=VelcroPhysics.Utilities.MathUtils.Cross$3(vcp1.rB.$clone(),vc.Normal.$clone()),rn2A=VelcroPhysics.Utilities.MathUtils.Cross$3(vcp2.rA.$clone(),vc.Normal.$clone()),rn2B=VelcroPhysics.Utilities.MathUtils.Cross$3(vcp2.rB.$clone(),vc.Normal.$clone()),k11=mA+mB+iA*rn1A*rn1A+iB*rn1B*rn1B,k22=mA+mB+iA*rn2A*rn2A+iB*rn2B*rn2B,k12=mA+mB+iA*rn1A*rn2A+iB*rn1B*rn2B,k_maxConditionNumber=1e3;k11*k11<k_maxConditionNumber*(k11*k22-k12*k12)?(vc.K.ex=new Microsoft.Xna.Framework.Vector2.$ctor2(k11,k12),vc.K.ey=new Microsoft.Xna.Framework.Vector2.$ctor2(k12,k22),vc.NormalMass=vc.K.Inverse.$clone()):vc.PointCount=1}}},WarmStart:function(){for(var j,vcp,P,i=0;i<this._count;i=i+1|0){var vc=this.VelocityConstraints[i],indexA=vc.IndexA,indexB=vc.IndexB,mA=vc.InvMassA,iA=vc.InvIA,mB=vc.InvMassB,iB=vc.InvIB,pointCount=vc.PointCount,vA=this._velocities[indexA].V.$clone(),wA=this._velocities[indexA].W,vB=this._velocities[indexB].V.$clone(),wB=this._velocities[indexB].W,normal=vc.Normal.$clone(),tangent=VelcroPhysics.Utilities.MathUtils.Cross(normal.$clone(),1);for(j=0;j<pointCount;j=j+1|0)vcp=vc.Points[j],P=Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(vcp.NormalImpulse,normal.$clone()),Microsoft.Xna.Framework.Vector2.op_Multiply$2(vcp.TangentImpulse,tangent.$clone())),wA-=iA*VelcroPhysics.Utilities.MathUtils.Cross$3(vcp.rA.$clone(),P.$clone()),vA=Microsoft.Xna.Framework.Vector2.op_Subtraction(vA.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mA,P.$clone())),wB+=iB*VelcroPhysics.Utilities.MathUtils.Cross$3(vcp.rB.$clone(),P.$clone()),vB=Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mB,P.$clone()));this._velocities[indexA].V=vA.$clone();this._velocities[indexA].W=wA;this._velocities[indexB].V=vB.$clone();this._velocities[indexB].W=wB}},SolveVelocityConstraints:function(){for(var j,P,j1,P1,k_errorTol,x,i=0;i<this._count;i=i+1|0){var vc=this.VelocityConstraints[i],indexA=vc.IndexA,indexB=vc.IndexB,mA=vc.InvMassA,iA=vc.InvIA,mB=vc.InvMassB,iB=vc.InvIB,pointCount=vc.PointCount,vA=this._velocities[indexA].V.$clone(),wA=this._velocities[indexA].W,vB=this._velocities[indexB].V.$clone(),wB=this._velocities[indexB].W,normal=vc.Normal.$clone(),tangent=VelcroPhysics.Utilities.MathUtils.Cross(normal.$clone(),1),friction=vc.Friction;for(System.Diagnostics.Debug.Assert(pointCount===1||pointCount===2),j=0;j<pointCount;j=j+1|0){var vcp=vc.Points[j],dv=Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(),VelcroPhysics.Utilities.MathUtils.Cross$1(wB,vcp.rB.$clone())),vA.$clone()),VelcroPhysics.Utilities.MathUtils.Cross$1(wA,vcp.rA.$clone())),vt=Microsoft.Xna.Framework.Vector2.Dot(dv.$clone(),tangent.$clone())-vc.TangentSpeed,lambda=vcp.TangentMass*-vt,maxFriction=friction*vcp.NormalImpulse,newImpulse=VelcroPhysics.Utilities.MathUtils.Clamp$2(vcp.TangentImpulse+lambda,-maxFriction,maxFriction);lambda=newImpulse-vcp.TangentImpulse;vcp.TangentImpulse=newImpulse;P=Microsoft.Xna.Framework.Vector2.op_Multiply$2(lambda,tangent.$clone());vA=Microsoft.Xna.Framework.Vector2.op_Subtraction(vA.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mA,P.$clone()));wA-=iA*VelcroPhysics.Utilities.MathUtils.Cross$3(vcp.rA.$clone(),P.$clone());vB=Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mB,P.$clone()));wB+=iB*VelcroPhysics.Utilities.MathUtils.Cross$3(vcp.rB.$clone(),P.$clone())}if(pointCount===1||!1)for(j1=0;j1<pointCount;j1=j1+1|0){var vcp1=vc.Points[j1],dv1=Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(),VelcroPhysics.Utilities.MathUtils.Cross$1(wB,vcp1.rB.$clone())),vA.$clone()),VelcroPhysics.Utilities.MathUtils.Cross$1(wA,vcp1.rA.$clone())),vn=Microsoft.Xna.Framework.Vector2.Dot(dv1.$clone(),normal.$clone()),lambda1=-vcp1.NormalMass*(vn-vcp1.VelocityBias),newImpulse1=Math.max(vcp1.NormalImpulse+lambda1,0);lambda1=newImpulse1-vcp1.NormalImpulse;vcp1.NormalImpulse=newImpulse1;P1=Microsoft.Xna.Framework.Vector2.op_Multiply$2(lambda1,normal.$clone());vA=Microsoft.Xna.Framework.Vector2.op_Subtraction(vA.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mA,P1.$clone()));wA-=iA*VelcroPhysics.Utilities.MathUtils.Cross$3(vcp1.rA.$clone(),P1.$clone());vB=Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mB,P1.$clone()));wB+=iB*VelcroPhysics.Utilities.MathUtils.Cross$3(vcp1.rB.$clone(),P1.$clone())}else{var cp1=vc.Points[0],cp2=vc.Points[1],a=new Microsoft.Xna.Framework.Vector2.$ctor2(cp1.NormalImpulse,cp2.NormalImpulse);System.Diagnostics.Debug.Assert(a.X>=0&&a.Y>=0);var dv11=Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(),VelcroPhysics.Utilities.MathUtils.Cross$1(wB,cp1.rB.$clone())),vA.$clone()),VelcroPhysics.Utilities.MathUtils.Cross$1(wA,cp1.rA.$clone())),dv2=Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(),VelcroPhysics.Utilities.MathUtils.Cross$1(wB,cp2.rB.$clone())),vA.$clone()),VelcroPhysics.Utilities.MathUtils.Cross$1(wA,cp2.rA.$clone())),vn1=Microsoft.Xna.Framework.Vector2.Dot(dv11.$clone(),normal.$clone()),vn2=Microsoft.Xna.Framework.Vector2.Dot(dv2.$clone(),normal.$clone()),b=Microsoft.Xna.Framework.Vector2.Zero.$clone();for(b.X=vn1-cp1.VelocityBias,b.Y=vn2-cp2.VelocityBias,k_errorTol=.001,b=Microsoft.Xna.Framework.Vector2.op_Subtraction(b.$clone(),VelcroPhysics.Utilities.MathUtils.Mul(Bridge.ref(vc,"K"),a.$clone()));;){if(x=Microsoft.Xna.Framework.Vector2.op_UnaryNegation(VelcroPhysics.Utilities.MathUtils.Mul(Bridge.ref(vc,"NormalMass"),b.$clone())),x.X>=0&&x.Y>=0){var d=Microsoft.Xna.Framework.Vector2.op_Subtraction(x.$clone(),a.$clone()),P11=Microsoft.Xna.Framework.Vector2.op_Multiply$2(d.X,normal.$clone()),P2=Microsoft.Xna.Framework.Vector2.op_Multiply$2(d.Y,normal.$clone());vA=Microsoft.Xna.Framework.Vector2.op_Subtraction(vA.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mA,Microsoft.Xna.Framework.Vector2.op_Addition(P11.$clone(),P2.$clone())));wA-=iA*(VelcroPhysics.Utilities.MathUtils.Cross$3(cp1.rA.$clone(),P11.$clone())+VelcroPhysics.Utilities.MathUtils.Cross$3(cp2.rA.$clone(),P2.$clone()));vB=Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mB,Microsoft.Xna.Framework.Vector2.op_Addition(P11.$clone(),P2.$clone())));wB+=iB*(VelcroPhysics.Utilities.MathUtils.Cross$3(cp1.rB.$clone(),P11.$clone())+VelcroPhysics.Utilities.MathUtils.Cross$3(cp2.rB.$clone(),P2.$clone()));cp1.NormalImpulse=x.X;cp2.NormalImpulse=x.Y;break}if(x.X=-cp1.NormalMass*b.X,x.Y=0,vn1=0,vn2=vc.K.ex.Y*x.X+b.Y,x.X>=0&&vn2>=0){var d1=Microsoft.Xna.Framework.Vector2.op_Subtraction(x.$clone(),a.$clone()),P12=Microsoft.Xna.Framework.Vector2.op_Multiply$2(d1.X,normal.$clone()),P21=Microsoft.Xna.Framework.Vector2.op_Multiply$2(d1.Y,normal.$clone());vA=Microsoft.Xna.Framework.Vector2.op_Subtraction(vA.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mA,Microsoft.Xna.Framework.Vector2.op_Addition(P12.$clone(),P21.$clone())));wA-=iA*(VelcroPhysics.Utilities.MathUtils.Cross$3(cp1.rA.$clone(),P12.$clone())+VelcroPhysics.Utilities.MathUtils.Cross$3(cp2.rA.$clone(),P21.$clone()));vB=Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mB,Microsoft.Xna.Framework.Vector2.op_Addition(P12.$clone(),P21.$clone())));wB+=iB*(VelcroPhysics.Utilities.MathUtils.Cross$3(cp1.rB.$clone(),P12.$clone())+VelcroPhysics.Utilities.MathUtils.Cross$3(cp2.rB.$clone(),P21.$clone()));cp1.NormalImpulse=x.X;cp2.NormalImpulse=x.Y;break}if(x.X=0,x.Y=-cp2.NormalMass*b.Y,vn1=vc.K.ey.X*x.Y+b.X,vn2=0,x.Y>=0&&vn1>=0){var d2=Microsoft.Xna.Framework.Vector2.op_Subtraction(x.$clone(),a.$clone()),P13=Microsoft.Xna.Framework.Vector2.op_Multiply$2(d2.X,normal.$clone()),P22=Microsoft.Xna.Framework.Vector2.op_Multiply$2(d2.Y,normal.$clone());vA=Microsoft.Xna.Framework.Vector2.op_Subtraction(vA.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mA,Microsoft.Xna.Framework.Vector2.op_Addition(P13.$clone(),P22.$clone())));wA-=iA*(VelcroPhysics.Utilities.MathUtils.Cross$3(cp1.rA.$clone(),P13.$clone())+VelcroPhysics.Utilities.MathUtils.Cross$3(cp2.rA.$clone(),P22.$clone()));vB=Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mB,Microsoft.Xna.Framework.Vector2.op_Addition(P13.$clone(),P22.$clone())));wB+=iB*(VelcroPhysics.Utilities.MathUtils.Cross$3(cp1.rB.$clone(),P13.$clone())+VelcroPhysics.Utilities.MathUtils.Cross$3(cp2.rB.$clone(),P22.$clone()));cp1.NormalImpulse=x.X;cp2.NormalImpulse=x.Y;break}if(x.X=0,x.Y=0,vn1=b.X,vn2=b.Y,vn1>=0&&vn2>=0){var d3=Microsoft.Xna.Framework.Vector2.op_Subtraction(x.$clone(),a.$clone()),P14=Microsoft.Xna.Framework.Vector2.op_Multiply$2(d3.X,normal.$clone()),P23=Microsoft.Xna.Framework.Vector2.op_Multiply$2(d3.Y,normal.$clone());vA=Microsoft.Xna.Framework.Vector2.op_Subtraction(vA.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mA,Microsoft.Xna.Framework.Vector2.op_Addition(P14.$clone(),P23.$clone())));wA-=iA*(VelcroPhysics.Utilities.MathUtils.Cross$3(cp1.rA.$clone(),P14.$clone())+VelcroPhysics.Utilities.MathUtils.Cross$3(cp2.rA.$clone(),P23.$clone()));vB=Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mB,Microsoft.Xna.Framework.Vector2.op_Addition(P14.$clone(),P23.$clone())));wB+=iB*(VelcroPhysics.Utilities.MathUtils.Cross$3(cp1.rB.$clone(),P14.$clone())+VelcroPhysics.Utilities.MathUtils.Cross$3(cp2.rB.$clone(),P23.$clone()));cp1.NormalImpulse=x.X;cp2.NormalImpulse=x.Y;break}break}}this._velocities[indexA].V=vA.$clone();this._velocities[indexA].W=wA;this._velocities[indexB].V=vB.$clone();this._velocities[indexB].W=wB}},StoreImpulses:function(){for(var vc,manifold,j,point,i=0;i<this._count;i=i+1|0){for(vc=this.VelocityConstraints[i],manifold=this._contacts[vc.ContactIndex].Manifold.$clone(),j=0;j<vc.PointCount;j=j+1|0)point=manifold.Points.getItem(j).$clone(),point.NormalImpulse=vc.Points[j].NormalImpulse,point.TangentImpulse=vc.Points[j].TangentImpulse,manifold.Points.setItem(j,point.$clone());this._contacts[vc.ContactIndex].Manifold=manifold.$clone()}},SolvePositionConstraints:function(){for(var j,xfA,xfB,rA,rB,minSeparation=0,i=0;i<this._count;i=i+1|0){var pc=this._positionConstraints[i],indexA=pc.IndexA,indexB=pc.IndexB,localCenterA=pc.LocalCenterA.$clone(),mA=pc.InvMassA,iA=pc.InvIA,localCenterB=pc.LocalCenterB.$clone(),mB=pc.InvMassB,iB=pc.InvIB,pointCount=pc.PointCount,cA=this._positions[indexA].C.$clone(),aA=this._positions[indexA].A,cB=this._positions[indexB].C.$clone(),aB=this._positions[indexB].A;for(j=0;j<pointCount;j=j+1|0){xfA=new VelcroPhysics.Shared.Transform.ctor;xfB=new VelcroPhysics.Shared.Transform.ctor;xfA.q.Set(aA);xfB.q.Set(aB);xfA.p=Microsoft.Xna.Framework.Vector2.op_Subtraction(cA.$clone(),VelcroPhysics.Utilities.MathUtils.Mul$2(xfA.q.$clone(),localCenterA.$clone()));xfB.p=Microsoft.Xna.Framework.Vector2.op_Subtraction(cB.$clone(),VelcroPhysics.Utilities.MathUtils.Mul$2(xfB.q.$clone(),localCenterB.$clone()));var normal={v:new Microsoft.Xna.Framework.Vector2},point={v:new Microsoft.Xna.Framework.Vector2},separation={};VelcroPhysics.Dynamics.Solver.PositionSolverManifold.Initialize(pc,xfA.$clone(),xfB.$clone(),j,normal,point,separation);rA=Microsoft.Xna.Framework.Vector2.op_Subtraction(point.v.$clone(),cA.$clone());rB=Microsoft.Xna.Framework.Vector2.op_Subtraction(point.v.$clone(),cB.$clone());minSeparation=Math.min(minSeparation,separation.v);var C=VelcroPhysics.Utilities.MathUtils.Clamp$2(VelcroPhysics.Settings.Baumgarte*(separation.v+VelcroPhysics.Settings.LinearSlop),-.2,0),rnA=VelcroPhysics.Utilities.MathUtils.Cross$3(rA.$clone(),normal.v.$clone()),rnB=VelcroPhysics.Utilities.MathUtils.Cross$3(rB.$clone(),normal.v.$clone()),K=mA+mB+iA*rnA*rnA+iB*rnB*rnB,impulse=K>0?-C/K:0,P=Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse,normal.v.$clone());cA=Microsoft.Xna.Framework.Vector2.op_Subtraction(cA.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mA,P.$clone()));aA-=iA*VelcroPhysics.Utilities.MathUtils.Cross$3(rA.$clone(),P.$clone());cB=Microsoft.Xna.Framework.Vector2.op_Addition(cB.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mB,P.$clone()));aB+=iB*VelcroPhysics.Utilities.MathUtils.Cross$3(rB.$clone(),P.$clone())}this._positions[indexA].C=cA.$clone();this._positions[indexA].A=aA;this._positions[indexB].C=cB.$clone();this._positions[indexB].A=aB}return minSeparation>=-.015},SolveTOIPositionConstraints:function(toiIndexA,toiIndexB){for(var mB,iB,j,xfA,xfB,rA,rB,minSeparation=0,i=0;i<this._count;i=i+1|0){var pc=this._positionConstraints[i],indexA=pc.IndexA,indexB=pc.IndexB,localCenterA=pc.LocalCenterA.$clone(),localCenterB=pc.LocalCenterB.$clone(),pointCount=pc.PointCount,mA=0,iA=0;(indexA===toiIndexA||indexA===toiIndexB)&&(mA=pc.InvMassA,iA=pc.InvIA);mB=0;iB=0;(indexB===toiIndexA||indexB===toiIndexB)&&(mB=pc.InvMassB,iB=pc.InvIB);var cA=this._positions[indexA].C.$clone(),aA=this._positions[indexA].A,cB=this._positions[indexB].C.$clone(),aB=this._positions[indexB].A;for(j=0;j<pointCount;j=j+1|0){xfA=new VelcroPhysics.Shared.Transform.ctor;xfB=new VelcroPhysics.Shared.Transform.ctor;xfA.q.Set(aA);xfB.q.Set(aB);xfA.p=Microsoft.Xna.Framework.Vector2.op_Subtraction(cA.$clone(),VelcroPhysics.Utilities.MathUtils.Mul$2(xfA.q.$clone(),localCenterA.$clone()));xfB.p=Microsoft.Xna.Framework.Vector2.op_Subtraction(cB.$clone(),VelcroPhysics.Utilities.MathUtils.Mul$2(xfB.q.$clone(),localCenterB.$clone()));var normal={v:new Microsoft.Xna.Framework.Vector2},point={v:new Microsoft.Xna.Framework.Vector2},separation={};VelcroPhysics.Dynamics.Solver.PositionSolverManifold.Initialize(pc,xfA.$clone(),xfB.$clone(),j,normal,point,separation);rA=Microsoft.Xna.Framework.Vector2.op_Subtraction(point.v.$clone(),cA.$clone());rB=Microsoft.Xna.Framework.Vector2.op_Subtraction(point.v.$clone(),cB.$clone());minSeparation=Math.min(minSeparation,separation.v);var C=VelcroPhysics.Utilities.MathUtils.Clamp$2(VelcroPhysics.Settings.Baumgarte*(separation.v+VelcroPhysics.Settings.LinearSlop),-.2,0),rnA=VelcroPhysics.Utilities.MathUtils.Cross$3(rA.$clone(),normal.v.$clone()),rnB=VelcroPhysics.Utilities.MathUtils.Cross$3(rB.$clone(),normal.v.$clone()),K=mA+mB+iA*rnA*rnA+iB*rnB*rnB,impulse=K>0?-C/K:0,P=Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse,normal.v.$clone());cA=Microsoft.Xna.Framework.Vector2.op_Subtraction(cA.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mA,P.$clone()));aA-=iA*VelcroPhysics.Utilities.MathUtils.Cross$3(rA.$clone(),P.$clone());cB=Microsoft.Xna.Framework.Vector2.op_Addition(cB.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mB,P.$clone()));aB+=iB*VelcroPhysics.Utilities.MathUtils.Cross$3(rB.$clone(),P.$clone())}this._positions[indexA].C=cA.$clone();this._positions[indexA].A=aA;this._positions[indexB].C=cB.$clone();this._positions[indexB].A=aB}return minSeparation>=-.0075}}});Bridge.define("VelcroPhysics.Dynamics.Solver.ContactVelocityConstraint",{fields:{ContactIndex:0,Friction:0,IndexA:0,IndexB:0,InvIA:0,InvIB:0,InvMassA:0,InvMassB:0,K:null,Normal:null,NormalMass:null,PointCount:0,Points:null,Restitution:0,TangentSpeed:0},ctors:{init:function(){this.K=new VelcroPhysics.Shared.Mat22;this.Normal=new Microsoft.Xna.Framework.Vector2;this.NormalMass=new VelcroPhysics.Shared.Mat22;this.Points=System.Array.init(VelcroPhysics.Settings.MaxManifoldPoints,null,VelcroPhysics.Dynamics.Solver.VelocityConstraintPoint)},ctor:function(){this.$initialize();for(var i=0;i<VelcroPhysics.Settings.MaxManifoldPoints;i=i+1|0)this.Points[i]=new VelcroPhysics.Dynamics.Solver.VelocityConstraintPoint}}});Bridge.define("VelcroPhysics.Dynamics.Solver.Island",{statics:{fields:{LinTolSqr:0,AngTolSqr:0},ctors:{init:function(){this.LinTolSqr=.0001;this.AngTolSqr=.00121846993}}},fields:{_contactManager:null,_contacts:null,_contactSolver:null,_joints:null,_watch:null,Bodies:null,Positions:null,Velocities:null,BodyCapacity:0,BodyCount:0,ContactCapacity:0,ContactCount:0,JointCapacity:0,JointCount:0,JointUpdateTime:0},ctors:{init:function(){this._contactSolver=new VelcroPhysics.Dynamics.Solver.ContactSolver;this._watch=new System.Diagnostics.Stopwatch}},methods:{Reset:function(bodyCapacity,contactCapacity,jointCapacity,contactManager){this.BodyCapacity=bodyCapacity;this.ContactCapacity=contactCapacity;this.JointCapacity=jointCapacity;this.BodyCount=0;this.ContactCount=0;this.JointCount=0;this._contactManager=contactManager;(this.Bodies==null||this.Bodies.length<bodyCapacity)&&(this.Bodies=System.Array.init(bodyCapacity,null,VelcroPhysics.Dynamics.Body),this.Velocities=System.Array.init(bodyCapacity,function(){return new VelcroPhysics.Dynamics.Solver.Velocity},VelcroPhysics.Dynamics.Solver.Velocity),this.Positions=System.Array.init(bodyCapacity,function(){return new VelcroPhysics.Dynamics.Solver.Position},VelcroPhysics.Dynamics.Solver.Position));(this._contacts==null||this._contacts.length<contactCapacity)&&(this._contacts=System.Array.init(Bridge.Int.mul(contactCapacity,2),null,VelcroPhysics.Collision.ContactSystem.Contact));(this._joints==null||this._joints.length<jointCapacity)&&(this._joints=System.Array.init(Bridge.Int.mul(jointCapacity,2),null,VelcroPhysics.Dynamics.Joints.Joint))},Clear:function(){this.BodyCount=0;this.ContactCount=0;this.JointCount=0},Solve:function(step,gravity){for(var solverData,i1,i2,j,joint,i3,ratio,rotation,ratio1,positionSolved,i4,contactsOkay,jointsOkay,j1,joint1,jointOkay,i5,body,minSleepTime,i6,b1,i7,b2,h=step.v.dt,i=0;i<this.BodyCount;i=i+1|0){var b=this.Bodies[i],c=b._sweep.C.$clone(),a=b._sweep.A,v=b._linearVelocity.$clone(),w=b._angularVelocity;b._sweep.C0=b._sweep.C.$clone();b._sweep.A0=b._sweep.A;b.BodyType===VelcroPhysics.Dynamics.BodyType.Dynamic&&(v=b.IgnoreGravity?Microsoft.Xna.Framework.Vector2.op_Addition(v.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(h,Microsoft.Xna.Framework.Vector2.op_Multiply$2(b._invMass,b._force.$clone()))):Microsoft.Xna.Framework.Vector2.op_Addition(v.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(h,Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(b.GravityScale,gravity.v.$clone()),Microsoft.Xna.Framework.Vector2.op_Multiply$2(b._invMass,b._force.$clone())))),w+=h*b._invI*b._torque,v=Microsoft.Xna.Framework.Vector2.op_Multiply$1(v.$clone(),VelcroPhysics.Utilities.MathUtils.Clamp$2(1-h*b.LinearDamping,0,1)),w*=VelcroPhysics.Utilities.MathUtils.Clamp$2(1-h*b.AngularDamping,0,1));this.Positions[i].C=c.$clone();this.Positions[i].A=a;this.Velocities[i].V=v.$clone();this.Velocities[i].W=w}for(solverData={v:new VelcroPhysics.Dynamics.Solver.SolverData},solverData.v.Step=step.v.$clone(),solverData.v.Positions=this.Positions,solverData.v.Velocities=this.Velocities,this._contactSolver.Reset(step.v.$clone(),this.ContactCount,this._contacts,this.Positions,this.Velocities),this._contactSolver.InitializeVelocityConstraints(),VelcroPhysics.Settings.EnableWarmstarting&&this._contactSolver.WarmStart(),VelcroPhysics.Settings.EnableDiagnostics&&this._watch.start(),i1=0;i1<this.JointCount;i1=i1+1|0)this._joints[i1].Enabled&&this._joints[i1].InitVelocityConstraints(solverData);for(VelcroPhysics.Settings.EnableDiagnostics&&this._watch.stop(),i2=0;i2<VelcroPhysics.Settings.VelocityIterations;i2=i2+1|0){for(j=0;j<this.JointCount;j=j+1|0)(joint=this._joints[j],joint.Enabled)&&(VelcroPhysics.Settings.EnableDiagnostics&&this._watch.start(),joint.SolveVelocityConstraints(solverData),joint.Validate(step.v.inv_dt),VelcroPhysics.Settings.EnableDiagnostics&&this._watch.stop());this._contactSolver.SolveVelocityConstraints()}for(this._contactSolver.StoreImpulses(),i3=0;i3<this.BodyCount;i3=i3+1|0){var c1=this.Positions[i3].C.$clone(),a1=this.Positions[i3].A,v1=this.Velocities[i3].V.$clone(),w1=this.Velocities[i3].W,translation=Microsoft.Xna.Framework.Vector2.op_Multiply$2(h,v1.$clone());Microsoft.Xna.Framework.Vector2.Dot(translation.$clone(),translation.$clone())>VelcroPhysics.Settings.MaxTranslationSquared&&(ratio=VelcroPhysics.Settings.MaxTranslation/translation.Length(),v1=Microsoft.Xna.Framework.Vector2.op_Multiply$1(v1.$clone(),ratio));rotation=h*w1;rotation*rotation>VelcroPhysics.Settings.MaxRotationSquared&&(ratio1=VelcroPhysics.Settings.MaxRotation/Math.abs(rotation),w1*=ratio1);c1=Microsoft.Xna.Framework.Vector2.op_Addition(c1.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(h,v1.$clone()));a1+=h*w1;this.Positions[i3].C=c1.$clone();this.Positions[i3].A=a1;this.Velocities[i3].V=v1.$clone();this.Velocities[i3].W=w1}for(positionSolved=!1,i4=0;i4<VelcroPhysics.Settings.PositionIterations;i4=i4+1|0){for(contactsOkay=this._contactSolver.SolvePositionConstraints(),jointsOkay=!0,j1=0;j1<this.JointCount;j1=j1+1|0)(joint1=this._joints[j1],joint1.Enabled)&&(VelcroPhysics.Settings.EnableDiagnostics&&this._watch.start(),jointOkay=joint1.SolvePositionConstraints(solverData),VelcroPhysics.Settings.EnableDiagnostics&&this._watch.stop(),jointsOkay=jointsOkay&&jointOkay);if(contactsOkay&&jointsOkay){positionSolved=!0;break}}for(VelcroPhysics.Settings.EnableDiagnostics&&(this.JointUpdateTime=System.Int64.toNumber(this._watch.ticks()),this._watch.reset()),i5=0;i5<this.BodyCount;i5=i5+1|0)body=this.Bodies[i5],body._sweep.C=this.Positions[i5].C.$clone(),body._sweep.A=this.Positions[i5].A,body._linearVelocity=this.Velocities[i5].V.$clone(),body._angularVelocity=this.Velocities[i5].W,body.SynchronizeTransform();if(this.Report(this._contactSolver.VelocityConstraints),VelcroPhysics.Settings.AllowSleep){for(minSleepTime=VelcroPhysics.Settings.MaxFloat,i6=0;i6<this.BodyCount;i6=i6+1|0)(b1=this.Bodies[i6],b1.BodyType!==VelcroPhysics.Dynamics.BodyType.Static)&&(!b1.SleepingAllowed||b1._angularVelocity*b1._angularVelocity>VelcroPhysics.Dynamics.Solver.Island.AngTolSqr||Microsoft.Xna.Framework.Vector2.Dot(b1._linearVelocity.$clone(),b1._linearVelocity.$clone())>VelcroPhysics.Dynamics.Solver.Island.LinTolSqr?(b1.SleepTime=0,minSleepTime=0):(b1.SleepTime+=h,minSleepTime=Math.min(minSleepTime,b1.SleepTime)));if(minSleepTime>=VelcroPhysics.Settings.TimeToSleep&&positionSolved)for(i7=0;i7<this.BodyCount;i7=i7+1|0)b2=this.Bodies[i7],b2.Awake=!1}},SolveTOI:function(subStep,toiIndexA,toiIndexB){var i,b,i1,contactsOkay,i2,h,i3,ratio,rotation,ratio1,body;for(System.Diagnostics.Debug.Assert(toiIndexA<this.BodyCount),System.Diagnostics.Debug.Assert(toiIndexB<this.BodyCount),i=0;i<this.BodyCount;i=i+1|0)b=this.Bodies[i],this.Positions[i].C=b._sweep.C.$clone(),this.Positions[i].A=b._sweep.A,this.Velocities[i].V=b._linearVelocity.$clone(),this.Velocities[i].W=b._angularVelocity;for(this._contactSolver.Reset(subStep.v.$clone(),this.ContactCount,this._contacts,this.Positions,this.Velocities),i1=0;i1<VelcroPhysics.Settings.TOIPositionIterations;i1=i1+1|0)if(contactsOkay=this._contactSolver.SolveTOIPositionConstraints(toiIndexA,toiIndexB),contactsOkay)break;for(this.Bodies[toiIndexA]._sweep.C0=this.Positions[toiIndexA].C.$clone(),this.Bodies[toiIndexA]._sweep.A0=this.Positions[toiIndexA].A,this.Bodies[toiIndexB]._sweep.C0=this.Positions[toiIndexB].C.$clone(),this.Bodies[toiIndexB]._sweep.A0=this.Positions[toiIndexB].A,this._contactSolver.InitializeVelocityConstraints(),i2=0;i2<VelcroPhysics.Settings.TOIVelocityIterations;i2=i2+1|0)this._contactSolver.SolveVelocityConstraints();for(h=subStep.v.dt,i3=0;i3<this.BodyCount;i3=i3+1|0){var c=this.Positions[i3].C.$clone(),a=this.Positions[i3].A,v=this.Velocities[i3].V.$clone(),w=this.Velocities[i3].W,translation=Microsoft.Xna.Framework.Vector2.op_Multiply$2(h,v.$clone());Microsoft.Xna.Framework.Vector2.Dot(translation.$clone(),translation.$clone())>VelcroPhysics.Settings.MaxTranslationSquared&&(ratio=VelcroPhysics.Settings.MaxTranslation/translation.Length(),v=Microsoft.Xna.Framework.Vector2.op_Multiply$1(v.$clone(),ratio));rotation=h*w;rotation*rotation>VelcroPhysics.Settings.MaxRotationSquared&&(ratio1=VelcroPhysics.Settings.MaxRotation/Math.abs(rotation),w*=ratio1);c=Microsoft.Xna.Framework.Vector2.op_Addition(c.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(h,v.$clone()));a+=h*w;this.Positions[i3].C=c.$clone();this.Positions[i3].A=a;this.Velocities[i3].V=v.$clone();this.Velocities[i3].W=w;body=this.Bodies[i3];body._sweep.C=c.$clone();body._sweep.A=a;body._linearVelocity=v.$clone();body._angularVelocity=w;body.SynchronizeTransform()}this.Report(this._contactSolver.VelocityConstraints)},Add$1:function(body){System.Diagnostics.Debug.Assert(this.BodyCount<this.BodyCapacity);body.IslandIndex=this.BodyCount;this.Bodies[Bridge.identity(this.BodyCount,this.BodyCount=this.BodyCount+1|0)]=body},Add:function(contact){System.Diagnostics.Debug.Assert(this.ContactCount<this.ContactCapacity);this._contacts[Bridge.identity(this.ContactCount,this.ContactCount=this.ContactCount+1|0)]=contact},Add$2:function(joint){System.Diagnostics.Debug.Assert(this.JointCount<this.JointCapacity);this._joints[Bridge.identity(this.JointCount,this.JointCount=this.JointCount+1|0)]=joint},Report:function(constraints){var i,c;if(this._contactManager!=null)for(i=0;i<this.ContactCount;i=i+1|0)c={v:this._contacts[i]},Bridge.staticEquals(c.v.FixtureA.AfterCollision,null)?null:c.v.FixtureA.AfterCollision(c.v.FixtureA,c.v.FixtureB,c.v,constraints[i]),Bridge.staticEquals(c.v.FixtureB.AfterCollision,null)?null:c.v.FixtureB.AfterCollision(c.v.FixtureB,c.v.FixtureA,c.v,constraints[i]),Bridge.staticEquals(this._contactManager.PostSolve,null)?null:this._contactManager.PostSolve(c.v,constraints[i])}}});Bridge.define("VelcroPhysics.Dynamics.Solver.Position",{$kind:"struct",statics:{methods:{getDefaultValue:function(){return new VelcroPhysics.Dynamics.Solver.Position}}},fields:{C:null,A:0},ctors:{init:function(){this.C=new Microsoft.Xna.Framework.Vector2},ctor:function(){this.$initialize()}},methods:{getHashCode:function(){return Bridge.addHash([3621968068,this.C,this.A])},equals:function(o){return Bridge.is(o,VelcroPhysics.Dynamics.Solver.Position)?Bridge.equals(this.C,o.C)&&Bridge.equals(this.A,o.A):!1},$clone:function(to){var s=to||new VelcroPhysics.Dynamics.Solver.Position;return s.C=this.C.$clone(),s.A=this.A,s}}});Bridge.define("VelcroPhysics.Dynamics.Solver.PositionSolverManifold",{statics:{methods:{Initialize:function(pc,xfA,xfB,index,normal,point,separation){var pointA,pointB,planePoint,clipPoint,planePoint1,clipPoint1;xfA={v:xfA};xfB={v:xfB};System.Diagnostics.Debug.Assert(pc.PointCount>0);switch(pc.Type){case VelcroPhysics.Collision.Narrowphase.ManifoldType.Circles:pointA=VelcroPhysics.Utilities.MathUtils.Mul$4(xfA,pc.LocalPoint.$clone());pointB=VelcroPhysics.Utilities.MathUtils.Mul$4(xfB,pc.LocalPoints[0].$clone());normal.v=Microsoft.Xna.Framework.Vector2.op_Subtraction(pointB.$clone(),pointA.$clone());Microsoft.Xna.Framework.Vector2.op_Inequality(normal.v.$clone(),Microsoft.Xna.Framework.Vector2.Zero.$clone())&&normal.v.Normalize();point.v=Microsoft.Xna.Framework.Vector2.op_Multiply$2(.5,Microsoft.Xna.Framework.Vector2.op_Addition(pointA.$clone(),pointB.$clone()));separation.v=Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(pointB.$clone(),pointA.$clone()),normal.v.$clone())-pc.RadiusA-pc.RadiusB;break;case VelcroPhysics.Collision.Narrowphase.ManifoldType.FaceA:normal.v=VelcroPhysics.Utilities.MathUtils.Mul$2(xfA.v.q.$clone(),pc.LocalNormal.$clone());planePoint=VelcroPhysics.Utilities.MathUtils.Mul$4(xfA,pc.LocalPoint.$clone());clipPoint=VelcroPhysics.Utilities.MathUtils.Mul$4(xfB,pc.LocalPoints[index].$clone());separation.v=Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(clipPoint.$clone(),planePoint.$clone()),normal.v.$clone())-pc.RadiusA-pc.RadiusB;point.v=clipPoint.$clone();break;case VelcroPhysics.Collision.Narrowphase.ManifoldType.FaceB:normal.v=VelcroPhysics.Utilities.MathUtils.Mul$2(xfB.v.q.$clone(),pc.LocalNormal.$clone());planePoint1=VelcroPhysics.Utilities.MathUtils.Mul$4(xfB,pc.LocalPoint.$clone());clipPoint1=VelcroPhysics.Utilities.MathUtils.Mul$4(xfA,pc.LocalPoints[index].$clone());separation.v=Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(clipPoint1.$clone(),planePoint1.$clone()),normal.v.$clone())-pc.RadiusA-pc.RadiusB;point.v=clipPoint1.$clone();normal.v=Microsoft.Xna.Framework.Vector2.op_UnaryNegation(normal.v.$clone());break;default:normal.v=Microsoft.Xna.Framework.Vector2.Zero.$clone();point.v=Microsoft.Xna.Framework.Vector2.Zero.$clone();separation.v=0;break}}}}});Bridge.define("VelcroPhysics.Dynamics.Solver.SolverData",{$kind:"struct",statics:{methods:{getDefaultValue:function(){return new VelcroPhysics.Dynamics.Solver.SolverData}}},fields:{Step:null,Positions:null,Velocities:null},ctors:{init:function(){this.Step=new VelcroPhysics.Dynamics.TimeStep},ctor:function(){this.$initialize()}},methods:{getHashCode:function(){return Bridge.addHash([3618718508,this.Step,this.Positions,this.Velocities])},equals:function(o){return Bridge.is(o,VelcroPhysics.Dynamics.Solver.SolverData)?Bridge.equals(this.Step,o.Step)&&Bridge.equals(this.Positions,o.Positions)&&Bridge.equals(this.Velocities,o.Velocities):!1},$clone:function(to){var s=to||new VelcroPhysics.Dynamics.Solver.SolverData;return s.Step=this.Step.$clone(),s.Positions=this.Positions,s.Velocities=this.Velocities,s}}});Bridge.define("VelcroPhysics.Dynamics.Solver.Velocity",{$kind:"struct",statics:{methods:{getDefaultValue:function(){return new VelcroPhysics.Dynamics.Solver.Velocity}}},fields:{V:null,W:0},ctors:{init:function(){this.V=new Microsoft.Xna.Framework.Vector2},ctor:function(){this.$initialize()}},methods:{getHashCode:function(){return Bridge.addHash([3907047097,this.V,this.W])},equals:function(o){return Bridge.is(o,VelcroPhysics.Dynamics.Solver.Velocity)?Bridge.equals(this.V,o.V)&&Bridge.equals(this.W,o.W):!1},$clone:function(to){var s=to||new VelcroPhysics.Dynamics.Solver.Velocity;return s.V=this.V.$clone(),s.W=this.W,s}}});Bridge.define("VelcroPhysics.Dynamics.Solver.VelocityConstraintPoint",{fields:{NormalImpulse:0,NormalMass:0,rA:null,rB:null,TangentImpulse:0,TangentMass:0,VelocityBias:0},ctors:{init:function(){this.rA=new Microsoft.Xna.Framework.Vector2;this.rB=new Microsoft.Xna.Framework.Vector2}}});Bridge.define("VelcroPhysics.Dynamics.TimeStep",{$kind:"struct",statics:{methods:{getDefaultValue:function(){return new VelcroPhysics.Dynamics.TimeStep}}},fields:{dt:0,dtRatio:0,inv_dt:0},ctors:{ctor:function(){this.$initialize()}},methods:{getHashCode:function(){return Bridge.addHash([3587366311,this.dt,this.dtRatio,this.inv_dt])},equals:function(o){return Bridge.is(o,VelcroPhysics.Dynamics.TimeStep)?Bridge.equals(this.dt,o.dt)&&Bridge.equals(this.dtRatio,o.dtRatio)&&Bridge.equals(this.inv_dt,o.inv_dt):!1},$clone:function(to){var s=to||new VelcroPhysics.Dynamics.TimeStep;return s.dt=this.dt,s.dtRatio=this.dtRatio,s.inv_dt=this.inv_dt,s}}});Bridge.define("VelcroPhysics.Dynamics.World",{fields:{_invDt0:0,_stack:null,_stepComplete:!1,_bodyAddList:null,_bodyRemoveList:null,_jointAddList:null,_jointRemoveList:null,_queryAABBCallback:null,_queryAABBCallbackWrapper:null,_myFixture:null,_point1:null,_point2:null,_testPointAllFixtures:null,_watch:null,_rayCastCallback:null,_rayCastCallbackWrapper:null,_contactPool:null,_worldHasNewFixture:!1,_bodyIdCounter:0,_fixtureIdCounter:0,BodyAdded:null,BodyRemoved:null,FixtureAdded:null,FixtureRemoved:null,JointAdded:null,JointRemoved:null,ControllerAdded:null,ControllerRemoved:null,ControllerList:null,BreakableBodyList:null,UpdateTime:0,ContinuousPhysicsTime:0,ControllersUpdateTime:0,AddRemoveTime:0,NewContactsTime:0,ContactsUpdateTime:0,SolveUpdateTime:0,Gravity:null,ContactManager:null,BodyList:null,JointList:null,Enabled:!1,Island:null},props:{ProxyCount:{get:function(){return this.ContactManager.BroadPhase.VelcroPhysics$Collision$Broadphase$IBroadPhase$ProxyCount}},ContactList:{get:function(){return this.ContactManager.ContactList}}},ctors:{init:function(){this._point1=new Microsoft.Xna.Framework.Vector2;this._point2=new Microsoft.Xna.Framework.Vector2;this.Gravity=new Microsoft.Xna.Framework.Vector2;this._stack=System.Array.init(64,null,VelcroPhysics.Dynamics.Body);this._bodyAddList=new(System.Collections.Generic.HashSet$1(VelcroPhysics.Dynamics.Body).ctor);this._bodyRemoveList=new(System.Collections.Generic.HashSet$1(VelcroPhysics.Dynamics.Body).ctor);this._jointAddList=new(System.Collections.Generic.HashSet$1(VelcroPhysics.Dynamics.Joints.Joint).ctor);this._jointRemoveList=new(System.Collections.Generic.HashSet$1(VelcroPhysics.Dynamics.Joints.Joint).ctor);this._watch=new System.Diagnostics.Stopwatch;this._contactPool=new(System.Collections.Generic.Queue$1(VelcroPhysics.Collision.ContactSystem.Contact).$ctor2)(256)},ctor:function(gravity){this.$initialize();this.Island=new VelcroPhysics.Dynamics.Solver.Island;this.Enabled=!0;this.ControllerList=new(System.Collections.Generic.List$1(VelcroPhysics.Extensions.Controllers.ControllerBase.Controller).ctor);this.BreakableBodyList=new(System.Collections.Generic.List$1(VelcroPhysics.Dynamics.BreakableBody).ctor);this.BodyList=new(System.Collections.Generic.List$1(VelcroPhysics.Dynamics.Body).$ctor2)(32);this.JointList=new(System.Collections.Generic.List$1(VelcroPhysics.Dynamics.Joints.Joint).$ctor2)(32);this._queryAABBCallbackWrapper=Bridge.fn.cacheBind(this,this.QueryAABBCallbackWrapper);this._rayCastCallbackWrapper=Bridge.fn.cacheBind(this,this.RayCastCallbackWrapper);this.ContactManager=new VelcroPhysics.Collision.ContactSystem.ContactManager(new VelcroPhysics.Collision.Broadphase.DynamicTreeBroadPhase);this.Gravity=gravity.$clone()}},methods:{ProcessRemovedJoints:function(){var $t,joint,collideConnected,bodyA,bodyB,edge;if(this._jointRemoveList.Count>0){$t=Bridge.getEnumerator(this._jointRemoveList);try{while($t.moveNext()){if(joint={v:$t.Current},collideConnected=joint.v.CollideConnected,this.JointList.remove(joint.v),bodyA=joint.v.BodyA,bodyB=joint.v.BodyB,bodyA.Awake=!0,joint.v.IsFixedType()||(bodyB.Awake=!0),joint.v.EdgeA.Prev!=null&&(joint.v.EdgeA.Prev.Next=joint.v.EdgeA.Next),joint.v.EdgeA.Next!=null&&(joint.v.EdgeA.Next.Prev=joint.v.EdgeA.Prev),Bridge.referenceEquals(joint.v.EdgeA,bodyA.JointList)&&(bodyA.JointList=joint.v.EdgeA.Next),joint.v.EdgeA.Prev=null,joint.v.EdgeA.Next=null,!joint.v.IsFixedType()&&(joint.v.EdgeB.Prev!=null&&(joint.v.EdgeB.Prev.Next=joint.v.EdgeB.Next),joint.v.EdgeB.Next!=null&&(joint.v.EdgeB.Next.Prev=joint.v.EdgeB.Prev),Bridge.referenceEquals(joint.v.EdgeB,bodyB.JointList)&&(bodyB.JointList=joint.v.EdgeB.Next),joint.v.EdgeB.Prev=null,joint.v.EdgeB.Next=null,collideConnected===!1))for(edge=bodyB.ContactList;edge!=null;)Bridge.referenceEquals(edge.Other,bodyA)&&(edge.Contact._flags|=VelcroPhysics.Collision.ContactSystem.ContactFlags.FilterFlag&255),edge=edge.Next;Bridge.staticEquals(this.JointRemoved,null)?null:this.JointRemoved(joint.v)}}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}this._jointRemoveList.clear()}},ProcessAddedJoints:function(){var $t,joint,bodyA,bodyB,edge;if(this._jointAddList.Count>0){$t=Bridge.getEnumerator(this._jointAddList);try{while($t.moveNext()){if(joint={v:$t.Current},this.JointList.add(joint.v),joint.v.EdgeA.Joint=joint.v,joint.v.EdgeA.Other=joint.v.BodyB,joint.v.EdgeA.Prev=null,joint.v.EdgeA.Next=joint.v.BodyA.JointList,joint.v.BodyA.JointList!=null&&(joint.v.BodyA.JointList.Prev=joint.v.EdgeA),joint.v.BodyA.JointList=joint.v.EdgeA,!joint.v.IsFixedType()&&(joint.v.EdgeB.Joint=joint.v,joint.v.EdgeB.Other=joint.v.BodyA,joint.v.EdgeB.Prev=null,joint.v.EdgeB.Next=joint.v.BodyB.JointList,joint.v.BodyB.JointList!=null&&(joint.v.BodyB.JointList.Prev=joint.v.EdgeB),joint.v.BodyB.JointList=joint.v.EdgeB,bodyA=joint.v.BodyA,bodyB=joint.v.BodyB,joint.v.CollideConnected===!1))for(edge=bodyB.ContactList;edge!=null;)Bridge.referenceEquals(edge.Other,bodyA)&&(edge.Contact._flags|=VelcroPhysics.Collision.ContactSystem.ContactFlags.FilterFlag&255),edge=edge.Next;Bridge.staticEquals(this.JointAdded,null)?null:this.JointAdded(joint.v)}}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}this._jointAddList.clear()}},ProcessAddedBodies:function(){var $t,body;if(this._bodyAddList.Count>0){$t=Bridge.getEnumerator(this._bodyAddList);try{while($t.moveNext())body={v:$t.Current},this.BodyList.add(body.v),Bridge.staticEquals(this.BodyAdded,null)?null:this.BodyAdded(body.v)}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}this._bodyAddList.clear()}},ProcessRemovedBodies:function(){var $t,body,je,je0,ce,ce0,i;if(this._bodyRemoveList.Count>0){$t=Bridge.getEnumerator(this._bodyRemoveList);try{while($t.moveNext()){for(body={v:$t.Current},System.Diagnostics.Debug.Assert(this.BodyList.Count>0),System.Diagnostics.Debug.Assert(this.BodyList.contains(body.v)),je=body.v.JointList;je!=null;)je0=je,je=je.Next,this.RemoveJoint$1(je0.Joint,!1);for(body.v.JointList=null,ce=body.v.ContactList;ce!=null;)ce0=ce,ce=ce.Next,this.ContactManager.Destroy(ce0.Contact);for(body.v.ContactList=null,i=0;i<body.v.FixtureList.Count;i=i+1|0)body.v.FixtureList.getItem(i).DestroyProxies(this.ContactManager.BroadPhase),body.v.FixtureList.getItem(i).Destroy();body.v.FixtureList=null;this.BodyList.remove(body.v);Bridge.staticEquals(this.BodyRemoved,null)?null:this.BodyRemoved(body.v)}}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}this._bodyRemoveList.clear()}},QueryAABBCallbackWrapper:function(proxyId){var proxy=this.ContactManager.BroadPhase.VelcroPhysics$Collision$Broadphase$IBroadPhase$GetProxy(proxyId);return this._queryAABBCallback(proxy.Fixture)},RayCastCallbackWrapper:function(rayCastInput,proxyId){var fraction,point;rayCastInput={v:rayCastInput};var proxy=this.ContactManager.BroadPhase.VelcroPhysics$Collision$Broadphase$IBroadPhase$GetProxy(proxyId),fixture=proxy.Fixture,index=proxy.ChildIndex,output={v:new VelcroPhysics.Collision.RayCast.RayCastOutput},hit=fixture.RayCast(output,rayCastInput,index);return hit?(fraction=output.v.Fraction,point=Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(1-fraction,rayCastInput.v.Point1.$clone()),Microsoft.Xna.Framework.Vector2.op_Multiply$2(fraction,rayCastInput.v.Point2.$clone())),this._rayCastCallback(fixture,point.$clone(),output.v.Normal.$clone(),fraction)):rayCastInput.v.MaxFraction},Solve:function(step){var $t,$t1,$t2,$t3,$t4,b,c,j,stackSize,index,seed,stackCount,b1,ce,contact,sensorA,sensorB,other,je,other1,i,b2,b3;this.Island.Reset(this.BodyList.Count,this.ContactManager.ContactList.Count,this.JointList.Count,this.ContactManager);$t=Bridge.getEnumerator(this.BodyList);try{while($t.moveNext())b=$t.Current,b._flags&=254}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}$t1=Bridge.getEnumerator(this.ContactManager.ContactList);try{while($t1.moveNext())c=$t1.Current,c._flags&=254}finally{Bridge.is($t1,System.IDisposable)&&$t1.System$IDisposable$Dispose()}$t2=Bridge.getEnumerator(this.JointList);try{while($t2.moveNext())j=$t2.Current,j.IslandFlag=!1}finally{Bridge.is($t2,System.IDisposable)&&$t2.System$IDisposable$Dispose()}for(stackSize=this.BodyList.Count,stackSize>this._stack.length&&(this._stack=System.Array.init(Math.max(Bridge.Int.mul(this._stack.length,2),stackSize),null,VelcroPhysics.Dynamics.Body)),index=this.BodyList.Count-1|0;index>=0;index=index-1|0)if((seed=this.BodyList.getItem(index),(seed._flags&VelcroPhysics.Dynamics.BodyFlags.IslandFlag&255)!==VelcroPhysics.Dynamics.BodyFlags.IslandFlag)&&seed.Awake!==!1&&seed.Enabled!==!1&&seed.BodyType!==VelcroPhysics.Dynamics.BodyType.Static){for(this.Island.Clear(),stackCount=0,this._stack[Bridge.identity(stackCount,stackCount=stackCount+1|0)]=seed,seed._flags|=VelcroPhysics.Dynamics.BodyFlags.IslandFlag&255;stackCount>0;)if(b1=this._stack[stackCount=stackCount-1|0],System.Diagnostics.Debug.Assert(b1.Enabled),this.Island.Add$1(b1),b1._flags|=VelcroPhysics.Dynamics.BodyFlags.AwakeFlag&255,b1.BodyType!==VelcroPhysics.Dynamics.BodyType.Static){for(ce=b1.ContactList;ce!=null;ce=ce.Next)(contact=ce.Contact,contact.IslandFlag)||ce.Contact.Enabled!==!1&&ce.Contact.IsTouching!==!1&&((sensorA=contact.FixtureA.IsSensor,sensorB=contact.FixtureB.IsSensor,sensorA||sensorB)||(this.Island.Add(contact),contact._flags|=VelcroPhysics.Collision.ContactSystem.ContactFlags.IslandFlag&255,other=ce.Other,other.IsIsland)||(System.Diagnostics.Debug.Assert(stackCount<stackSize),this._stack[Bridge.identity(stackCount,stackCount=stackCount+1|0)]=other,other._flags|=VelcroPhysics.Dynamics.BodyFlags.IslandFlag&255));for(je=b1.JointList;je!=null;je=je.Next)if(!je.Joint.IslandFlag)if(other1=je.Other,other1!=null){if(other1.Enabled===!1)continue;if(this.Island.Add$2(je.Joint),je.Joint.IslandFlag=!0,other1.IsIsland)continue;System.Diagnostics.Debug.Assert(stackCount<stackSize);this._stack[Bridge.identity(stackCount,stackCount=stackCount+1|0)]=other1;other1._flags|=VelcroPhysics.Dynamics.BodyFlags.IslandFlag&255}else this.Island.Add$2(je.Joint),je.Joint.IslandFlag=!0}for(this.Island.Solve(step,Bridge.ref(this,"Gravity")),i=0;i<this.Island.BodyCount;i=i+1|0)b2=($t3=this.Island.Bodies)[i],b2.BodyType===VelcroPhysics.Dynamics.BodyType.Static&&(b2._flags&=254)}$t4=Bridge.getEnumerator(this.BodyList);try{while($t4.moveNext())(b3=$t4.Current,b3.IsIsland)&&b3.BodyType!==VelcroPhysics.Dynamics.BodyType.Static&&b3.SynchronizeFixtures()}finally{Bridge.is($t4,System.IDisposable)&&$t4.System$IDisposable$Dispose()}this.ContactManager.FindNewContacts()},SolveTOI:function(step){var $t,i,i1,c,minContact,minAlpha,i2,c1,alpha,fA,fB,activeA,activeB,collideA,collideB,alpha0,input,output,beta,bodies,i3,body,ce,contact,other,backup,subStep,i4,body1,ce1;if(this.Island.Reset(64,VelcroPhysics.Settings.MaxTOIContacts,0,this.ContactManager),this._stepComplete){for(i=0;i<this.BodyList.Count;i=i+1|0)this.BodyList.getItem(i)._flags&=254,this.BodyList.getItem(i)._sweep.Alpha0=0;for(i1=0;i1<this.ContactManager.ContactList.Count;i1=i1+1|0)c=this.ContactManager.ContactList.getItem(i1),c._flags&=254,c._flags&=223,c._toiCount=0,c._toi=1}for(;;){for(minContact=null,minAlpha=1,i2=0;i2<this.ContactManager.ContactList.Count;i2=i2+1|0)if((c1=this.ContactManager.ContactList.getItem(i2),c1.Enabled!==!1)&&!(c1._toiCount>VelcroPhysics.Settings.MaxSubSteps)){if(c1.TOIFlag)alpha=c1._toi;else{if(fA=c1.FixtureA,fB=c1.FixtureB,fA.IsSensor||fB.IsSensor)continue;var bA=fA.Body,bB=fB.Body,typeA=bA.BodyType,typeB=bB.BodyType;if(System.Diagnostics.Debug.Assert(typeA===VelcroPhysics.Dynamics.BodyType.Dynamic||typeB===VelcroPhysics.Dynamics.BodyType.Dynamic),activeA=bA.Awake&&typeA!==VelcroPhysics.Dynamics.BodyType.Static,activeB=bB.Awake&&typeB!==VelcroPhysics.Dynamics.BodyType.Static,activeA===!1&&activeB===!1)continue;if(collideA=(bA.IsBullet||typeA!==VelcroPhysics.Dynamics.BodyType.Dynamic)&&(fA.IgnoreCCDWith&fB.CollisionCategories)==0&&!bA.IgnoreCCD,collideB=(bB.IsBullet||typeB!==VelcroPhysics.Dynamics.BodyType.Dynamic)&&(fB.IgnoreCCDWith&fA.CollisionCategories)==0&&!bB.IgnoreCCD,collideA===!1&&collideB===!1)continue;alpha0=bA._sweep.Alpha0;bA._sweep.Alpha0<bB._sweep.Alpha0?(alpha0=bB._sweep.Alpha0,bA._sweep.Advance(alpha0)):bB._sweep.Alpha0<bA._sweep.Alpha0&&(alpha0=bA._sweep.Alpha0,bB._sweep.Advance(alpha0));System.Diagnostics.Debug.Assert(alpha0<1);input={v:new VelcroPhysics.Collision.TOI.TOIInput};input.v.ProxyA=new VelcroPhysics.Collision.Distance.DistanceProxy.$ctor1(fA.Shape,c1.ChildIndexA);input.v.ProxyB=new VelcroPhysics.Collision.Distance.DistanceProxy.$ctor1(fB.Shape,c1.ChildIndexB);input.v.SweepA=bA._sweep.$clone();input.v.SweepB=bB._sweep.$clone();input.v.TMax=1;output={v:new VelcroPhysics.Collision.TOI.TOIOutput};VelcroPhysics.Collision.TOI.TimeOfImpact.CalculateTimeOfImpact(input,output);beta=output.v.T;alpha=output.v.State===VelcroPhysics.Collision.TOI.TOIOutputState.Touching?Math.min(alpha0+(1-alpha0)*beta,1):1;c1._toi=alpha;c1._flags&=223}alpha<minAlpha&&(minContact=c1,minAlpha=alpha)}if(minContact==null||.9999988<minAlpha){this._stepComplete=!0;break}var fA1=minContact.FixtureA,fB1=minContact.FixtureB,bA0=fA1.Body,bB0=fB1.Body,backup1=bA0._sweep.$clone(),backup2=bB0._sweep.$clone();if(bA0.Advance(minAlpha),bB0.Advance(minAlpha),minContact.Update(this.ContactManager),minContact._flags&=223,minContact._toiCount=minContact._toiCount+1|0,minContact.Enabled===!1||minContact.IsTouching===!1){minContact._flags&=251;bA0._sweep=backup1.$clone();bB0._sweep=backup2.$clone();bA0.SynchronizeTransform();bB0.SynchronizeTransform();continue}for(bA0.Awake=!0,bB0.Awake=!0,this.Island.Clear(),this.Island.Add$1(bA0),this.Island.Add$1(bB0),this.Island.Add(minContact),bA0._flags|=VelcroPhysics.Dynamics.BodyFlags.IslandFlag&255,bB0._flags|=VelcroPhysics.Dynamics.BodyFlags.IslandFlag&255,minContact._flags&=254,bodies=System.Array.init([bA0,bB0],VelcroPhysics.Dynamics.Body),i3=0;i3<2;i3=i3+1|0)if(body=bodies[i3],body.BodyType===VelcroPhysics.Dynamics.BodyType.Dynamic)for(ce=body.ContactList;ce!=null;ce=ce.Next){if(contact=ce.Contact,this.Island.BodyCount===this.Island.BodyCapacity)break;if(this.Island.ContactCount===this.Island.ContactCapacity)break;if(!contact.IslandFlag&&(other=ce.Other,other.BodyType!==VelcroPhysics.Dynamics.BodyType.Dynamic||body.IsBullet!==!1||other.IsBullet!==!1)&&!contact.FixtureA.IsSensor&&!contact.FixtureB.IsSensor){if(backup=other._sweep.$clone(),other.IsIsland||other.Advance(minAlpha),contact.Update(this.ContactManager),contact.Enabled===!1){other._sweep=backup.$clone();other.SynchronizeTransform();continue}if(contact.IsTouching===!1){other._sweep=backup.$clone();other.SynchronizeTransform();continue}(minContact._flags|=VelcroPhysics.Collision.ContactSystem.ContactFlags.IslandFlag&255,this.Island.Add(contact),other.IsIsland)||(other._flags|=VelcroPhysics.Dynamics.BodyFlags.IslandFlag&255,other.BodyType!==VelcroPhysics.Dynamics.BodyType.Static&&(other.Awake=!0),this.Island.Add$1(other))}}for(subStep={v:new VelcroPhysics.Dynamics.TimeStep},subStep.v.dt=(1-minAlpha)*step.v.dt,subStep.v.inv_dt=1/subStep.v.dt,subStep.v.dtRatio=1,this.Island.SolveTOI(subStep,bA0.IslandIndex,bB0.IslandIndex),i4=0;i4<this.Island.BodyCount;i4=i4+1|0)if(body1=($t=this.Island.Bodies)[i4],body1._flags&=254,body1.BodyType===VelcroPhysics.Dynamics.BodyType.Dynamic)for(body1.SynchronizeFixtures(),ce1=body1.ContactList;ce1!=null;ce1=ce1.Next)ce1.Contact._flags&=223,ce1.Contact._flags&=254;if(this.ContactManager.FindNewContacts(),VelcroPhysics.Settings.EnableSubStepping){this._stepComplete=!1;break}}},AddBody:function(body){System.Diagnostics.Debug.Assert$1(!this._bodyAddList.contains(body),"You are adding the same body more than once.");this._bodyAddList.contains(body)||this._bodyAddList.add(body)},RemoveBody:function(body){System.Diagnostics.Debug.Assert$1(!this._bodyRemoveList.contains(body),"The body is already marked for removal. You are removing the body more than once.");this._bodyRemoveList.contains(body)||this._bodyRemoveList.add(body)},AddJoint:function(joint){System.Diagnostics.Debug.Assert$1(!this._jointAddList.contains(joint),"You are adding the same joint more than once.");this._jointAddList.contains(joint)||this._jointAddList.add(joint)},RemoveJoint$1:function(joint,doCheck){doCheck&&System.Diagnostics.Debug.Assert$1(!this._jointRemoveList.contains(joint),"The joint is already marked for removal. You are removing the joint more than once.");this._jointRemoveList.contains(joint)||this._jointRemoveList.add(joint)},RemoveJoint:function(joint){this.RemoveJoint$1(joint,!0)},ProcessChanges:function(){this.ProcessAddedBodies();this.ProcessAddedJoints();this.ProcessRemovedBodies();this.ProcessRemovedJoints()},Step:function(dt){var step,i,i1;if(this.Enabled){for(VelcroPhysics.Settings.EnableDiagnostics&&this._watch.start(),this.ProcessChanges(),VelcroPhysics.Settings.EnableDiagnostics&&(this.AddRemoveTime=System.Int64.toNumber(this._watch.ticks())),this._worldHasNewFixture&&(this.ContactManager.FindNewContacts(),this._worldHasNewFixture=!1),VelcroPhysics.Settings.EnableDiagnostics&&(this.NewContactsTime=System.Int64.toNumber(this._watch.ticks())-this.AddRemoveTime),step={v:new VelcroPhysics.Dynamics.TimeStep},step.v.inv_dt=dt>0?1/dt:0,step.v.dt=dt,step.v.dtRatio=this._invDt0*dt,i=0;i<this.ControllerList.Count;i=i+1|0)this.ControllerList.getItem(i).Update(dt);for(VelcroPhysics.Settings.EnableDiagnostics&&(this.ControllersUpdateTime=System.Int64.toNumber(this._watch.ticks())-(this.AddRemoveTime+this.NewContactsTime)),this.ContactManager.Collide(),VelcroPhysics.Settings.EnableDiagnostics&&(this.ContactsUpdateTime=System.Int64.toNumber(this._watch.ticks())-(this.AddRemoveTime+this.NewContactsTime+this.ControllersUpdateTime)),this.Solve(step),VelcroPhysics.Settings.EnableDiagnostics&&(this.SolveUpdateTime=System.Int64.toNumber(this._watch.ticks())-(this.AddRemoveTime+this.NewContactsTime+this.ControllersUpdateTime+this.ContactsUpdateTime)),VelcroPhysics.Settings.ContinuousPhysics&&this.SolveTOI(step),VelcroPhysics.Settings.EnableDiagnostics&&(this.ContinuousPhysicsTime=System.Int64.toNumber(this._watch.ticks())-(this.AddRemoveTime+this.NewContactsTime+this.ControllersUpdateTime+this.ContactsUpdateTime+this.SolveUpdateTime)),VelcroPhysics.Settings.AutoClearForces&&this.ClearForces(),i1=0;i1<this.BreakableBodyList.Count;i1=i1+1|0)this.BreakableBodyList.getItem(i1).Update();this._invDt0=step.v.inv_dt;VelcroPhysics.Settings.EnableDiagnostics&&(this._watch.stop(),this.UpdateTime=System.Int64.toNumber(this._watch.ticks()),this._watch.reset())}},ClearForces:function(){for(var body,i=0;i<this.BodyList.Count;i=i+1|0)body=this.BodyList.getItem(i),body._force=Microsoft.Xna.Framework.Vector2.Zero.$clone(),body._torque=0},QueryAABB$1:function(callback,aabb){this._queryAABBCallback=callback;this.ContactManager.BroadPhase.VelcroPhysics$Collision$Broadphase$IBroadPhase$Query(this._queryAABBCallbackWrapper,aabb);this._queryAABBCallback=null},QueryAABB:function(aabb){var affected=new(System.Collections.Generic.List$1(VelcroPhysics.Dynamics.Fixture).ctor);return this.QueryAABB$1(function(fixture){return affected.add(fixture),!0},aabb),affected},RayCast$1:function(callback,point1,point2){var input={v:new VelcroPhysics.Collision.RayCast.RayCastInput};input.v.MaxFraction=1;input.v.Point1=point1.$clone();input.v.Point2=point2.$clone();this._rayCastCallback=callback;this.ContactManager.BroadPhase.VelcroPhysics$Collision$Broadphase$IBroadPhase$RayCast(this._rayCastCallbackWrapper,input);this._rayCastCallback=null},RayCast:function(point1,point2){var affected=new(System.Collections.Generic.List$1(VelcroPhysics.Dynamics.Fixture).ctor);return this.RayCast$1(function(f,p,n,fr){return affected.add(f),1},point1.$clone(),point2.$clone()),affected},AddController:function(controller){System.Diagnostics.Debug.Assert$1(!this.ControllerList.contains(controller),"You are adding the same controller more than once.");controller.World=this;this.ControllerList.add(controller);Bridge.staticEquals(this.ControllerAdded,null)?null:this.ControllerAdded(controller)},RemoveController:function(controller){System.Diagnostics.Debug.Assert$1(this.ControllerList.contains(controller),"You are removing a controller that is not in the simulation.");this.ControllerList.contains(controller)&&(this.ControllerList.remove(controller),Bridge.staticEquals(this.ControllerRemoved,null)?null:this.ControllerRemoved(controller))},AddBreakableBody:function(breakableBody){this.BreakableBodyList.add(breakableBody)},RemoveBreakableBody:function(breakableBody){System.Diagnostics.Debug.Assert(this.BreakableBodyList.contains(breakableBody));this.BreakableBodyList.remove(breakableBody)},TestPoint:function(point){var aabb={v:new VelcroPhysics.Shared.AABB},d=new Microsoft.Xna.Framework.Vector2.$ctor2(VelcroPhysics.Settings.Epsilon,VelcroPhysics.Settings.Epsilon);return aabb.v.LowerBound=Microsoft.Xna.Framework.Vector2.op_Subtraction(point.$clone(),d.$clone()),aabb.v.UpperBound=Microsoft.Xna.Framework.Vector2.op_Addition(point.$clone(),d.$clone()),this._myFixture=null,this._point1=point.$clone(),this.QueryAABB$1(Bridge.fn.cacheBind(this,this.TestPointCallback),aabb),this._myFixture},TestPointCallback:function(fixture){var inside=fixture.TestPoint(Bridge.ref(this,"_point1"));return inside?(this._myFixture=fixture,!1):!0},TestPointAll:function(point){var aabb={v:new VelcroPhysics.Shared.AABB},d=new Microsoft.Xna.Framework.Vector2.$ctor2(VelcroPhysics.Settings.Epsilon,VelcroPhysics.Settings.Epsilon);return aabb.v.LowerBound=Microsoft.Xna.Framework.Vector2.op_Subtraction(point.$clone(),d.$clone()),aabb.v.UpperBound=Microsoft.Xna.Framework.Vector2.op_Addition(point.$clone(),d.$clone()),this._point2=point.$clone(),this._testPointAllFixtures=new(System.Collections.Generic.List$1(VelcroPhysics.Dynamics.Fixture).ctor),this.QueryAABB$1(Bridge.fn.cacheBind(this,this.TestPointAllCallback),aabb),this._testPointAllFixtures},TestPointAllCallback:function(fixture){var inside=fixture.TestPoint(Bridge.ref(this,"_point2"));return inside&&this._testPointAllFixtures.add(fixture),!0},ShiftOrigin:function(newOrigin){var $t,$t1,b,joint;$t=Bridge.getEnumerator(this.BodyList);try{while($t.moveNext())b=$t.Current,b._xf.p=Microsoft.Xna.Framework.Vector2.op_Subtraction(b._xf.p.$clone(),newOrigin.$clone()),b._sweep.C0=Microsoft.Xna.Framework.Vector2.op_Subtraction(b._sweep.C0.$clone(),newOrigin.$clone()),b._sweep.C=Microsoft.Xna.Framework.Vector2.op_Subtraction(b._sweep.C.$clone(),newOrigin.$clone())}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}$t1=Bridge.getEnumerator(this.JointList);try{while($t1.moveNext())joint=$t1.Current}finally{Bridge.is($t1,System.IDisposable)&&$t1.System$IDisposable$Dispose()}this.ContactManager.BroadPhase.VelcroPhysics$Collision$Broadphase$IBroadPhase$ShiftOrigin(newOrigin.$clone())},Clear:function(){var i,i1,i2;for(this.ProcessChanges(),i=this.BodyList.Count-1|0;i>=0;i=i-1|0)this.RemoveBody(this.BodyList.getItem(i));for(i1=this.ControllerList.Count-1|0;i1>=0;i1=i1-1|0)this.RemoveController(this.ControllerList.getItem(i1));for(i2=this.BreakableBodyList.Count-1|0;i2>=0;i2=i2-1|0)this.RemoveBreakableBody(this.BreakableBodyList.getItem(i2));this.ProcessChanges()},CreateBody:function(template){var b=new VelcroPhysics.Dynamics.Body(this,template);return b.BodyId=Bridge.identity(this._bodyIdCounter,this._bodyIdCounter=this._bodyIdCounter+1|0),this.AddBody(b),b}}});Bridge.define("VelcroPhysics.Extensions.PhysicsLogics.PhysicsLogicBase.FilterData",{fields:{DisabledOnCategories:0,DisabledOnGroup:0,EnabledOnCategories:0,EnabledOnGroup:0},ctors:{init:function(){this.DisabledOnCategories=VelcroPhysics.Collision.Filtering.Category.None;this.EnabledOnCategories=VelcroPhysics.Collision.Filtering.Category.All}},methods:{IsActiveOn:function(body){var $t,fixture;if(body==null||!body.Enabled||body.IsStatic||body.FixtureList==null)return!1;$t=Bridge.getEnumerator(body.FixtureList);try{while($t.moveNext()){if((fixture=$t.Current,fixture.CollisionGroup===this.DisabledOnGroup&&fixture.CollisionGroup!==0&&this.DisabledOnGroup!==0)||(fixture.CollisionCategories&this.DisabledOnCategories)!==VelcroPhysics.Collision.Filtering.Category.None)return!1;if(this.EnabledOnGroup!==0||this.EnabledOnCategories!==VelcroPhysics.Collision.Filtering.Category.All){if(fixture.CollisionGroup===this.EnabledOnGroup&&fixture.CollisionGroup!==0&&this.EnabledOnGroup!==0||(fixture.CollisionCategories&this.EnabledOnCategories)!==VelcroPhysics.Collision.Filtering.Category.None&&this.EnabledOnCategories!==VelcroPhysics.Collision.Filtering.Category.All)return!0}else return!0}}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}return!1},AddDisabledCategory:function(category){this.DisabledOnCategories|=category},RemoveDisabledCategory:function(category){this.DisabledOnCategories&=~category},IsInDisabledCategory:function(category){return(this.DisabledOnCategories&category)===category},AddEnabledCategory:function(category){this.EnabledOnCategories|=category},RemoveEnabledCategory:function(category){this.EnabledOnCategories&=~category},IsInEnabledInCategory:function(category){return(this.EnabledOnCategories&category)===category}}});Bridge.define("VelcroPhysics.Extensions.Controllers.ControllerBase.ControllerFilter",{$kind:"struct",statics:{methods:{getDefaultValue:function(){return new VelcroPhysics.Extensions.Controllers.ControllerBase.ControllerFilter}}},fields:{ControllerFlags:0},ctors:{ctor:function(){this.$initialize()}},methods:{IgnoreController:function(controller){this.ControllerFlags|=controller},RestoreController:function(controller){this.ControllerFlags&=~controller},IsControllerIgnored:function(controller){return(this.ControllerFlags&controller)===controller},getHashCode:function(){return Bridge.addHash([7457916294,this.ControllerFlags])},equals:function(o){return Bridge.is(o,VelcroPhysics.Extensions.Controllers.ControllerBase.ControllerFilter)?Bridge.equals(this.ControllerFlags,o.ControllerFlags):!1},$clone:function(to){var s=to||new VelcroPhysics.Extensions.Controllers.ControllerBase.ControllerFilter;return s.ControllerFlags=this.ControllerFlags,s}}});Bridge.define("VelcroPhysics.Extensions.Controllers.ControllerBase.ControllerType",{$kind:"enum",statics:{fields:{GravityController:1,VelocityLimitController:2,AbstractForceController:4,BuoyancyController:8}},$flags:!0});Bridge.define("VelcroPhysics.Extensions.Controllers.Gravity.GravityType",{$kind:"enum",statics:{fields:{Linear:0,DistanceSquared:1}}});Bridge.define("VelcroPhysics.Extensions.Controllers.Wind.AbstractForceController.DecayModes",{$kind:"nested enum",statics:{fields:{None:0,Step:1,Linear:2,InverseSquare:3,Curve:4}}});Bridge.define("VelcroPhysics.Extensions.Controllers.Wind.AbstractForceController.ForceTypes",{$kind:"nested enum",statics:{fields:{Point:0,Line:1,Area:2}}});Bridge.define("VelcroPhysics.Extensions.Controllers.Wind.AbstractForceController.TimingModes",{$kind:"nested enum",statics:{fields:{Switched:0,Triggered:1,Curve:2}}});Bridge.define("VelcroPhysics.Extensions.DebugView.DebugViewBase",{fields:{World:null,Flags:0},ctors:{ctor:function(world){this.$initialize();this.World=world}},methods:{AppendFlags:function(flags){this.Flags|=flags},RemoveFlags:function(flags){this.Flags&=~flags}}});Bridge.define("VelcroPhysics.Extensions.DebugView.DebugViewFlags",{$kind:"enum",statics:{fields:{Shape:1,Joint:2,AABB:4,CenterOfMass:16,DebugPanel:32,ContactPoints:64,ContactNormals:128,PolygonPoints:256,PerformanceGraph:512,Controllers:1024}},$flags:!0});Bridge.define("VelcroPhysics.Extensions.PhysicsLogics.Explosion.RayDataComparer",{inherits:[System.Collections.Generic.IComparer$1(System.Single)],alias:["System$Collections$Generic$IComparer$1$System$Single$compare","System$Collections$Generic$IComparer$1$compare"],methods:{System$Collections$Generic$IComparer$1$System$Single$compare:function(a,b){var diff=a-b;return diff>0?1:diff<0?-1:0}}});Bridge.define("VelcroPhysics.Extensions.PhysicsLogics.PhysicsLogicBase.PhysicsLogicFilter",{$kind:"struct",statics:{methods:{getDefaultValue:function(){return new VelcroPhysics.Extensions.PhysicsLogics.PhysicsLogicBase.PhysicsLogicFilter}}},fields:{ControllerIgnores:0},ctors:{ctor:function(){this.$initialize()}},methods:{IgnorePhysicsLogic:function(type){this.ControllerIgnores|=type},RestorePhysicsLogic:function(type){this.ControllerIgnores&=~type},IsPhysicsLogicIgnored:function(type){return(this.ControllerIgnores&type)===type},getHashCode:function(){return Bridge.addHash([6841110227,this.ControllerIgnores])},equals:function(o){return Bridge.is(o,VelcroPhysics.Extensions.PhysicsLogics.PhysicsLogicBase.PhysicsLogicFilter)?Bridge.equals(this.ControllerIgnores,o.ControllerIgnores):!1},$clone:function(to){var s=to||new VelcroPhysics.Extensions.PhysicsLogics.PhysicsLogicBase.PhysicsLogicFilter;return s.ControllerIgnores=this.ControllerIgnores,s}}});Bridge.define("VelcroPhysics.Extensions.PhysicsLogics.PhysicsLogicBase.PhysicsLogicType",{$kind:"enum",statics:{fields:{Explosion:1}},$flags:!0});Bridge.define("VelcroPhysics.Extensions.PhysicsLogics.PhysicsLogicBase.ShapeData",{$kind:"struct",statics:{methods:{getDefaultValue:function(){return new VelcroPhysics.Extensions.PhysicsLogics.PhysicsLogicBase.ShapeData}}},fields:{Body:null,Max:0,Min:0},ctors:{ctor:function(){this.$initialize()}},methods:{getHashCode:function(){return Bridge.addHash([3837963545,this.Body,this.Max,this.Min])},equals:function(o){return Bridge.is(o,VelcroPhysics.Extensions.PhysicsLogics.PhysicsLogicBase.ShapeData)?Bridge.equals(this.Body,o.Body)&&Bridge.equals(this.Max,o.Max)&&Bridge.equals(this.Min,o.Min):!1},$clone:function(to){var s=to||new VelcroPhysics.Extensions.PhysicsLogics.PhysicsLogicBase.ShapeData;return s.Body=this.Body,s.Max=this.Max,s.Min=this.Min,s}}});Bridge.define("VelcroPhysics.Factories.BodyFactory",{statics:{methods:{CreateBody:function(world,position,rotation,bodyType,userData){position===void 0&&(position=new Microsoft.Xna.Framework.Vector2);rotation===void 0&&(rotation=0);bodyType===void 0&&(bodyType=0);userData===void 0&&(userData=null);var template=new VelcroPhysics.Templates.BodyTemplate;return template.Position=position.$clone(),template.Angle=rotation,template.Type=bodyType,template.UserData=userData,world.CreateBody(template)},CreateEdge:function(world,start,end,userData){userData===void 0&&(userData=null);var body=VelcroPhysics.Factories.BodyFactory.CreateBody(world);return body.UserData=userData,VelcroPhysics.Factories.FixtureFactory.AttachEdge(start.$clone(),end.$clone(),body),body},CreateChainShape:function(world,vertices,position,userData){position===void 0&&(position=new Microsoft.Xna.Framework.Vector2);userData===void 0&&(userData=null);var body=VelcroPhysics.Factories.BodyFactory.CreateBody(world,position.$clone());return body.UserData=userData,VelcroPhysics.Factories.FixtureFactory.AttachChainShape(vertices,body),body},CreateLoopShape:function(world,vertices,position,userData){position===void 0&&(position=new Microsoft.Xna.Framework.Vector2);userData===void 0&&(userData=null);var body=VelcroPhysics.Factories.BodyFactory.CreateBody(world,position.$clone());return body.UserData=userData,VelcroPhysics.Factories.FixtureFactory.AttachLoopShape(vertices,body),body},CreateRectangle:function(world,width,height,density,position,rotation,bodyType,userData){if(position===void 0&&(position=new Microsoft.Xna.Framework.Vector2),rotation===void 0&&(rotation=0),bodyType===void 0&&(bodyType=0),userData===void 0&&(userData=null),width<=0)throw new System.ArgumentOutOfRangeException.$ctor4("width","Width must be more than 0 meters");if(height<=0)throw new System.ArgumentOutOfRangeException.$ctor4("height","Height must be more than 0 meters");var body=VelcroPhysics.Factories.BodyFactory.CreateBody(world,position.$clone(),rotation,bodyType,userData),rectangleVertices=VelcroPhysics.Utilities.PolygonUtils.CreateRectangle(width/2,height/2);return VelcroPhysics.Factories.FixtureFactory.AttachPolygon(rectangleVertices,density,body),body},CreateCircle:function(world,radius,density,position,bodyType,userData){position===void 0&&(position=new Microsoft.Xna.Framework.Vector2);bodyType===void 0&&(bodyType=0);userData===void 0&&(userData=null);var body=VelcroPhysics.Factories.BodyFactory.CreateBody(world,position.$clone(),0,bodyType,userData);return VelcroPhysics.Factories.FixtureFactory.AttachCircle$1(radius,density,body),body},CreateEllipse:function(world,xRadius,yRadius,edges,density,position,rotation,bodyType,userData){position===void 0&&(position=new Microsoft.Xna.Framework.Vector2);rotation===void 0&&(rotation=0);bodyType===void 0&&(bodyType=0);userData===void 0&&(userData=null);var body=VelcroPhysics.Factories.BodyFactory.CreateBody(world,position.$clone(),rotation,bodyType,userData);return VelcroPhysics.Factories.FixtureFactory.AttachEllipse(xRadius,yRadius,edges,density,body),body},CreatePolygon:function(world,vertices,density,position,rotation,bodyType,userData){position===void 0&&(position=new Microsoft.Xna.Framework.Vector2);rotation===void 0&&(rotation=0);bodyType===void 0&&(bodyType=0);userData===void 0&&(userData=null);var body=VelcroPhysics.Factories.BodyFactory.CreateBody(world,position.$clone(),rotation,bodyType,userData);return VelcroPhysics.Factories.FixtureFactory.AttachPolygon(vertices,density,body),body},CreateCompoundPolygon:function(world,list,density,position,rotation,bodyType,userData){position===void 0&&(position=new Microsoft.Xna.Framework.Vector2);rotation===void 0&&(rotation=0);bodyType===void 0&&(bodyType=0);userData===void 0&&(userData=null);var body=VelcroPhysics.Factories.BodyFactory.CreateBody(world,position.$clone(),rotation,bodyType,userData);return VelcroPhysics.Factories.FixtureFactory.AttachCompoundPolygon(list,density,body),body},CreateGear:function(world,radius,numberOfTeeth,tipPercentage,toothHeight,density,position,rotation,bodyType,userData){var gearPolygon,list;return(position===void 0&&(position=new Microsoft.Xna.Framework.Vector2),rotation===void 0&&(rotation=0),bodyType===void 0&&(bodyType=0),userData===void 0&&(userData=null),gearPolygon=VelcroPhysics.Utilities.PolygonUtils.CreateGear(radius,numberOfTeeth,tipPercentage,toothHeight),!gearPolygon.IsConvex())?(list=VelcroPhysics.Tools.Triangulation.TriangulationBase.Triangulate.ConvexPartition(gearPolygon,VelcroPhysics.Tools.Triangulation.TriangulationBase.TriangulationAlgorithm.Earclip),VelcroPhysics.Factories.BodyFactory.CreateCompoundPolygon(world,list,density,position.$clone(),rotation,bodyType,userData)):VelcroPhysics.Factories.BodyFactory.CreatePolygon(world,gearPolygon,density,position.$clone(),rotation,bodyType,userData)},CreateCapsule:function(world,height,topRadius,topEdges,bottomRadius,bottomEdges,density,position,rotation,bodyType,userData){var verts,vertList;return(position===void 0&&(position=new Microsoft.Xna.Framework.Vector2),rotation===void 0&&(rotation=0),bodyType===void 0&&(bodyType=0),userData===void 0&&(userData=null),verts=VelcroPhysics.Utilities.PolygonUtils.CreateCapsule$1(height,topRadius,topEdges,bottomRadius,bottomEdges),verts.Count>=VelcroPhysics.Settings.MaxPolygonVertices)?(vertList=VelcroPhysics.Tools.Triangulation.TriangulationBase.Triangulate.ConvexPartition(verts,VelcroPhysics.Tools.Triangulation.TriangulationBase.TriangulationAlgorithm.Earclip),VelcroPhysics.Factories.BodyFactory.CreateCompoundPolygon(world,vertList,density,position.$clone(),rotation,bodyType,userData)):VelcroPhysics.Factories.BodyFactory.CreatePolygon(world,verts,density,position.$clone(),rotation,bodyType,userData)},CreateCapsule$1:function(world,height,endRadius,density,position,rotation,bodyType,userData){var rectangle,list,body;return position===void 0&&(position=new Microsoft.Xna.Framework.Vector2),rotation===void 0&&(rotation=0),bodyType===void 0&&(bodyType=0),userData===void 0&&(userData=null),rectangle=VelcroPhysics.Utilities.PolygonUtils.CreateRectangle(endRadius,height/2),list=new(System.Collections.Generic.List$1(VelcroPhysics.Shared.Vertices).ctor),list.add(rectangle),body=VelcroPhysics.Factories.BodyFactory.CreateCompoundPolygon(world,list,density,position.$clone(),rotation,bodyType,userData),VelcroPhysics.Factories.FixtureFactory.AttachCircle(endRadius,density,body,new Microsoft.Xna.Framework.Vector2.$ctor2(0,height/2)),VelcroPhysics.Factories.FixtureFactory.AttachCircle(endRadius,density,body,new Microsoft.Xna.Framework.Vector2.$ctor2(0,-(height/2))),body},CreateRoundedRectangle:function(world,width,height,xRadius,yRadius,segments,density,position,rotation,bodyType,userData){var verts,vertList;return(position===void 0&&(position=new Microsoft.Xna.Framework.Vector2),rotation===void 0&&(rotation=0),bodyType===void 0&&(bodyType=0),userData===void 0&&(userData=null),verts=VelcroPhysics.Utilities.PolygonUtils.CreateRoundedRectangle(width,height,xRadius,yRadius,segments),verts.Count>=VelcroPhysics.Settings.MaxPolygonVertices)?(vertList=VelcroPhysics.Tools.Triangulation.TriangulationBase.Triangulate.ConvexPartition(verts,VelcroPhysics.Tools.Triangulation.TriangulationBase.TriangulationAlgorithm.Earclip),VelcroPhysics.Factories.BodyFactory.CreateCompoundPolygon(world,vertList,density,position.$clone(),rotation,bodyType,userData)):VelcroPhysics.Factories.BodyFactory.CreatePolygon(world,verts,density,position.$clone(),rotation,bodyType,userData)},CreateLineArc:function(world,radians,sides,radius,closed,position,rotation,bodyType,userData){closed===void 0&&(closed=!1);position===void 0&&(position=new Microsoft.Xna.Framework.Vector2);rotation===void 0&&(rotation=0);bodyType===void 0&&(bodyType=0);userData===void 0&&(userData=null);var body=VelcroPhysics.Factories.BodyFactory.CreateBody(world,position.$clone(),rotation,bodyType,userData);return VelcroPhysics.Factories.FixtureFactory.AttachLineArc(radians,sides,radius,closed,body),body},CreateSolidArc:function(world,density,radians,sides,radius,position,rotation,bodyType,userData){position===void 0&&(position=new Microsoft.Xna.Framework.Vector2);rotation===void 0&&(rotation=0);bodyType===void 0&&(bodyType=0);userData===void 0&&(userData=null);var body=VelcroPhysics.Factories.BodyFactory.CreateBody(world,position.$clone(),rotation,bodyType,userData);return VelcroPhysics.Factories.FixtureFactory.AttachSolidArc(density,radians,sides,radius,body),body},CreateBreakableBody$1:function(world,vertices,density,position,rotation){position===void 0&&(position=new Microsoft.Xna.Framework.Vector2);rotation===void 0&&(rotation=0);var triangles=VelcroPhysics.Tools.Triangulation.TriangulationBase.Triangulate.ConvexPartition(vertices,VelcroPhysics.Tools.Triangulation.TriangulationBase.TriangulationAlgorithm.Earclip),breakableBody=new VelcroPhysics.Dynamics.BreakableBody.$ctor1(world,triangles,density,position.$clone(),rotation);return breakableBody.MainBody.Position=position.$clone(),world.AddBreakableBody(breakableBody),breakableBody},CreateBreakableBody:function(world,shapes,position,rotation){position===void 0&&(position=new Microsoft.Xna.Framework.Vector2);rotation===void 0&&(rotation=0);var breakableBody=new VelcroPhysics.Dynamics.BreakableBody.ctor(world,shapes,position.$clone(),rotation);return breakableBody.MainBody.Position=position.$clone(),world.AddBreakableBody(breakableBody),breakableBody},CreateFromTemplate:function(world,bodyTemplate){return world.CreateBody(bodyTemplate)}}}});Bridge.define("VelcroPhysics.Factories.FixtureFactory",{statics:{methods:{AttachEdge:function(start,end,body,userData){userData===void 0&&(userData=null);var edgeShape=new VelcroPhysics.Collision.Shapes.EdgeShape.$ctor1(start.$clone(),end.$clone());return body.CreateFixture(edgeShape,userData)},AttachChainShape:function(vertices,body,userData){userData===void 0&&(userData=null);var shape=new VelcroPhysics.Collision.Shapes.ChainShape.$ctor1(vertices);return body.CreateFixture(shape,userData)},AttachLoopShape:function(vertices,body,userData){userData===void 0&&(userData=null);var shape=new VelcroPhysics.Collision.Shapes.ChainShape.$ctor1(vertices,!0);return body.CreateFixture(shape,userData)},AttachRectangle:function(width,height,density,offset,body,userData){var rectangleVertices,rectangleShape;return userData===void 0&&(userData=null),offset={v:offset},rectangleVertices=VelcroPhysics.Utilities.PolygonUtils.CreateRectangle(width/2,height/2),rectangleVertices.Translate$1(offset),rectangleShape=new VelcroPhysics.Collision.Shapes.PolygonShape.$ctor2(rectangleVertices,density),body.CreateFixture(rectangleShape,userData)},AttachCircle$1:function(radius,density,body,userData){if(userData===void 0&&(userData=null),radius<=0)throw new System.ArgumentOutOfRangeException.$ctor4("radius","Radius must be more than 0 meters");var circleShape=new VelcroPhysics.Collision.Shapes.CircleShape.$ctor1(radius,density);return body.CreateFixture(circleShape,userData)},AttachCircle:function(radius,density,body,offset,userData){if(userData===void 0&&(userData=null),radius<=0)throw new System.ArgumentOutOfRangeException.$ctor4("radius","Radius must be more than 0 meters");var circleShape=new VelcroPhysics.Collision.Shapes.CircleShape.$ctor1(radius,density);return circleShape.Position=offset.$clone(),body.CreateFixture(circleShape,userData)},AttachPolygon:function(vertices,density,body,userData){if(userData===void 0&&(userData=null),vertices.Count<=1)throw new System.ArgumentOutOfRangeException.$ctor4("vertices","Too few points to be a polygon");var polygon=new VelcroPhysics.Collision.Shapes.PolygonShape.$ctor2(vertices,density);return body.CreateFixture(polygon,userData)},AttachEllipse:function(xRadius,yRadius,edges,density,body,userData){if(userData===void 0&&(userData=null),xRadius<=0)throw new System.ArgumentOutOfRangeException.$ctor4("xRadius","X-radius must be more than 0");if(yRadius<=0)throw new System.ArgumentOutOfRangeException.$ctor4("yRadius","Y-radius must be more than 0");var ellipseVertices=VelcroPhysics.Utilities.PolygonUtils.CreateEllipse(xRadius,yRadius,edges),polygonShape=new VelcroPhysics.Collision.Shapes.PolygonShape.$ctor2(ellipseVertices,density);return body.CreateFixture(polygonShape,userData)},AttachCompoundPolygon:function(list,density,body,userData){var $t,res,vertices,shape,shape1;userData===void 0&&(userData=null);res=new(System.Collections.Generic.List$1(VelcroPhysics.Dynamics.Fixture).$ctor2)(list.Count);$t=Bridge.getEnumerator(list);try{while($t.moveNext())vertices=$t.Current,vertices.Count===2?(shape=new VelcroPhysics.Collision.Shapes.EdgeShape.$ctor1(vertices.getItem(0).$clone(),vertices.getItem(1).$clone()),res.add(body.CreateFixture(shape,userData))):(shape1=new VelcroPhysics.Collision.Shapes.PolygonShape.$ctor2(vertices,density),res.add(body.CreateFixture(shape1,userData)))}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}return res},AttachLineArc:function(radians,sides,radius,closed,body){var arc=VelcroPhysics.Utilities.PolygonUtils.CreateArc(radians,sides,radius);return arc.Rotate((Microsoft.Xna.Framework.MathHelper.Pi-radians)/2),closed?VelcroPhysics.Factories.FixtureFactory.AttachLoopShape(arc,body):VelcroPhysics.Factories.FixtureFactory.AttachChainShape(arc,body)},AttachSolidArc:function(density,radians,sides,radius,body){var arc=VelcroPhysics.Utilities.PolygonUtils.CreateArc(radians,sides,radius),triangles;return arc.Rotate((Microsoft.Xna.Framework.MathHelper.Pi-radians)/2),arc.add(arc.getItem(0).$clone()),triangles=VelcroPhysics.Tools.Triangulation.TriangulationBase.Triangulate.ConvexPartition(arc,VelcroPhysics.Tools.Triangulation.TriangulationBase.TriangulationAlgorithm.Earclip),VelcroPhysics.Factories.FixtureFactory.AttachCompoundPolygon(triangles,density,body)},CreateFromTemplate:function(body,f1){return body.CreateFixture$1(f1)}}}});Bridge.define("VelcroPhysics.Factories.JointFactory",{statics:{methods:{CreateMotorJoint:function(world,bodyA,bodyB,useWorldCoordinates){useWorldCoordinates===void 0&&(useWorldCoordinates=!1);var joint=new VelcroPhysics.Dynamics.Joints.MotorJoint.$ctor1(bodyA,bodyB,useWorldCoordinates);return world.AddJoint(joint),joint},CreateRopeJoint:function(world,bodyA,bodyB,anchorA,anchorB,useWorldCoordinates){useWorldCoordinates===void 0&&(useWorldCoordinates=!1);var ropeJoint=new VelcroPhysics.Dynamics.Joints.RopeJoint.$ctor1(bodyA,bodyB,anchorA.$clone(),anchorB.$clone(),useWorldCoordinates);return world.AddJoint(ropeJoint),ropeJoint},CreateWeldJoint:function(world,bodyA,bodyB,anchorA,anchorB,useWorldCoordinates){useWorldCoordinates===void 0&&(useWorldCoordinates=!1);var weldJoint=new VelcroPhysics.Dynamics.Joints.WeldJoint.$ctor1(bodyA,bodyB,anchorA.$clone(),anchorB.$clone(),useWorldCoordinates);return world.AddJoint(weldJoint),weldJoint},CreatePrismaticJoint:function(world,bodyA,bodyB,anchor,axis,useWorldCoordinates){useWorldCoordinates===void 0&&(useWorldCoordinates=!1);var joint=new VelcroPhysics.Dynamics.Joints.PrismaticJoint.$ctor2(bodyA,bodyB,anchor.$clone(),axis.$clone(),useWorldCoordinates);return world.AddJoint(joint),joint},CreateAngleJoint:function(world,bodyA,bodyB){var angleJoint=new VelcroPhysics.Dynamics.Joints.AngleJoint.$ctor1(bodyA,bodyB);return world.AddJoint(angleJoint),angleJoint},CreateGearJoint:function(world,bodyA,bodyB,jointA,jointB,ratio){var gearJoint=new VelcroPhysics.Dynamics.Joints.GearJoint(bodyA,bodyB,jointA,jointB,ratio);return world.AddJoint(gearJoint),gearJoint},CreatePulleyJoint:function(world,bodyA,bodyB,anchorA,anchorB,worldAnchorA,worldAnchorB,ratio,useWorldCoordinates){useWorldCoordinates===void 0&&(useWorldCoordinates=!1);var pulleyJoint=new VelcroPhysics.Dynamics.Joints.PulleyJoint.$ctor1(bodyA,bodyB,anchorA.$clone(),anchorB.$clone(),worldAnchorA.$clone(),worldAnchorB.$clone(),ratio,useWorldCoordinates);return world.AddJoint(pulleyJoint),pulleyJoint},CreateFixedMouseJoint:function(world,body,worldAnchor){var joint=new VelcroPhysics.Dynamics.Joints.FixedMouseJoint(body,worldAnchor.$clone());return world.AddJoint(joint),joint},CreateRevoluteJoint$1:function(world,bodyA,bodyB,anchorA,anchorB,useWorldCoordinates){useWorldCoordinates===void 0&&(useWorldCoordinates=!1);var joint=new VelcroPhysics.Dynamics.Joints.RevoluteJoint.$ctor1(bodyA,bodyB,anchorA.$clone(),anchorB.$clone(),useWorldCoordinates);return world.AddJoint(joint),joint},CreateRevoluteJoint:function(world,bodyA,bodyB,anchor){var localanchorA=bodyA.GetLocalPoint(bodyB.GetWorldPoint(anchor.$clone())),joint=new VelcroPhysics.Dynamics.Joints.RevoluteJoint.$ctor1(bodyA,bodyB,localanchorA.$clone(),anchor.$clone());return world.AddJoint(joint),joint},CreateWheelJoint$1:function(world,bodyA,bodyB,anchor,axis,useWorldCoordinates){useWorldCoordinates===void 0&&(useWorldCoordinates=!1);var joint=new VelcroPhysics.Dynamics.Joints.WheelJoint.$ctor1(bodyA,bodyB,anchor.$clone(),axis.$clone(),useWorldCoordinates);return world.AddJoint(joint),joint},CreateWheelJoint:function(world,bodyA,bodyB,axis){return VelcroPhysics.Factories.JointFactory.CreateWheelJoint$1(world,bodyA,bodyB,Microsoft.Xna.Framework.Vector2.Zero.$clone(),axis.$clone())},CreateDistanceJoint$1:function(world,bodyA,bodyB,anchorA,anchorB,useWorldCoordinates){useWorldCoordinates===void 0&&(useWorldCoordinates=!1);var distanceJoint=new VelcroPhysics.Dynamics.Joints.DistanceJoint.$ctor1(bodyA,bodyB,anchorA.$clone(),anchorB.$clone(),useWorldCoordinates);return world.AddJoint(distanceJoint),distanceJoint},CreateDistanceJoint:function(world,bodyA,bodyB){return VelcroPhysics.Factories.JointFactory.CreateDistanceJoint$1(world,bodyA,bodyB,Microsoft.Xna.Framework.Vector2.Zero.$clone(),Microsoft.Xna.Framework.Vector2.Zero.$clone())},CreateFrictionJoint$1:function(world,bodyA,bodyB,anchor,useWorldCoordinates){useWorldCoordinates===void 0&&(useWorldCoordinates=!1);var frictionJoint=new VelcroPhysics.Dynamics.Joints.FrictionJoint.$ctor1(bodyA,bodyB,anchor.$clone(),useWorldCoordinates);return world.AddJoint(frictionJoint),frictionJoint},CreateFrictionJoint:function(world,bodyA,bodyB){return VelcroPhysics.Factories.JointFactory.CreateFrictionJoint$1(world,bodyA,bodyB,Microsoft.Xna.Framework.Vector2.Zero.$clone())}}}});Bridge.define("VelcroPhysics.Settings",{statics:{fields:{MaxFloat:0,Epsilon:0,Pi:0,EnableDiagnostics:!1,SkipSanityChecks:!1,MaxSubSteps:0,EnableWarmstarting:!1,MaxManifoldPoints:0,AABBExtension:0,AABBMultiplier:0,LinearSlop:0,AngularSlop:0,PolygonRadius:0,MaxTOIContacts:0,VelocityThreshold:0,MaxLinearCorrection:0,MaxAngularCorrection:0,Baumgarte:0,TimeToSleep:0,LinearSleepTolerance:0,AngularSleepTolerance:0,MaxTranslation:0,MaxTranslationSquared:0,MaxRotation:0,MaxRotationSquared:0,MaxGJKIterations:0,EnableSubStepping:!1,AutoClearForces:!1,VelocityIterations:0,PositionIterations:0,ContinuousPhysics:!1,UseConvexHullPolygons:!1,TOIVelocityIterations:0,TOIPositionIterations:0,AllowSleep:!1,MaxPolygonVertices:0,UseFPECollisionCategories:!1,DefaultFixtureCollisionCategories:0,DefaultFixtureCollidesWith:0,DefaultFixtureIgnoreCCDWith:0,BlockSolve:!1},ctors:{init:function(){this.MaxFloat=340282347e30;this.Epsilon=11920929e-14;this.Pi=3.14159274;this.EnableDiagnostics=!0;this.SkipSanityChecks=!1;this.MaxSubSteps=8;this.EnableWarmstarting=!0;this.MaxManifoldPoints=2;this.AABBExtension=.1;this.AABBMultiplier=2;this.LinearSlop=.005;this.AngularSlop=.03490659;this.PolygonRadius=.01;this.MaxTOIContacts=32;this.VelocityThreshold=1;this.MaxLinearCorrection=.2;this.MaxAngularCorrection=.139626354;this.Baumgarte=.2;this.TimeToSleep=.5;this.LinearSleepTolerance=.01;this.AngularSleepTolerance=.03490659;this.MaxTranslation=2;this.MaxTranslationSquared=4;this.MaxRotation=1.57079637;this.MaxRotationSquared=2.46740127;this.MaxGJKIterations=20;this.EnableSubStepping=!1;this.AutoClearForces=!0;this.VelocityIterations=8;this.PositionIterations=3;this.ContinuousPhysics=!0;this.UseConvexHullPolygons=!0;this.TOIVelocityIterations=VelcroPhysics.Settings.VelocityIterations;this.TOIPositionIterations=20;this.AllowSleep=!0;this.MaxPolygonVertices=8;this.DefaultFixtureCollisionCategories=VelcroPhysics.Collision.Filtering.Category.Cat1;this.DefaultFixtureCollidesWith=VelcroPhysics.Collision.Filtering.Category.All;this.DefaultFixtureIgnoreCCDWith=VelcroPhysics.Collision.Filtering.Category.None;this.BlockSolve=!0}},methods:{MixFriction:function(friction1,friction2){return Math.sqrt(friction1*friction2)},MixRestitution:function(restitution1,restitution2){return restitution1>restitution2?restitution1:restitution2}}}});Bridge.define("VelcroPhysics.Shared.AABB",{$kind:"struct",statics:{methods:{TestOverlap:function(a,b){var d1=Microsoft.Xna.Framework.Vector2.op_Subtraction(b.v.LowerBound.$clone(),a.v.UpperBound.$clone()),d2=Microsoft.Xna.Framework.Vector2.op_Subtraction(a.v.LowerBound.$clone(),b.v.UpperBound.$clone());return d1.X<=0&&d1.Y<=0&&d2.X<=0&&d2.Y<=0},getDefaultValue:function(){return new VelcroPhysics.Shared.AABB}}},fields:{LowerBound:null,UpperBound:null},props:{Width:{get:function(){return this.UpperBound.X-this.LowerBound.X}},Height:{get:function(){return this.UpperBound.Y-this.LowerBound.Y}},Center:{get:function(){return Microsoft.Xna.Framework.Vector2.op_Multiply$2(.5,Microsoft.Xna.Framework.Vector2.op_Addition(this.LowerBound.$clone(),this.UpperBound.$clone()))}},Extents:{get:function(){return Microsoft.Xna.Framework.Vector2.op_Multiply$2(.5,Microsoft.Xna.Framework.Vector2.op_Subtraction(this.UpperBound.$clone(),this.LowerBound.$clone()))}},Perimeter:{get:function(){var wx=this.UpperBound.X-this.LowerBound.X,wy=this.UpperBound.Y-this.LowerBound.Y;return 2*(wx+wy)}},Vertices:{get:function(){var vertices=new VelcroPhysics.Shared.Vertices.$ctor2(4);return vertices.add(this.UpperBound.$clone()),vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(this.UpperBound.X,this.LowerBound.Y)),vertices.add(this.LowerBound.$clone()),vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(this.LowerBound.X,this.UpperBound.Y)),vertices}},Q1:{get:function(){return new VelcroPhysics.Shared.AABB.$ctor1(this.Center.$clone(),this.UpperBound.$clone())}},Q2:{get:function(){return new VelcroPhysics.Shared.AABB.$ctor1(new Microsoft.Xna.Framework.Vector2.$ctor2(this.LowerBound.X,this.Center.Y),new Microsoft.Xna.Framework.Vector2.$ctor2(this.Center.X,this.UpperBound.Y))}},Q3:{get:function(){return new VelcroPhysics.Shared.AABB.$ctor1(this.LowerBound.$clone(),this.Center.$clone())}},Q4:{get:function(){return new VelcroPhysics.Shared.AABB.$ctor1(new Microsoft.Xna.Framework.Vector2.$ctor2(this.Center.X,this.LowerBound.Y),new Microsoft.Xna.Framework.Vector2.$ctor2(this.UpperBound.X,this.Center.Y))}}},ctors:{init:function(){this.LowerBound=new Microsoft.Xna.Framework.Vector2;this.UpperBound=new Microsoft.Xna.Framework.Vector2},$ctor1:function(min,max){VelcroPhysics.Shared.AABB.$ctor3.call(this,min,max)},$ctor2:function(center,width,height){VelcroPhysics.Shared.AABB.$ctor1.call(this,Microsoft.Xna.Framework.Vector2.op_Subtraction(center.$clone(),new Microsoft.Xna.Framework.Vector2.$ctor2(width/2,height/2)),Microsoft.Xna.Framework.Vector2.op_Addition(center.$clone(),new Microsoft.Xna.Framework.Vector2.$ctor2(width/2,height/2)))},$ctor3:function(min,max){this.$initialize();this.LowerBound=new Microsoft.Xna.Framework.Vector2.$ctor2(Math.min(min.v.X,max.v.X),Math.min(min.v.Y,max.v.Y));this.UpperBound=new Microsoft.Xna.Framework.Vector2.$ctor2(Math.max(min.v.X,max.v.X),Math.max(min.v.Y,max.v.Y))},ctor:function(){this.$initialize()}},methods:{IsValid:function(){var d=Microsoft.Xna.Framework.Vector2.op_Subtraction(this.UpperBound.$clone(),this.LowerBound.$clone()),valid=d.X>=0&&d.Y>=0;return valid&&VelcroPhysics.Utilities.MathUtils.IsValid(this.LowerBound)&&VelcroPhysics.Utilities.MathUtils.IsValid(this.UpperBound)},Combine:function(aabb){this.LowerBound=Microsoft.Xna.Framework.Vector2.Min(this.LowerBound.$clone(),aabb.v.LowerBound.$clone());this.UpperBound=Microsoft.Xna.Framework.Vector2.Max(this.UpperBound.$clone(),aabb.v.UpperBound.$clone())},Combine$1:function(aabb1,aabb2){this.LowerBound=Microsoft.Xna.Framework.Vector2.Min(aabb1.v.LowerBound.$clone(),aabb2.v.LowerBound.$clone());this.UpperBound=Microsoft.Xna.Framework.Vector2.Max(aabb1.v.UpperBound.$clone(),aabb2.v.UpperBound.$clone())},Contains$1:function(aabb){var result=this.LowerBound.X<=aabb.v.LowerBound.X;return result=result&&this.LowerBound.Y<=aabb.v.LowerBound.Y,result=result&&aabb.v.UpperBound.X<=this.UpperBound.X,result&&aabb.v.UpperBound.Y<=this.UpperBound.Y},Contains:function(point){return point.v.X>this.LowerBound.X+1401298e-51&&point.v.X<this.UpperBound.X-1401298e-51&&point.v.Y>this.LowerBound.Y+1401298e-51&&point.v.Y<this.UpperBound.Y-1401298e-51},RayCast:function(output,input,doInteriorCheck){var i;doInteriorCheck===void 0&&(doInteriorCheck=!0);output.v=new VelcroPhysics.Collision.RayCast.RayCastOutput;var tmin=-340282347e30,tmax=VelcroPhysics.Settings.MaxFloat,p=input.v.Point1.$clone(),d=Microsoft.Xna.Framework.Vector2.op_Subtraction(input.v.Point2.$clone(),input.v.Point1.$clone()),absD=VelcroPhysics.Utilities.MathUtils.Abs(d.$clone()),normal=Microsoft.Xna.Framework.Vector2.Zero.$clone();for(i=0;i<2;i=i+1|0){var absD_i=i===0?absD.X:absD.Y,lowerBound_i=i===0?this.LowerBound.X:this.LowerBound.Y,upperBound_i=i===0?this.UpperBound.X:this.UpperBound.Y,p_i=i===0?p.X:p.Y;if(absD_i<VelcroPhysics.Settings.Epsilon){if(p_i<lowerBound_i||upperBound_i<p_i)return!1}else{var d_i=i===0?d.X:d.Y,inv_d=1/d_i,t1={v:(lowerBound_i-p_i)*inv_d},t2={v:(upperBound_i-p_i)*inv_d},s=-1;if(t1.v>t2.v&&(VelcroPhysics.Utilities.MathUtils.Swap(System.Single,t1,t2),s=1),t1.v>tmin&&(i===0?normal.X=s:normal.Y=s,tmin=t1.v),tmax=Math.min(tmax,t2.v),tmin>tmax)return!1}}return doInteriorCheck&&(tmin<0||input.v.MaxFraction<tmin)?!1:(output.v.Fraction=tmin,output.v.Normal=normal.$clone(),!0)},getHashCode:function(){return Bridge.addHash([1111638337,this.LowerBound,this.UpperBound])},equals:function(o){return Bridge.is(o,VelcroPhysics.Shared.AABB)?Bridge.equals(this.LowerBound,o.LowerBound)&&Bridge.equals(this.UpperBound,o.UpperBound):!1},$clone:function(to){var s=to||new VelcroPhysics.Shared.AABB;return s.LowerBound=this.LowerBound.$clone(),s.UpperBound=this.UpperBound.$clone(),s}}});Bridge.define("VelcroPhysics.Shared.Benchmark",{statics:{fields:{_results:null,_runPool:null},ctors:{init:function(){this._results=new(System.Collections.Generic.Dictionary$2(System.String,System.Int64));this._runPool=new(VelcroPhysics.Shared.Pool$1(VelcroPhysics.Shared.BenchmarkRun))(function(){return new VelcroPhysics.Shared.BenchmarkRun})}},methods:{StartRun:function(area){var run=VelcroPhysics.Shared.Benchmark._runPool.GetFromPool();return run.SetData(area),run},RecordResults:function(area,results){!0&&(VelcroPhysics.Shared.Benchmark._results.containsKey(area)?VelcroPhysics.Shared.Benchmark._results.set(area,VelcroPhysics.Shared.Benchmark._results.get(area).add(results)):VelcroPhysics.Shared.Benchmark._results.add(area,results))},ResetResults:function(area){if(0)return System.Int64(0);var oldVal=VelcroPhysics.Shared.Benchmark._results.get(area);return VelcroPhysics.Shared.Benchmark._results.set(area,System.Int64(0)),oldVal},GetResults:function(area){if(0)return System.Int64(0);var value={};return VelcroPhysics.Shared.Benchmark._results.tryGetValue(area,value)?value.v:System.Int64(0)}}}});Bridge.definei("VelcroPhysics.Shared.Optimization.IPoolable$1",function(T){return{inherits:[System.IDisposable],$kind:"interface"}});Bridge.define("VelcroPhysics.Shared.Contracts.Contract",{statics:{methods:{Requires:function(condition,message){if(!condition){message=VelcroPhysics.Shared.Contracts.Contract.BuildMessage("REQUIRED",message);throw new VelcroPhysics.Shared.Contracts.RequiredException(message);}},Warn:function(condition,message){message=VelcroPhysics.Shared.Contracts.Contract.BuildMessage("WARNING",message);System.Diagnostics.Debug.WriteLineIf$2(!condition,message)},Ensures:function(condition,message){if(!condition){message=VelcroPhysics.Shared.Contracts.Contract.BuildMessage("ENSURANCE",message);throw new VelcroPhysics.Shared.Contracts.EnsuresException(message);}},RequireForAll:function(T,value,check){var $t,item;$t=Bridge.getEnumerator(value,T);try{while($t.moveNext())item=$t.Current,VelcroPhysics.Shared.Contracts.Contract.Requires(check(item),System.String.concat("Failed on: ",item))}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}},Fail:function(message){message=VelcroPhysics.Shared.Contracts.Contract.BuildMessage("FAILURE",message);throw new VelcroPhysics.Shared.Contracts.RequiredException(message);},BuildMessage:function(type,message){var $t,stackTrace=Bridge.toArray(System.Linq.Enumerable.from(System.String.split(System.Environment.StackTrace,($t="\n",System.String.toCharArray($t,0,$t.length)).map(function(i){return String.fromCharCode(i)}),null,1)).skip(3)).join("\n");return message==null?"":(type||"")+": "+(message||"")+"\n"+(stackTrace||"")}}}});Bridge.define("VelcroPhysics.Shared.Contracts.EnsuresException",{inherits:[System.Exception],ctors:{ctor:function(message){this.$initialize();System.Exception.ctor.call(this,message)}}});Bridge.define("VelcroPhysics.Shared.Contracts.RequiredException",{inherits:[System.Exception],ctors:{ctor:function(message){this.$initialize();System.Exception.ctor.call(this,message)}}});Bridge.define("VelcroPhysics.Shared.Graph$2",function(T,T1){return{inherits:[System.Collections.Generic.IEnumerable$1(T)],fields:{_comparer:null,Count:0,First:null},alias:["GetEnumerator",["System$Collections$Generic$IEnumerable$1$"+Bridge.getTypeAlias(T)+"$GetEnumerator","System$Collections$Generic$IEnumerable$1$GetEnumerator"]],ctors:{ctor:function(){this.$initialize();this._comparer=System.Collections.Generic.EqualityComparer$1(T).def},$ctor1:function(comparer){this.$initialize();VelcroPhysics.Shared.Contracts.Contract.Requires(comparer!=null,"You supplied a null comparer");this._comparer=comparer}},methods:{Add$1:function(value){var result=new(VelcroPhysics.Shared.GraphNode$2(T,T1))(value);return this.Add(result),result},Add:function(node){VelcroPhysics.Shared.Contracts.Contract.Requires(node!=null,"node must not be null");this.First==null?(node.Next=node,node.Prev=node,this.First=node,this.Count=this.Count+1|0):(node.Next=this.First,node.Prev=this.First.Prev,this.First.Prev.Next=node,this.First.Prev=node,this.Count=this.Count+1|0)},Contains:function(value){return this.Find(value)!=null},Find:function(value){var node=this.First;if(node==null)return null;if(value!=null){do{if(this._comparer.equals2(node.Item,value))return node;node=node.Next}while(!Bridge.referenceEquals(node,this.First))}else do{if(node.Item==null)return node;node=node.Next}while(!Bridge.referenceEquals(node,this.First));return null},Clear:function(){for(var node0,node=this.First,i=0;i<this.Count;i=i+1|0)node0=node,node=node.Next,node0.Invalidate()},Remove:function(value){var node=this.Find(value);return node==null?!1:(this.Remove$1(node),!0)},Remove$1:function(node){(VelcroPhysics.Shared.Contracts.Contract.Requires(node!=null,"node must not be null"),VelcroPhysics.Shared.Contracts.Contract.Warn(this.First!=null,"You are trying to remove an item from an empty list."),node.Next!=null||node.Prev!=null)&&(Bridge.referenceEquals(node.Next,node)?this.First=null:(node.Next.Prev=node.Prev,node.Prev.Next=node.Next,Bridge.referenceEquals(this.First,node)&&(this.First=node.Next)),node.Invalidate(),this.Count=this.Count-1|0)},GetEnumerator:function(){var $step=0,$jumpFromFinally,$returnValue,node,i,node0,$async_e,$enumerator=new(Bridge.GeneratorEnumerator$1(T))(Bridge.fn.bind(this,function(){try{for(;;)switch($step){case 0:node=this.First;i=0;$step=1;continue;case 1:if(i<this.Count){$step=2;continue}$step=5;continue;case 2:return node0=node,node=node.Next,$enumerator.current=node0.Item,$step=3,!0;case 3:$step=4;continue;case 4:i=i+1|0;$step=1;continue;case 5:default:return!1}}catch($async_e1){$async_e=System.Exception.create($async_e1);throw $async_e;}}));return $enumerator},System$Collections$IEnumerable$GetEnumerator:function(){return this.GetEnumerator()},GetNodes:function(){return new(Bridge.GeneratorEnumerable$1(VelcroPhysics.Shared.GraphNode$2(T,T1)))(Bridge.fn.bind(this,function(){var $step=0,$jumpFromFinally,$returnValue,node,i,node0,$async_e,$enumerator=new(Bridge.GeneratorEnumerator$1(VelcroPhysics.Shared.GraphNode$2(T,T1)))(Bridge.fn.bind(this,function(){try{for(;;)switch($step){case 0:node=this.First;i=0;$step=1;continue;case 1:if(i<this.Count){$step=2;continue}$step=5;continue;case 2:return node0=node,node=node.Next,$enumerator.current=node0,$step=3,!0;case 3:$step=4;continue;case 4:i=i+1|0;$step=1;continue;case 5:default:return!1}}catch($async_e1){$async_e=System.Exception.create($async_e1);throw $async_e;}}));return $enumerator}))}}}});Bridge.define("VelcroPhysics.Shared.GraphNode$2",function(T,T1){return{fields:{Item:Bridge.getDefaultValue(T),Next:null,Prev:null,Other:Bridge.getDefaultValue(T1)},ctors:{ctor:function(item){item===void 0&&(item=Bridge.getDefaultValue(T));this.$initialize();this.Item=item}},methods:{Invalidate:function(){this.Next=null;this.Prev=null},Clear:function(){this.Item=Bridge.getDefaultValue(T);this.Invalidate()}}}});Bridge.define("VelcroPhysics.Shared.Mat22",{$kind:"struct",statics:{methods:{Add:function(A,B,R){R.v.ex=Microsoft.Xna.Framework.Vector2.op_Addition(A.v.ex.$clone(),B.v.ex.$clone());R.v.ey=Microsoft.Xna.Framework.Vector2.op_Addition(A.v.ey.$clone(),B.v.ey.$clone())},getDefaultValue:function(){return new VelcroPhysics.Shared.Mat22}}},fields:{ex:null,ey:null},props:{Inverse:{get:function(){var a=this.ex.X,b=this.ey.X,c=this.ex.Y,d=this.ey.Y,det=a*d-b*c,result;return det!==0&&(det=1/det),result=new VelcroPhysics.Shared.Mat22.ctor,result.ex.X=det*d,result.ex.Y=-det*c,result.ey.X=-det*b,result.ey.Y=det*a,result.$clone()}}},ctors:{init:function(){this.ex=new Microsoft.Xna.Framework.Vector2;this.ey=new Microsoft.Xna.Framework.Vector2},$ctor1:function(c1,c2){this.$initialize();this.ex=c1.$clone();this.ey=c2.$clone()},$ctor2:function(a11,a12,a21,a22){this.$initialize();this.ex=new Microsoft.Xna.Framework.Vector2.$ctor2(a11,a21);this.ey=new Microsoft.Xna.Framework.Vector2.$ctor2(a12,a22)},ctor:function(){this.$initialize()}},methods:{Set:function(c1,c2){this.ex=c1.$clone();this.ey=c2.$clone()},SetIdentity:function(){this.ex.X=1;this.ey.X=0;this.ex.Y=0;this.ey.Y=1},SetZero:function(){this.ex.X=0;this.ey.X=0;this.ex.Y=0;this.ey.Y=0},Solve:function(b){var a11=this.ex.X,a12=this.ey.X,a21=this.ex.Y,a22=this.ey.Y,det=a11*a22-a12*a21;return det!==0&&(det=1/det),new Microsoft.Xna.Framework.Vector2.$ctor2(det*(a22*b.X-a12*b.Y),det*(a11*b.Y-a21*b.X))},getHashCode:function(){return Bridge.addHash([846487935,this.ex,this.ey])},equals:function(o){return Bridge.is(o,VelcroPhysics.Shared.Mat22)?Bridge.equals(this.ex,o.ex)&&Bridge.equals(this.ey,o.ey):!1},$clone:function(to){var s=to||new VelcroPhysics.Shared.Mat22;return s.ex=this.ex.$clone(),s.ey=this.ey.$clone(),s}}});Bridge.define("VelcroPhysics.Shared.Mat33",{$kind:"struct",statics:{methods:{getDefaultValue:function(){return new VelcroPhysics.Shared.Mat33}}},fields:{ex:null,ey:null,ez:null},ctors:{init:function(){this.ex=new Microsoft.Xna.Framework.Vector3;this.ey=new Microsoft.Xna.Framework.Vector3;this.ez=new Microsoft.Xna.Framework.Vector3},$ctor1:function(c1,c2,c3){this.$initialize();this.ex=c1.$clone();this.ey=c2.$clone();this.ez=c3.$clone()},ctor:function(){this.$initialize()}},methods:{SetZero:function(){this.ex=Microsoft.Xna.Framework.Vector3.Zero.$clone();this.ey=Microsoft.Xna.Framework.Vector3.Zero.$clone();this.ez=Microsoft.Xna.Framework.Vector3.Zero.$clone()},Solve33:function(b){var det=Microsoft.Xna.Framework.Vector3.Dot(this.ex.$clone(),Microsoft.Xna.Framework.Vector3.Cross(this.ey.$clone(),this.ez.$clone()));return det!==0&&(det=1/det),new Microsoft.Xna.Framework.Vector3.$ctor3(det*Microsoft.Xna.Framework.Vector3.Dot(b.$clone(),Microsoft.Xna.Framework.Vector3.Cross(this.ey.$clone(),this.ez.$clone())),det*Microsoft.Xna.Framework.Vector3.Dot(this.ex.$clone(),Microsoft.Xna.Framework.Vector3.Cross(b.$clone(),this.ez.$clone())),det*Microsoft.Xna.Framework.Vector3.Dot(this.ex.$clone(),Microsoft.Xna.Framework.Vector3.Cross(this.ey.$clone(),b.$clone())))},Solve22:function(b){var a11=this.ex.X,a12=this.ey.X,a21=this.ex.Y,a22=this.ey.Y,det=a11*a22-a12*a21;return det!==0&&(det=1/det),new Microsoft.Xna.Framework.Vector2.$ctor2(det*(a22*b.X-a12*b.Y),det*(a11*b.Y-a21*b.X))},GetInverse22:function(M){var a=this.ex.X,b=this.ey.X,c=this.ex.Y,d=this.ey.Y,det=a*d-b*c;det!==0&&(det=1/det);M.v.ex.X=det*d;M.v.ey.X=-det*b;M.v.ex.Z=0;M.v.ex.Y=-det*c;M.v.ey.Y=det*a;M.v.ey.Z=0;M.v.ez.X=0;M.v.ez.Y=0;M.v.ez.Z=0},GetSymInverse33:function(M){var det=VelcroPhysics.Utilities.MathUtils.Dot(this.ex.$clone(),VelcroPhysics.Utilities.MathUtils.Cross$2(this.ey,this.ez.$clone()));det!==0&&(det=1/det);var a11=this.ex.X,a12=this.ey.X,a13=this.ez.X,a22=this.ey.Y,a23=this.ez.Y,a33=this.ez.Z;M.v.ex.X=det*(a22*a33-a23*a23);M.v.ex.Y=det*(a13*a23-a12*a33);M.v.ex.Z=det*(a12*a23-a13*a22);M.v.ey.X=M.v.ex.Y;M.v.ey.Y=det*(a11*a33-a13*a13);M.v.ey.Z=det*(a13*a12-a11*a23);M.v.ez.X=M.v.ex.Z;M.v.ez.Y=M.v.ey.Z;M.v.ez.Z=det*(a11*a22-a12*a12)},getHashCode:function(){return Bridge.addHash([863265152,this.ex,this.ey,this.ez])},equals:function(o){return Bridge.is(o,VelcroPhysics.Shared.Mat33)?Bridge.equals(this.ex,o.ex)&&Bridge.equals(this.ey,o.ey)&&Bridge.equals(this.ez,o.ez):!1},$clone:function(to){var s=to||new VelcroPhysics.Shared.Mat33;return s.ex=this.ex.$clone(),s.ey=this.ey.$clone(),s.ez=this.ez.$clone(),s}}});Bridge.define("VelcroPhysics.Shared.Optimization.FixedArray2$1",function(T){return{inherits:[System.Collections.Generic.IEnumerable$1(T)],$kind:"struct",statics:{methods:{getDefaultValue:function(){return new(VelcroPhysics.Shared.Optimization.FixedArray2$1(T))}}},fields:{Value0:Bridge.getDefaultValue(T),Value1:Bridge.getDefaultValue(T)},alias:["GetEnumerator",["System$Collections$Generic$IEnumerable$1$"+Bridge.getTypeAlias(T)+"$GetEnumerator","System$Collections$Generic$IEnumerable$1$GetEnumerator"]],ctors:{ctor:function(){this.$initialize()}},methods:{getItem:function(index){switch(index){case 0:return this.Value0;case 1:return this.Value1;default:throw new System.IndexOutOfRangeException.ctor;}},setItem:function(index,value){switch(index){case 0:this.Value0=value;break;case 1:this.Value1=value;break;default:throw new System.IndexOutOfRangeException.ctor;}},GetEnumerator:function(){return Bridge.getEnumerator(this.Enumerate(),T)},System$Collections$IEnumerable$GetEnumerator:function(){return this.GetEnumerator()},IndexOf:function(value){for(var i=0;i<2;i=i+1|0)if(Bridge.equals(this.getItem(i),value))return i;return-1},Clear:function(){this.Value0=this.Value1=Bridge.getDefaultValue(T)},Enumerate:function(){return new(Bridge.GeneratorEnumerable$1(T))(Bridge.fn.bind(this,function(){var $step=0,$jumpFromFinally,$returnValue,i,$async_e,$enumerator=new(Bridge.GeneratorEnumerator$1(T))(Bridge.fn.bind(this,function(){try{for(;;)switch($step){case 0:i=0;$step=1;continue;case 1:if(i<2){$step=2;continue}$step=5;continue;case 2:return $enumerator.current=this.getItem(i),$step=3,!0;case 3:$step=4;continue;case 4:i=i+1|0;$step=1;continue;case 5:default:return!1}}catch($async_e1){$async_e=System.Exception.create($async_e1);throw $async_e;}}));return $enumerator}))},getHashCode:function(){return Bridge.addHash([3625788427,this.Value0,this.Value1])},equals:function(o){return Bridge.is(o,VelcroPhysics.Shared.Optimization.FixedArray2$1(T))?Bridge.equals(this.Value0,o.Value0)&&Bridge.equals(this.Value1,o.Value1):!1},$clone:function(to){var s=to||new(VelcroPhysics.Shared.Optimization.FixedArray2$1(T));return s.Value0=this.Value0,s.Value1=this.Value1,s}}}});Bridge.define("VelcroPhysics.Shared.Optimization.FixedArray3$1",function(T){return{inherits:[System.Collections.Generic.IEnumerable$1(T)],$kind:"struct",statics:{methods:{getDefaultValue:function(){return new(VelcroPhysics.Shared.Optimization.FixedArray3$1(T))}}},fields:{Value0:Bridge.getDefaultValue(T),Value1:Bridge.getDefaultValue(T),Value2:Bridge.getDefaultValue(T)},alias:["GetEnumerator",["System$Collections$Generic$IEnumerable$1$"+Bridge.getTypeAlias(T)+"$GetEnumerator","System$Collections$Generic$IEnumerable$1$GetEnumerator"]],ctors:{ctor:function(){this.$initialize()}},methods:{getItem:function(index){switch(index){case 0:return this.Value0;case 1:return this.Value1;case 2:return this.Value2;default:throw new System.IndexOutOfRangeException.ctor;}},setItem:function(index,value){switch(index){case 0:this.Value0=value;break;case 1:this.Value1=value;break;case 2:this.Value2=value;break;default:throw new System.IndexOutOfRangeException.ctor;}},GetEnumerator:function(){return Bridge.getEnumerator(this.Enumerate(),T)},System$Collections$IEnumerable$GetEnumerator:function(){return this.GetEnumerator()},IndexOf:function(value){for(var i=0;i<3;i=i+1|0)if(Bridge.equals(this.getItem(i),value))return i;return-1},Clear:function(){this.Value0=this.Value1=this.Value2=Bridge.getDefaultValue(T)},Enumerate:function(){return new(Bridge.GeneratorEnumerable$1(T))(Bridge.fn.bind(this,function(){var $step=0,$jumpFromFinally,$returnValue,i,$async_e,$enumerator=new(Bridge.GeneratorEnumerator$1(T))(Bridge.fn.bind(this,function(){try{for(;;)switch($step){case 0:i=0;$step=1;continue;case 1:if(i<3){$step=2;continue}$step=5;continue;case 2:return $enumerator.current=this.getItem(i),$step=3,!0;case 3:$step=4;continue;case 4:i=i+1|0;$step=1;continue;case 5:default:return!1}}catch($async_e1){$async_e=System.Exception.create($async_e1);throw $async_e;}}));return $enumerator}))},getHashCode:function(){return Bridge.addHash([3625853963,this.Value0,this.Value1,this.Value2])},equals:function(o){return Bridge.is(o,VelcroPhysics.Shared.Optimization.FixedArray3$1(T))?Bridge.equals(this.Value0,o.Value0)&&Bridge.equals(this.Value1,o.Value1)&&Bridge.equals(this.Value2,o.Value2):!1},$clone:function(to){var s=to||new(VelcroPhysics.Shared.Optimization.FixedArray3$1(T));return s.Value0=this.Value0,s.Value1=this.Value1,s.Value2=this.Value2,s}}}});Bridge.define("VelcroPhysics.Shared.PolygonError",{$kind:"enum",statics:{fields:{NoError:0,InvalidAmountOfVertices:1,NotSimple:2,NotCounterClockWise:3,NotConvex:4,AreaTooSmall:5,SideTooSmall:6}}});Bridge.define("VelcroPhysics.Shared.Rot",{$kind:"struct",statics:{methods:{getDefaultValue:function(){return new VelcroPhysics.Shared.Rot}}},fields:{s:0,c:0},ctors:{$ctor1:function(angle){this.$initialize();this.s=Math.sin(angle);this.c=Math.cos(angle)},ctor:function(){this.$initialize()}},methods:{Set:function(angle){angle===0?(this.s=0,this.c=1):(this.s=Math.sin(angle),this.c=Math.cos(angle))},SetIdentity:function(){this.s=0;this.c=1},GetAngle:function(){return Math.atan2(this.s,this.c)},GetXAxis:function(){return new Microsoft.Xna.Framework.Vector2.$ctor2(this.c,this.s)},GetYAxis:function(){return new Microsoft.Xna.Framework.Vector2.$ctor2(-this.s,this.c)},getHashCode:function(){return Bridge.addHash([7630674,this.s,this.c])},equals:function(o){return Bridge.is(o,VelcroPhysics.Shared.Rot)?Bridge.equals(this.s,o.s)&&Bridge.equals(this.c,o.c):!1},$clone:function(to){var s=to||new VelcroPhysics.Shared.Rot;return s.s=this.s,s.c=this.c,s}}});Bridge.define("VelcroPhysics.Shared.Transform",{$kind:"struct",statics:{methods:{getDefaultValue:function(){return new VelcroPhysics.Shared.Transform}}},fields:{p:null,q:null},ctors:{init:function(){this.p=new Microsoft.Xna.Framework.Vector2;this.q=new VelcroPhysics.Shared.Rot},$ctor1:function(position,rotation){this.$initialize();this.p=position.v.$clone();this.q=rotation.v.$clone()},ctor:function(){this.$initialize()}},methods:{SetIdentity:function(){this.p=Microsoft.Xna.Framework.Vector2.Zero.$clone();this.q.SetIdentity()},Set:function(position,angle){this.p=position.$clone();this.q.Set(angle)},getHashCode:function(){return Bridge.addHash([3771783476,this.p,this.q])},equals:function(o){return Bridge.is(o,VelcroPhysics.Shared.Transform)?Bridge.equals(this.p,o.p)&&Bridge.equals(this.q,o.q):!1},$clone:function(to){var s=to||new VelcroPhysics.Shared.Transform;return s.p=this.p.$clone(),s.q=this.q.$clone(),s}}});Bridge.define("VelcroPhysics.Shared.Vertices",{inherits:[System.Collections.Generic.List$1(Microsoft.Xna.Framework.Vector2)],fields:{AttachedToBody:!1,Holes:null},ctors:{ctor:function(){this.$initialize();System.Collections.Generic.List$1(Microsoft.Xna.Framework.Vector2).ctor.call(this)},$ctor2:function(capacity){this.$initialize();System.Collections.Generic.List$1(Microsoft.Xna.Framework.Vector2).$ctor2.call(this,capacity)},$ctor1:function(vertices){this.$initialize();System.Collections.Generic.List$1(Microsoft.Xna.Framework.Vector2).ctor.call(this);this.AddRange(vertices)}},methods:{NextIndex:function(index){return(index+1|0)>(this.Count-1|0)?0:index+1|0},NextVertex:function(index){return this.getItem(this.NextIndex(index)).$clone()},PreviousIndex:function(index){return(index-1|0)<0?this.Count-1|0:index-1|0},PreviousVertex:function(index){return this.getItem(this.PreviousIndex(index)).$clone()},GetSignedArea:function(){var i,area;if(this.Count<3)return 0;for(area=0,i=0;i<this.Count;i=i+1|0){var j=(i+1|0)%this.Count,vi=this.getItem(i).$clone(),vj=this.getItem(j).$clone();area+=vi.X*vj.Y;area-=vi.Y*vj.X}return area/2},GetArea:function(){var area=this.GetSignedArea();return area<0?-area:area},GetCentroid:function(){var i;if(this.Count<3)return new Microsoft.Xna.Framework.Vector2.$ctor2(Number.NaN,Number.NaN);var c=Microsoft.Xna.Framework.Vector2.Zero.$clone(),area=0,inv3=.333333343;for(i=0;i<this.Count;i=i+1|0){var current=this.getItem(i).$clone(),next=(i+1|0)<this.Count?this.getItem(i+1|0).$clone():this.getItem(0).$clone(),triangleArea=.5*(current.X*next.Y-current.Y*next.X);area+=triangleArea;c=Microsoft.Xna.Framework.Vector2.op_Addition(c.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(triangleArea*inv3,Microsoft.Xna.Framework.Vector2.op_Addition(current.$clone(),next.$clone())))}return c=Microsoft.Xna.Framework.Vector2.op_Multiply$1(c.$clone(),1/area),c.$clone()},GetAABB:function(){for(var aabb=new VelcroPhysics.Shared.AABB,lowerBound=new Microsoft.Xna.Framework.Vector2.$ctor2(340282347e30,340282347e30),upperBound=new Microsoft.Xna.Framework.Vector2.$ctor2(-340282347e30,-340282347e30),i=0;i<this.Count;i=i+1|0)this.getItem(i).$clone().X<lowerBound.X&&(lowerBound.X=this.getItem(i).$clone().X),this.getItem(i).$clone().X>upperBound.X&&(upperBound.X=this.getItem(i).$clone().X),this.getItem(i).$clone().Y<lowerBound.Y&&(lowerBound.Y=this.getItem(i).$clone().Y),this.getItem(i).$clone().Y>upperBound.Y&&(upperBound.Y=this.getItem(i).$clone().Y);return aabb.LowerBound=lowerBound.$clone(),aabb.UpperBound=upperBound.$clone(),aabb.$clone()},Translate:function(value){value={v:value};this.Translate$1(value)},Translate$1:function(value){var $t,i,hole;for(System.Diagnostics.Debug.Assert$1(!this.AttachedToBody,"Translating vertices that are used by a Body can result in unstable behavior. Use Body.Position instead."),i=0;i<this.Count;i=i+1|0)this.setItem(i,Microsoft.Xna.Framework.Vector2.Add(this.getItem(i).$clone(),value.v.$clone()));if(this.Holes!=null&&this.Holes.Count>0){$t=Bridge.getEnumerator(this.Holes);try{while($t.moveNext())hole=$t.Current,hole.Translate$1(value)}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}}},Scale:function(value){value={v:value};this.Scale$1(value)},Scale$1:function(value){var $t,i,hole;for(System.Diagnostics.Debug.Assert$1(!this.AttachedToBody,"Scaling vertices that are used by a Body can result in unstable behavior."),i=0;i<this.Count;i=i+1|0)this.setItem(i,Microsoft.Xna.Framework.Vector2.Multiply(this.getItem(i).$clone(),value.v.$clone()));if(this.Holes!=null&&this.Holes.Count>0){$t=Bridge.getEnumerator(this.Holes);try{while($t.moveNext())hole=$t.Current,hole.Scale$1(value)}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}}},Rotate:function(value){var $t,num1,num2,i,position,hole;for(System.Diagnostics.Debug.Assert$1(!this.AttachedToBody,"Rotating vertices that are used by a Body can result in unstable behavior."),num1=Math.cos(value),num2=Math.sin(value),i=0;i<this.Count;i=i+1|0)position=this.getItem(i).$clone(),this.setItem(i,new Microsoft.Xna.Framework.Vector2.$ctor2(position.X*num1+position.Y*-num2,position.X*num2+position.Y*num1));if(this.Holes!=null&&this.Holes.Count>0){$t=Bridge.getEnumerator(this.Holes);try{while($t.moveNext())hole=$t.Current,hole.Rotate(value)}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}}},IsConvex:function(){var i,next,edge,j,r,s;if(this.Count<3)return!1;if(this.Count===3)return!0;for(i=0;i<this.Count;i=i+1|0)for(next=(i+1|0)<this.Count?i+1|0:0,edge=Microsoft.Xna.Framework.Vector2.op_Subtraction(this.getItem(next).$clone(),this.getItem(i).$clone()),j=0;j<this.Count;j=j+1|0)if(j!==i&&j!==next&&(r=Microsoft.Xna.Framework.Vector2.op_Subtraction(this.getItem(j).$clone(),this.getItem(i).$clone()),s=edge.X*r.Y-edge.Y*r.X,s<=0))return!1;return!0},IsCounterClockWise:function(){return this.Count<3?!1:this.GetSignedArea()>0},ForceCounterClockWise:function(){this.Count<3||this.IsCounterClockWise()||this.Reverse()},IsSimple:function(){var i,a1,a2,j;if(this.Count<3)return!1;for(i=0;i<this.Count;i=i+1|0)for(a1={v:this.getItem(i).$clone()},a2={v:this.NextVertex(i)},j=i+1|0;j<this.Count;j=j+1|0){var b1={v:this.getItem(j).$clone()},b2={v:this.NextVertex(j)},temp={v:new Microsoft.Xna.Framework.Vector2};if(VelcroPhysics.Utilities.LineUtils.LineIntersect2(a1,a2,b1,b2,temp))return!1}return!0},CheckPolygon:function(){var i,next,edge;if(!this.IsSimple())return VelcroPhysics.Shared.PolygonError.NotSimple;if(this.GetArea()<=1401298e-51)return VelcroPhysics.Shared.PolygonError.AreaTooSmall;if(!this.IsConvex())return VelcroPhysics.Shared.PolygonError.NotConvex;for(i=0;i<this.Count;i=i+1|0)if(next=(i+1|0)<this.Count?i+1|0:0,edge=Microsoft.Xna.Framework.Vector2.op_Subtraction(this.getItem(next).$clone(),this.getItem(i).$clone()),edge.LengthSquared()<=0)return VelcroPhysics.Shared.PolygonError.SideTooSmall;return this.IsCounterClockWise()?VelcroPhysics.Shared.PolygonError.NoError:VelcroPhysics.Shared.PolygonError.NotCounterClockWise},ProjectToAxis:function(axis,min,max){var dotProduct=Microsoft.Xna.Framework.Vector2.Dot(axis.v.$clone(),this.getItem(0).$clone()),i;for(min.v=dotProduct,max.v=dotProduct,i=0;i<this.Count;i=i+1|0)dotProduct=Microsoft.Xna.Framework.Vector2.Dot(this.getItem(i).$clone(),axis.v.$clone()),dotProduct<min.v?min.v=dotProduct:dotProduct>max.v&&(max.v=dotProduct)},PointInPolygon:function(point){for(var wn=0,i=0;i<this.Count;i=i+1|0){var p1={v:this.getItem(i).$clone()},p2={v:this.getItem(this.NextIndex(i)).$clone()},edge=Microsoft.Xna.Framework.Vector2.op_Subtraction(p2.v.$clone(),p1.v.$clone()),area=VelcroPhysics.Utilities.MathUtils.Area$1(p1,p2,point);if(area===0&&Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(point.v.$clone(),p1.v.$clone()),edge.$clone())>=0&&Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(point.v.$clone(),p2.v.$clone()),edge.$clone())<=0)return 0;p1.v.Y<=point.v.Y?p2.v.Y>point.v.Y&&area>0&&(wn=wn+1|0):p2.v.Y<=point.v.Y&&area<0&&(wn=wn-1|0)}return wn===0?-1:1},PointInPolygonAngle:function(point){for(var p1,p2,angle=0,i=0;i<this.Count;i=i+1|0)p1={v:Microsoft.Xna.Framework.Vector2.op_Subtraction(this.getItem(i).$clone(),point.v.$clone())},p2={v:Microsoft.Xna.Framework.Vector2.op_Subtraction(this.getItem(this.NextIndex(i)).$clone(),point.v.$clone())},angle+=VelcroPhysics.Utilities.MathUtils.VectorAngle$1(p1,p2);return Math.abs(angle)<Math.PI?!1:!0},Transform:function(transform){for(var i1,temp,i=0;i<this.Count;i=i+1|0)this.setItem(i,Microsoft.Xna.Framework.Vector2.Transform(this.getItem(i).$clone(),transform.v.$clone()));if(this.Holes!=null&&this.Holes.Count>0)for(i1=0;i1<this.Holes.Count;i1=i1+1|0)temp=this.Holes.getItem(i1).ToArray(),Microsoft.Xna.Framework.Vector2.Transform$4(temp,transform,temp),this.Holes.setItem(i1,new VelcroPhysics.Shared.Vertices.$ctor1(temp))},toString:function(){for(var builder=new System.Text.StringBuilder,i=0;i<this.Count;i=i+1|0)builder.append(this.getItem(i).$clone()),i<(this.Count-1|0)&&builder.append(" ");return builder.toString()}}});Bridge.define("VelcroPhysics.Templates.IDefaults",{$kind:"interface"});Bridge.define("VelcroPhysics.Templates.Shapes.ShapeTemplate",{fields:{Density:0,Radius:0,ShapeType:0},ctors:{ctor:function(type){this.$initialize();this.ShapeType=type}}});Bridge.define("VelcroPhysics.Tools.ConvexHull.ChainHull.ChainHull",{statics:{fields:{_pointComparer:null},ctors:{init:function(){this._pointComparer=new VelcroPhysics.Tools.ConvexHull.ChainHull.ChainHull.PointComparer}},methods:{GetConvexHull:function(vertices){var pointSet,minmax,j,maxmax,xmax,maxmin,bot,j1;if(vertices.Count<=3)return vertices;pointSet=new VelcroPhysics.Shared.Vertices.$ctor1(vertices);pointSet.Sort$1(VelcroPhysics.Tools.ConvexHull.ChainHull.ChainHull._pointComparer);for(var h=System.Array.init(pointSet.Count,function(){return new Microsoft.Xna.Framework.Vector2},Microsoft.Xna.Framework.Vector2),res,top=-1,minmin=0,xmin=pointSet.getItem(0).$clone().X,i=1;i<pointSet.Count;i=i+1|0)if(pointSet.getItem(i).$clone().X!==xmin)break;if(minmax=i-1|0,minmax===(pointSet.Count-1|0)){for(h[top=top+1|0]=pointSet.getItem(minmin).$clone(),pointSet.getItem(minmax).$clone().Y!==pointSet.getItem(minmin).$clone().Y&&(h[top=top+1|0]=pointSet.getItem(minmax).$clone()),h[top=top+1|0]=pointSet.getItem(minmin).$clone(),res=new VelcroPhysics.Shared.Vertices.$ctor2(top+1|0),j=0;j<(top+1|0);j=j+1|0)res.add(h[j].$clone());return res}for(top=-1,maxmax=pointSet.Count-1|0,xmax=pointSet.getItem(pointSet.Count-1|0).$clone().X,i=pointSet.Count-2|0;i>=0;i=i-1|0)if(pointSet.getItem(i).$clone().X!==xmax)break;for(maxmin=i+1|0,h[top=top+1|0]=pointSet.getItem(minmin).$clone(),i=minmax;(i=i+1|0)<=maxmin;)if(!(VelcroPhysics.Utilities.MathUtils.Area(pointSet.getItem(minmin).$clone(),pointSet.getItem(maxmin).$clone(),pointSet.getItem(i).$clone())>=0)||!(i<maxmin)){while(top>0){if(VelcroPhysics.Utilities.MathUtils.Area(h[top-1|0].$clone(),h[top].$clone(),pointSet.getItem(i).$clone())>0)break;top=top-1|0}h[top=top+1|0]=pointSet.getItem(i).$clone()}for(maxmax!==maxmin&&(h[top=top+1|0]=pointSet.getItem(maxmax).$clone()),bot=top,i=maxmin;(i=i-1|0)>=minmax;)if(!(VelcroPhysics.Utilities.MathUtils.Area(pointSet.getItem(maxmax).$clone(),pointSet.getItem(minmax).$clone(),pointSet.getItem(i).$clone())>=0)||!(i>minmax)){while(top>bot){if(VelcroPhysics.Utilities.MathUtils.Area(h[top-1|0].$clone(),h[top].$clone(),pointSet.getItem(i).$clone())>0)break;top=top-1|0}h[top=top+1|0]=pointSet.getItem(i).$clone()}for(minmax!==minmin&&(h[top=top+1|0]=pointSet.getItem(minmin).$clone()),res=new VelcroPhysics.Shared.Vertices.$ctor2(top+1|0),j1=0;j1<(top+1|0);j1=j1+1|0)res.add(h[j1].$clone());return res}}}});Bridge.define("VelcroPhysics.Tools.ConvexHull.ChainHull.ChainHull.PointComparer",{inherits:[System.Collections.Generic.Comparer$1(Microsoft.Xna.Framework.Vector2)],$kind:"nested class",alias:["compare",["System$Collections$Generic$IComparer$1$Microsoft$Xna$Framework$Vector2$compare","System$Collections$Generic$IComparer$1$compare"]],methods:{compare:function(a,b){var f=Bridge.compare(a.X,b.X);return f!==0?f:Bridge.compare(a.Y,b.Y)}}});Bridge.define("VelcroPhysics.Tools.ConvexHull.GiftWrap.GiftWrap",{statics:{methods:{GetConvexHull:function(vertices){var i0,x0,i,x,ie,j,result,i1;if(vertices.Count<=3)return vertices;for(i0=0,x0=vertices.getItem(0).$clone().X,i=1;i<vertices.Count;i=i+1|0)x=vertices.getItem(i).$clone().X,(x>x0||x===x0&&vertices.getItem(i).$clone().Y<vertices.getItem(i0).$clone().Y)&&(i0=i,x0=x);for(var hull=System.Array.init(new Int32Array(vertices.Count),System.Int32),m=0,ih=i0;;){for(hull[m]=ih,ie=0,j=1;j<vertices.Count;j=j+1|0){if(ie===ih){ie=j;continue}var r={v:Microsoft.Xna.Framework.Vector2.op_Subtraction(vertices.getItem(ie).$clone(),vertices.getItem(hull[m]).$clone())},v={v:Microsoft.Xna.Framework.Vector2.op_Subtraction(vertices.getItem(j).$clone(),vertices.getItem(hull[m]).$clone())},c=VelcroPhysics.Utilities.MathUtils.Cross$4(r,v);c<0&&(ie=j);c===0&&v.v.LengthSquared()>r.v.LengthSquared()&&(ie=j)}if(m=m+1|0,ih=ie,ie===i0)break}for(result=new VelcroPhysics.Shared.Vertices.$ctor2(m),i1=0;i1<m;i1=i1+1|0)result.add(vertices.getItem(hull[i1]).$clone());return result}}}});Bridge.define("VelcroPhysics.Tools.ConvexHull.Melkman.Melkman",{statics:{methods:{GetConvexHull:function(vertices){var $t,tmp,qfm1,qbm1,i,nextPt,convexHull,i1,convexHull1,i2,i3;if(vertices.Count<=3)return vertices;var deque=System.Array.init(vertices.Count+1|0,function(){return new Microsoft.Xna.Framework.Vector2},Microsoft.Xna.Framework.Vector2),qf=3,qb=0,startIndex=3,k=VelcroPhysics.Utilities.MathUtils.Area(vertices.getItem(0).$clone(),vertices.getItem(1).$clone(),vertices.getItem(2).$clone());if(k===0)for(deque[0]=vertices.getItem(0).$clone(),deque[1]=vertices.getItem(2).$clone(),deque[2]=vertices.getItem(0).$clone(),qf=2,startIndex=3;startIndex<vertices.Count;startIndex=startIndex+1|0)if(tmp={v:vertices.getItem(startIndex).$clone()},VelcroPhysics.Utilities.MathUtils.Area$1(Bridge.ref(deque,0),Bridge.ref(deque,1),tmp)===0)deque[1]=vertices.getItem(startIndex).$clone();else break;else deque[0]=($t=vertices.getItem(2).$clone(),deque[3]=$t.$clone(),$t),k>0?(deque[1]=vertices.getItem(0).$clone(),deque[2]=vertices.getItem(1).$clone()):(deque[1]=vertices.getItem(1).$clone(),deque[2]=vertices.getItem(0).$clone());for(qfm1=qf===0?deque.length-1|0:qf-1|0,qbm1=qb===(deque.length-1|0)?0:qb+1|0,i=startIndex;i<vertices.Count;i=i+1|0)if(nextPt={v:vertices.getItem(i).$clone()},!(VelcroPhysics.Utilities.MathUtils.Area$1(Bridge.ref(deque,qfm1),Bridge.ref(deque,qf),nextPt)>0)||!(VelcroPhysics.Utilities.MathUtils.Area$1(Bridge.ref(deque,qb),Bridge.ref(deque,qbm1),nextPt)>0)){while(!(VelcroPhysics.Utilities.MathUtils.Area$1(Bridge.ref(deque,qfm1),Bridge.ref(deque,qf),nextPt)>0))qf=qfm1,qfm1=qf===0?deque.length-1|0:qf-1|0;for(qf=qf===(deque.length-1|0)?0:qf+1|0,qfm1=qf===0?deque.length-1|0:qf-1|0,deque[qf]=nextPt.v.$clone();!(VelcroPhysics.Utilities.MathUtils.Area$1(Bridge.ref(deque,qb),Bridge.ref(deque,qbm1),nextPt)>0);)qb=qbm1,qbm1=qb===(deque.length-1|0)?0:qb+1|0;qb=qb===0?deque.length-1|0:qb-1|0;qbm1=qb===(deque.length-1|0)?0:qb+1|0;deque[qb]=nextPt.v.$clone()}if(qb<qf){for(convexHull=new VelcroPhysics.Shared.Vertices.$ctor2(qf),i1=qb;i1<qf;i1=i1+1|0)convexHull.add(deque[i1].$clone());return convexHull}else{for(convexHull1=new VelcroPhysics.Shared.Vertices.$ctor2(qf+deque.length|0),i2=0;i2<qf;i2=i2+1|0)convexHull1.add(deque[i2].$clone());for(i3=qb;i3<deque.length;i3=i3+1|0)convexHull1.add(deque[i3].$clone());return convexHull1}}}}});Bridge.define("VelcroPhysics.Tools.Cutting.Simple.CuttingTools",{statics:{methods:{SplitShape:function(fixture,entryPoint,exitPoint,first,second){var $t,vertex,vertices,newPolygon,i,cutAdded,last,i1,n,n1,offset;entryPoint={v:entryPoint};exitPoint={v:exitPoint};var localEntryPoint=fixture.Body.GetLocalPoint$1(entryPoint),localExitPoint=fixture.Body.GetLocalPoint$1(exitPoint),shape=Bridge.as(fixture.Shape,VelcroPhysics.Collision.Shapes.PolygonShape);if(shape==null){first.v=new VelcroPhysics.Shared.Vertices.ctor;second.v=new VelcroPhysics.Shared.Vertices.ctor;return}$t=Bridge.getEnumerator(shape.Vertices);try{while($t.moveNext())vertex=$t.Current.$clone(),vertex.equalsT(localEntryPoint.$clone())&&(localEntryPoint=Microsoft.Xna.Framework.Vector2.op_Subtraction(localEntryPoint.$clone(),new Microsoft.Xna.Framework.Vector2.$ctor2(0,VelcroPhysics.Settings.Epsilon))),vertex.equalsT(localExitPoint.$clone())&&(localExitPoint=Microsoft.Xna.Framework.Vector2.op_Addition(localExitPoint.$clone(),new Microsoft.Xna.Framework.Vector2.$ctor2(0,VelcroPhysics.Settings.Epsilon)))}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}for(vertices=new VelcroPhysics.Shared.Vertices.$ctor1(shape.Vertices),newPolygon=System.Array.init(2,null,VelcroPhysics.Shared.Vertices),i=0;i<newPolygon.length;i=i+1|0)newPolygon[i]=new VelcroPhysics.Shared.Vertices.$ctor2(vertices.Count);for(cutAdded=System.Array.init([-1,-1],System.Int32),last=-1,i1=0;i1<vertices.Count;i1=i1+1|0)n=Microsoft.Xna.Framework.Vector2.Dot(VelcroPhysics.Utilities.MathUtils.Cross(Microsoft.Xna.Framework.Vector2.op_Subtraction(localExitPoint.$clone(),localEntryPoint.$clone()),1),Microsoft.Xna.Framework.Vector2.op_Subtraction(vertices.getItem(i1).$clone(),localEntryPoint.$clone()))>VelcroPhysics.Settings.Epsilon?0:1,last!==n&&(last===0&&(System.Diagnostics.Debug.Assert(cutAdded[0]===-1),cutAdded[0]=newPolygon[last].Count,newPolygon[last].add(localExitPoint.$clone()),newPolygon[last].add(localEntryPoint.$clone())),last===1&&(System.Diagnostics.Debug.Assert(cutAdded[last]===-1),cutAdded[last]=newPolygon[last].Count,newPolygon[last].add(localEntryPoint.$clone()),newPolygon[last].add(localExitPoint.$clone()))),newPolygon[n].add(vertices.getItem(i1).$clone()),last=n;for(cutAdded[0]===-1&&(cutAdded[0]=newPolygon[0].Count,newPolygon[0].add(localExitPoint.$clone()),newPolygon[0].add(localEntryPoint.$clone())),cutAdded[1]===-1&&(cutAdded[1]=newPolygon[1].Count,newPolygon[1].add(localEntryPoint.$clone()),newPolygon[1].add(localExitPoint.$clone())),n1=0;n1<2;n1=n1+1|0)offset=new Microsoft.Xna.Framework.Vector2,offset=cutAdded[n1]>0?Microsoft.Xna.Framework.Vector2.op_Subtraction(newPolygon[n1].getItem(cutAdded[n1]-1|0).$clone(),newPolygon[n1].getItem(cutAdded[n1]).$clone()):Microsoft.Xna.Framework.Vector2.op_Subtraction(newPolygon[n1].getItem(newPolygon[n1].Count-1|0).$clone(),newPolygon[n1].getItem(0).$clone()),offset.Normalize(),VelcroPhysics.Utilities.MathUtils.IsValid(offset)||(offset=Microsoft.Xna.Framework.Vector2.One.$clone()),newPolygon[n1].setItem(cutAdded[n1],Microsoft.Xna.Framework.Vector2.op_Addition(newPolygon[n1].getItem(cutAdded[n1]).$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(VelcroPhysics.Settings.Epsilon,offset.$clone()))),offset=cutAdded[n1]<(newPolygon[n1].Count-2|0)?Microsoft.Xna.Framework.Vector2.op_Subtraction(newPolygon[n1].getItem(cutAdded[n1]+2|0).$clone(),newPolygon[n1].getItem(cutAdded[n1]+1|0).$clone()):Microsoft.Xna.Framework.Vector2.op_Subtraction(newPolygon[n1].getItem(0).$clone(),newPolygon[n1].getItem(newPolygon[n1].Count-1|0).$clone()),offset.Normalize(),VelcroPhysics.Utilities.MathUtils.IsValid(offset)||(offset=Microsoft.Xna.Framework.Vector2.One.$clone()),newPolygon[n1].setItem(cutAdded[n1]+1|0,Microsoft.Xna.Framework.Vector2.op_Addition(newPolygon[n1].getItem(cutAdded[n1]+1|0).$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(VelcroPhysics.Settings.Epsilon,offset.$clone())));first.v=newPolygon[0];second.v=newPolygon[1]},Cut:function(world,start,end){var fixtures=new(System.Collections.Generic.List$1(VelcroPhysics.Dynamics.Fixture).ctor),entryPoints=new(System.Collections.Generic.List$1(Microsoft.Xna.Framework.Vector2).ctor),exitPoints=new(System.Collections.Generic.List$1(Microsoft.Xna.Framework.Vector2).ctor),i,first,second,firstFixture,secondFixture;if(world.TestPoint(start.$clone())!=null||world.TestPoint(end.$clone())!=null||(world.RayCast$1(function(f,p,n,fr){return fixtures.add(f),entryPoints.add(p.$clone()),1},start.$clone(),end.$clone()),world.RayCast$1(function(f,p,n,fr){return exitPoints.add(p.$clone()),1},end.$clone(),start.$clone()),(entryPoints.Count+exitPoints.Count|0)<2))return!1;for(i=0;i<fixtures.Count;i=i+1|0)fixtures.getItem(i).Shape.ShapeType===VelcroPhysics.Collision.Shapes.ShapeType.Polygon&&fixtures.getItem(i).Body.BodyType!==VelcroPhysics.Dynamics.BodyType.Static&&(first={},second={},VelcroPhysics.Tools.Cutting.Simple.CuttingTools.SplitShape(fixtures.getItem(i),entryPoints.getItem(i).$clone(),exitPoints.getItem(i).$clone(),first,second),first.v.CheckPolygon()===VelcroPhysics.Shared.PolygonError.NoError&&(firstFixture=VelcroPhysics.Factories.BodyFactory.CreatePolygon(world,first.v,fixtures.getItem(i).Shape.Density,fixtures.getItem(i).Body.Position.$clone()),firstFixture.Rotation=fixtures.getItem(i).Body.Rotation,firstFixture.LinearVelocity=fixtures.getItem(i).Body.LinearVelocity.$clone(),firstFixture.AngularVelocity=fixtures.getItem(i).Body.AngularVelocity,firstFixture.BodyType=VelcroPhysics.Dynamics.BodyType.Dynamic),second.v.CheckPolygon()===VelcroPhysics.Shared.PolygonError.NoError&&(secondFixture=VelcroPhysics.Factories.BodyFactory.CreatePolygon(world,second.v,fixtures.getItem(i).Shape.Density,fixtures.getItem(i).Body.Position.$clone()),secondFixture.Rotation=fixtures.getItem(i).Body.Rotation,secondFixture.LinearVelocity=fixtures.getItem(i).Body.LinearVelocity.$clone(),secondFixture.AngularVelocity=fixtures.getItem(i).Body.AngularVelocity,secondFixture.BodyType=VelcroPhysics.Dynamics.BodyType.Dynamic),world.RemoveBody(fixtures.getItem(i).Body));return!0}}}});Bridge.define("VelcroPhysics.Tools.Cutting.Simple.PolyClipError",{$kind:"enum",statics:{fields:{None:0,DegeneratedOutput:1,NonSimpleInput:2,BrokenResult:3}}});Bridge.define("VelcroPhysics.Tools.Cutting.Simple.PolyClipType",{$kind:"enum",statics:{fields:{Intersect:0,Union:1,Difference:2}}});Bridge.define("VelcroPhysics.Tools.Cutting.YuPengClipper",{statics:{fields:{ClipperEpsilonSquared:0},ctors:{init:function(){this.ClipperEpsilonSquared=11920929e-14}},methods:{Union:function(polygon1,polygon2,error){return VelcroPhysics.Tools.Cutting.YuPengClipper.Execute(polygon1,polygon2,VelcroPhysics.Tools.Cutting.Simple.PolyClipType.Union,error)},Difference:function(polygon1,polygon2,error){return VelcroPhysics.Tools.Cutting.YuPengClipper.Execute(polygon1,polygon2,VelcroPhysics.Tools.Cutting.Simple.PolyClipType.Difference,error)},Intersect:function(polygon1,polygon2,error){return VelcroPhysics.Tools.Cutting.YuPengClipper.Execute(polygon1,polygon2,VelcroPhysics.Tools.Cutting.Simple.PolyClipType.Intersect,error)},Execute:function(subject,clip,clipType,error){var slicedSubject,slicedClip,resultSimplices,result,i;System.Diagnostics.Debug.Assert$2(subject.IsSimple()&&clip.IsSimple(),"Non simple input!","Input polygons must be simple (cannot intersect themselves).");slicedSubject={};slicedClip={};VelcroPhysics.Tools.Cutting.YuPengClipper.CalculateIntersections(subject,clip,slicedSubject,slicedClip);var lbSubject={v:subject.GetAABB().LowerBound.$clone()},lbClip={v:clip.GetAABB().LowerBound.$clone()},translate={v:new Microsoft.Xna.Framework.Vector2};Microsoft.Xna.Framework.Vector2.Min$1(lbSubject,lbClip,translate);translate.v=Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.One.$clone(),translate.v.$clone());Microsoft.Xna.Framework.Vector2.op_Inequality(translate.v.$clone(),Microsoft.Xna.Framework.Vector2.Zero.$clone())&&(slicedSubject.v.Translate$1(translate),slicedClip.v.Translate$1(translate));slicedSubject.v.ForceCounterClockWise();slicedClip.v.ForceCounterClockWise();var subjectSimplices={},subjectCoeff={},clipSimplices={},clipCoeff={};for(VelcroPhysics.Tools.Cutting.YuPengClipper.CalculateSimplicalChain(slicedSubject.v,subjectCoeff,subjectSimplices),VelcroPhysics.Tools.Cutting.YuPengClipper.CalculateSimplicalChain(slicedClip.v,clipCoeff,clipSimplices),resultSimplices={},VelcroPhysics.Tools.Cutting.YuPengClipper.CalculateResultChain(subjectCoeff.v,subjectSimplices.v,clipCoeff.v,clipSimplices.v,clipType,resultSimplices),result={},error.v=VelcroPhysics.Tools.Cutting.YuPengClipper.BuildPolygonsFromChain(resultSimplices.v,result),translate.v=Microsoft.Xna.Framework.Vector2.op_Multiply$1(translate.v.$clone(),-1),i=0;i<result.v.Count;i=i+1|0)result.v.getItem(i).Translate$1(translate),VelcroPhysics.Tools.PolygonManipulation.SimplifyTools.CollinearSimplify(result.v.getItem(i));return result.v},CalculateIntersections:function(polygon1,polygon2,slicedPoly1,slicedPoly2){var i,a,b,j,alpha,index,index1,i1,iNext,i2,iNext1;for(slicedPoly1.v=new VelcroPhysics.Shared.Vertices.$ctor1(polygon1),slicedPoly2.v=new VelcroPhysics.Shared.Vertices.$ctor1(polygon2),i=0;i<polygon1.Count;i=i+1|0)for(a=polygon1.getItem(i).$clone(),b=polygon1.getItem(polygon1.NextIndex(i)).$clone(),j=0;j<polygon2.Count;j=j+1|0){var c=polygon2.getItem(j).$clone(),d=polygon2.getItem(polygon2.NextIndex(j)).$clone(),intersectionPoint={v:new Microsoft.Xna.Framework.Vector2};if(VelcroPhysics.Utilities.LineUtils.LineIntersect$1(a.$clone(),b.$clone(),c.$clone(),d.$clone(),intersectionPoint)){if(alpha=VelcroPhysics.Tools.Cutting.YuPengClipper.GetAlpha(a.$clone(),b.$clone(),intersectionPoint.v.$clone()),alpha>0&&alpha<1){for(index=slicedPoly1.v.indexOf(a.$clone())+1|0;index<slicedPoly1.v.Count&&VelcroPhysics.Tools.Cutting.YuPengClipper.GetAlpha(a.$clone(),b.$clone(),slicedPoly1.v.getItem(index).$clone())<=alpha;)index=index+1|0;slicedPoly1.v.insert(index,intersectionPoint.v.$clone())}if(alpha=VelcroPhysics.Tools.Cutting.YuPengClipper.GetAlpha(c.$clone(),d.$clone(),intersectionPoint.v.$clone()),alpha>0&&alpha<1){for(index1=slicedPoly2.v.indexOf(c.$clone())+1|0;index1<slicedPoly2.v.Count&&VelcroPhysics.Tools.Cutting.YuPengClipper.GetAlpha(c.$clone(),d.$clone(),slicedPoly2.v.getItem(index1).$clone())<=alpha;)index1=index1+1|0;slicedPoly2.v.insert(index1,intersectionPoint.v.$clone())}}}for(i1=0;i1<slicedPoly1.v.Count;i1=i1+1|0)iNext=slicedPoly1.v.NextIndex(i1),Microsoft.Xna.Framework.Vector2.op_Subtraction(slicedPoly1.v.getItem(iNext).$clone(),slicedPoly1.v.getItem(i1).$clone()).LengthSquared()<=VelcroPhysics.Tools.Cutting.YuPengClipper.ClipperEpsilonSquared&&(slicedPoly1.v.removeAt(i1),i1=i1-1|0);for(i2=0;i2<slicedPoly2.v.Count;i2=i2+1|0)iNext1=slicedPoly2.v.NextIndex(i2),Microsoft.Xna.Framework.Vector2.op_Subtraction(slicedPoly2.v.getItem(iNext1).$clone(),slicedPoly2.v.getItem(i2).$clone()).LengthSquared()<=VelcroPhysics.Tools.Cutting.YuPengClipper.ClipperEpsilonSquared&&(slicedPoly2.v.removeAt(i2),i2=i2-1|0)},CalculateSimplicalChain:function(poly,coeff,simplicies){simplicies.v=new(System.Collections.Generic.List$1(VelcroPhysics.Tools.Cutting.YuPengClipper.Edge).ctor);coeff.v=new(System.Collections.Generic.List$1(System.Single).ctor);for(var i=0;i<poly.Count;i=i+1|0)simplicies.v.add(new VelcroPhysics.Tools.Cutting.YuPengClipper.Edge(poly.getItem(i).$clone(),poly.getItem(poly.NextIndex(i)).$clone())),coeff.v.add(VelcroPhysics.Tools.Cutting.YuPengClipper.CalculateSimplexCoefficient(Microsoft.Xna.Framework.Vector2.Zero.$clone(),poly.getItem(i).$clone(),poly.getItem(poly.NextIndex(i)).$clone()))},CalculateResultChain:function(poly1Coeff,poly1Simplicies,poly2Coeff,poly2Simplicies,clipType,resultSimplices){var i,edgeCharacter,j,i1,edgeCharacter1,j1;for(resultSimplices.v=new(System.Collections.Generic.List$1(VelcroPhysics.Tools.Cutting.YuPengClipper.Edge).ctor),i=0;i<poly1Simplicies.Count;i=i+1|0){if(edgeCharacter=0,poly2Simplicies.contains(poly1Simplicies.getItem(i)))edgeCharacter=1;else if(poly2Simplicies.contains(VelcroPhysics.Tools.Cutting.YuPengClipper.Edge.op_UnaryNegation(poly1Simplicies.getItem(i)))&&clipType===VelcroPhysics.Tools.Cutting.Simple.PolyClipType.Union)edgeCharacter=1;else for(j=0;j<poly2Simplicies.Count;j=j+1|0)poly2Simplicies.contains(VelcroPhysics.Tools.Cutting.YuPengClipper.Edge.op_UnaryNegation(poly1Simplicies.getItem(i)))||(edgeCharacter+=VelcroPhysics.Tools.Cutting.YuPengClipper.CalculateBeta(poly1Simplicies.getItem(i).GetCenter(),poly2Simplicies.getItem(j),poly2Coeff.getItem(j)));clipType===VelcroPhysics.Tools.Cutting.Simple.PolyClipType.Intersect?edgeCharacter===1&&resultSimplices.v.add(poly1Simplicies.getItem(i)):edgeCharacter===0&&resultSimplices.v.add(poly1Simplicies.getItem(i))}for(i1=0;i1<poly2Simplicies.Count;i1=i1+1|0)if(edgeCharacter1=0,!resultSimplices.v.contains(poly2Simplicies.getItem(i1))&&!resultSimplices.v.contains(VelcroPhysics.Tools.Cutting.YuPengClipper.Edge.op_UnaryNegation(poly2Simplicies.getItem(i1))))if(poly1Simplicies.contains(VelcroPhysics.Tools.Cutting.YuPengClipper.Edge.op_UnaryNegation(poly2Simplicies.getItem(i1)))&&clipType===VelcroPhysics.Tools.Cutting.Simple.PolyClipType.Union)edgeCharacter1=1;else{for(edgeCharacter1=0,j1=0;j1<poly1Simplicies.Count;j1=j1+1|0)poly1Simplicies.contains(poly2Simplicies.getItem(i1))||poly1Simplicies.contains(VelcroPhysics.Tools.Cutting.YuPengClipper.Edge.op_UnaryNegation(poly2Simplicies.getItem(i1)))||(edgeCharacter1+=VelcroPhysics.Tools.Cutting.YuPengClipper.CalculateBeta(poly2Simplicies.getItem(i1).GetCenter(),poly1Simplicies.getItem(j1),poly1Coeff.getItem(j1)));clipType===VelcroPhysics.Tools.Cutting.Simple.PolyClipType.Intersect||clipType===VelcroPhysics.Tools.Cutting.Simple.PolyClipType.Difference?edgeCharacter1===1&&resultSimplices.v.add(VelcroPhysics.Tools.Cutting.YuPengClipper.Edge.op_UnaryNegation(poly2Simplicies.getItem(i1))):edgeCharacter1===0&&resultSimplices.v.add(poly2Simplicies.getItem(i1))}},BuildPolygonsFromChain:function(simplicies,result){var errVal,output;for(result.v=new(System.Collections.Generic.List$1(VelcroPhysics.Shared.Vertices).ctor),errVal=VelcroPhysics.Tools.Cutting.Simple.PolyClipError.None;simplicies.Count>0;){output=new VelcroPhysics.Shared.Vertices.ctor;output.add(simplicies.getItem(0).EdgeStart.$clone());output.add(simplicies.getItem(0).EdgeEnd.$clone());simplicies.removeAt(0);for(var closed=!1,index=0,count=simplicies.Count;!closed&&simplicies.Count>0;)if(VelcroPhysics.Tools.Cutting.YuPengClipper.VectorEqual(output.getItem(output.Count-1|0).$clone(),simplicies.getItem(index).EdgeStart.$clone())?(VelcroPhysics.Tools.Cutting.YuPengClipper.VectorEqual(simplicies.getItem(index).EdgeEnd.$clone(),output.getItem(0).$clone())?closed=!0:output.add(simplicies.getItem(index).EdgeEnd.$clone()),simplicies.removeAt(index),index=index-1|0):VelcroPhysics.Tools.Cutting.YuPengClipper.VectorEqual(output.getItem(output.Count-1|0).$clone(),simplicies.getItem(index).EdgeEnd.$clone())&&(VelcroPhysics.Tools.Cutting.YuPengClipper.VectorEqual(simplicies.getItem(index).EdgeStart.$clone(),output.getItem(0).$clone())?closed=!0:output.add(simplicies.getItem(index).EdgeStart.$clone()),simplicies.removeAt(index),index=index-1|0),!closed&&(index=index+1|0)===simplicies.Count){if(count===simplicies.Count)return result.v=new(System.Collections.Generic.List$1(VelcroPhysics.Shared.Vertices).ctor),System.Diagnostics.Debug.WriteLine$2("Undefined error while building result polygon(s)."),VelcroPhysics.Tools.Cutting.Simple.PolyClipError.BrokenResult;index=0;count=simplicies.Count}output.Count<3&&(errVal=VelcroPhysics.Tools.Cutting.Simple.PolyClipError.DegeneratedOutput,System.Diagnostics.Debug.WriteLine$2("Degenerated output polygon produced (vertices < 3)."));result.v.add(output)}return errVal},CalculateBeta:function(point,e,coefficient){var result=0;return VelcroPhysics.Tools.Cutting.YuPengClipper.PointInSimplex(point.$clone(),e)&&(result=coefficient),(VelcroPhysics.Tools.Cutting.YuPengClipper.PointOnLineSegment(Microsoft.Xna.Framework.Vector2.Zero.$clone(),e.EdgeStart.$clone(),point.$clone())||VelcroPhysics.Tools.Cutting.YuPengClipper.PointOnLineSegment(Microsoft.Xna.Framework.Vector2.Zero.$clone(),e.EdgeEnd.$clone(),point.$clone()))&&(result=.5*coefficient),result},GetAlpha:function(start,end,point){return Microsoft.Xna.Framework.Vector2.op_Subtraction(point.$clone(),start.$clone()).LengthSquared()/Microsoft.Xna.Framework.Vector2.op_Subtraction(end.$clone(),start.$clone()).LengthSquared()},CalculateSimplexCoefficient:function(a,b,c){a={v:a};b={v:b};c={v:c};var isLeft=VelcroPhysics.Utilities.MathUtils.Area$1(a,b,c);return isLeft<0?-1:isLeft>0?1:0},PointInSimplex:function(point,edge){point={v:point};var polygon=new VelcroPhysics.Shared.Vertices.ctor;return polygon.add(Microsoft.Xna.Framework.Vector2.Zero.$clone()),polygon.add(edge.EdgeStart.$clone()),polygon.add(edge.EdgeEnd.$clone()),polygon.PointInPolygon(point)===1},PointOnLineSegment:function(start,end,point){start={v:start};end={v:end};point={v:point};var segment=Microsoft.Xna.Framework.Vector2.op_Subtraction(end.v.$clone(),start.v.$clone());return VelcroPhysics.Utilities.MathUtils.Area$1(start,end,point)===0&&Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(point.v.$clone(),start.v.$clone()),segment.$clone())>=0&&Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(point.v.$clone(),end.v.$clone()),segment.$clone())<=0},VectorEqual:function(vec1,vec2){return Microsoft.Xna.Framework.Vector2.op_Subtraction(vec2.$clone(),vec1.$clone()).LengthSquared()<=VelcroPhysics.Tools.Cutting.YuPengClipper.ClipperEpsilonSquared}}}});Bridge.define("VelcroPhysics.Tools.Cutting.YuPengClipper.Edge",{$kind:"nested class",statics:{methods:{op_UnaryNegation:function(e){return new VelcroPhysics.Tools.Cutting.YuPengClipper.Edge(e.EdgeEnd.$clone(),e.EdgeStart.$clone())}}},fields:{EdgeStart:null,EdgeEnd:null},ctors:{init:function(){this.EdgeStart=new Microsoft.Xna.Framework.Vector2;this.EdgeEnd=new Microsoft.Xna.Framework.Vector2},ctor:function(edgeStart,edgeEnd){this.$initialize();this.EdgeStart=edgeStart.$clone();this.EdgeEnd=edgeEnd.$clone()}},methods:{GetCenter:function(){return Microsoft.Xna.Framework.Vector2.op_Division$1(Microsoft.Xna.Framework.Vector2.op_Addition(this.EdgeStart.$clone(),this.EdgeEnd.$clone()),2)},equals:function(obj){return obj==null?!1:this.Equals(Bridge.as(obj,VelcroPhysics.Tools.Cutting.YuPengClipper.Edge))},Equals:function(e){return e==null?!1:VelcroPhysics.Tools.Cutting.YuPengClipper.VectorEqual(this.EdgeStart.$clone(),e.EdgeStart.$clone())&&VelcroPhysics.Tools.Cutting.YuPengClipper.VectorEqual(this.EdgeEnd.$clone(),e.EdgeEnd.$clone())},getHashCode:function(){return this.EdgeStart.getHashCode()^this.EdgeEnd.getHashCode()}}});Bridge.define("VelcroPhysics.Tools.PathGenerator.LinkFactory",{statics:{methods:{CreateChain:function(world,start,end,linkWidth,linkHeight,numberOfLinks,linkDensity,attachRopeJoint){var path,shape,chainLinks;return System.Diagnostics.Debug.Assert(numberOfLinks>=2),path=new VelcroPhysics.Tools.PathGenerator.Path.ctor,path.Add(start.$clone()),path.Add(end.$clone()),shape=new VelcroPhysics.Collision.Shapes.PolygonShape.$ctor2(VelcroPhysics.Utilities.PolygonUtils.CreateRectangle(linkWidth,linkHeight),linkDensity),chainLinks=VelcroPhysics.Tools.PathGenerator.PathManager.EvenlyDistributeShapesAlongPath$1(world,path,shape,VelcroPhysics.Dynamics.BodyType.Dynamic,numberOfLinks),VelcroPhysics.Tools.PathGenerator.PathManager.AttachBodiesWithRevoluteJoint(world,chainLinks,new Microsoft.Xna.Framework.Vector2.$ctor2(0,-linkHeight),new Microsoft.Xna.Framework.Vector2.$ctor2(0,linkHeight),!1,!1),attachRopeJoint&&VelcroPhysics.Factories.JointFactory.CreateRopeJoint(world,chainLinks.getItem(0),chainLinks.getItem(chainLinks.Count-1|0),Microsoft.Xna.Framework.Vector2.Zero.$clone(),Microsoft.Xna.Framework.Vector2.Zero.$clone()),path}}}});Bridge.define("VelcroPhysics.Tools.PathGenerator.Path",{fields:{_deltaT:0,ControlPoints:null,Closed:!1},ctors:{ctor:function(){this.$initialize();this.ControlPoints=new(System.Collections.Generic.List$1(Microsoft.Xna.Framework.Vector2).ctor)},$ctor1:function(vertices){this.$initialize();this.ControlPoints=new(System.Collections.Generic.List$1(Microsoft.Xna.Framework.Vector2).$ctor2)(vertices.length);for(var i=0;i<vertices.length;i=i+1|0)this.Add(vertices[i].$clone())},$ctor2:function(vertices){this.$initialize();this.ControlPoints=new(System.Collections.Generic.List$1(Microsoft.Xna.Framework.Vector2).$ctor2)(System.Array.getCount(vertices,Microsoft.Xna.Framework.Vector2));for(var i=0;i<System.Array.getCount(vertices,Microsoft.Xna.Framework.Vector2);i=i+1|0)this.Add(System.Array.getItem(vertices,i,Microsoft.Xna.Framework.Vector2).$clone())}},methods:{NextIndex:function(index){return index===(this.ControlPoints.Count-1|0)?0:index+1|0},PreviousIndex:function(index){return index===0?this.ControlPoints.Count-1|0:index-1|0},Translate:function(vector){for(var i=0;i<this.ControlPoints.Count;i=i+1|0)this.ControlPoints.setItem(i,Microsoft.Xna.Framework.Vector2.Add(this.ControlPoints.getItem(i).$clone(),vector.v.$clone()))},Scale:function(value){for(var i=0;i<this.ControlPoints.Count;i=i+1|0)this.ControlPoints.setItem(i,Microsoft.Xna.Framework.Vector2.Multiply(this.ControlPoints.getItem(i).$clone(),value.v.$clone()))},Rotate:function(value){var rotationMatrix={v:new Microsoft.Xna.Framework.Matrix},i;for(Microsoft.Xna.Framework.Matrix.CreateRotationZ$1(value,rotationMatrix),i=0;i<this.ControlPoints.Count;i=i+1|0)this.ControlPoints.setItem(i,Microsoft.Xna.Framework.Vector2.Transform(this.ControlPoints.getItem(i).$clone(),rotationMatrix.v.$clone()))},toString:function(){for(var builder=new System.Text.StringBuilder,i=0;i<this.ControlPoints.Count;i=i+1|0)builder.append(this.ControlPoints.getItem(i).$clone()),i<(this.ControlPoints.Count-1|0)&&builder.append(" ");return builder.toString()},GetVertices:function(divisions){for(var verts=new VelcroPhysics.Shared.Vertices.ctor,timeStep=1/divisions,i=0;i<1;i+=timeStep)verts.add(this.GetPosition(i));return verts},GetPosition:function(time){var temp=new Microsoft.Xna.Framework.Vector2,p,p0,p1,p2,p3,lt,p4,p01,p11,p21,p31,lt1;if(this.ControlPoints.Count<2)throw new System.Exception("You need at least 2 control points to calculate a position.");return this.Closed?(this.Add(this.ControlPoints.getItem(0).$clone()),this._deltaT=1/(this.ControlPoints.Count-1|0),p=Bridge.Int.clip32(time/this._deltaT),p0=p-1|0,p0<0?p0=p0+(this.ControlPoints.Count-1|0)|0:p0>=(this.ControlPoints.Count-1|0)&&(p0=p0-(this.ControlPoints.Count-1|0)|0),p1=p,p1<0?p1=p1+(this.ControlPoints.Count-1|0)|0:p1>=(this.ControlPoints.Count-1|0)&&(p1=p1-(this.ControlPoints.Count-1|0)|0),p2=p+1|0,p2<0?p2=p2+(this.ControlPoints.Count-1|0)|0:p2>=(this.ControlPoints.Count-1|0)&&(p2=p2-(this.ControlPoints.Count-1|0)|0),p3=p+2|0,p3<0?p3=p3+(this.ControlPoints.Count-1|0)|0:p3>=(this.ControlPoints.Count-1|0)&&(p3=p3-(this.ControlPoints.Count-1|0)|0),lt=(time-this._deltaT*p)/this._deltaT,temp=Microsoft.Xna.Framework.Vector2.CatmullRom(this.ControlPoints.getItem(p0).$clone(),this.ControlPoints.getItem(p1).$clone(),this.ControlPoints.getItem(p2).$clone(),this.ControlPoints.getItem(p3).$clone(),lt),this.RemoveAt(this.ControlPoints.Count-1|0)):(p4=Bridge.Int.clip32(time/this._deltaT),p01=p4-1|0,p01<0?p01=0:p01>=(this.ControlPoints.Count-1|0)&&(p01=this.ControlPoints.Count-1|0),p11=p4,p11<0?p11=0:p11>=(this.ControlPoints.Count-1|0)&&(p11=this.ControlPoints.Count-1|0),p21=p4+1|0,p21<0?p21=0:p21>=(this.ControlPoints.Count-1|0)&&(p21=this.ControlPoints.Count-1|0),p31=p4+2|0,p31<0?p31=0:p31>=(this.ControlPoints.Count-1|0)&&(p31=this.ControlPoints.Count-1|0),lt1=(time-this._deltaT*p4)/this._deltaT,temp=Microsoft.Xna.Framework.Vector2.CatmullRom(this.ControlPoints.getItem(p01).$clone(),this.ControlPoints.getItem(p11).$clone(),this.ControlPoints.getItem(p21).$clone(),this.ControlPoints.getItem(p31).$clone(),lt1)),temp.$clone()},GetPositionNormal:function(time){var offsetTime=time+.0001,a={v:this.GetPosition(time)},b={v:this.GetPosition(offsetTime)},output={v:new Microsoft.Xna.Framework.Vector2},temp={v:new Microsoft.Xna.Framework.Vector2};return Microsoft.Xna.Framework.Vector2.Subtract$1(a,b,temp),output.v.X=-temp.v.Y,output.v.Y=temp.v.X,Microsoft.Xna.Framework.Vector2.Normalize$1(output,output),output.v.$clone()},Add:function(point){this.ControlPoints.add(point.$clone());this._deltaT=1/(this.ControlPoints.Count-1|0)},Remove:function(point){this.ControlPoints.remove(point.$clone());this._deltaT=1/(this.ControlPoints.Count-1|0)},RemoveAt:function(index){this.ControlPoints.removeAt(index);this._deltaT=1/(this.ControlPoints.Count-1|0)},GetLength:function(){for(var verts=this.GetVertices(Bridge.Int.mul(this.ControlPoints.Count,25)),length=0,i=1;i<verts.Count;i=i+1|0)length+=Microsoft.Xna.Framework.Vector2.Distance(verts.getItem(i-1|0).$clone(),verts.getItem(i).$clone());return this.Closed&&(length+=Microsoft.Xna.Framework.Vector2.Distance(verts.getItem(this.ControlPoints.Count-1|0).$clone(),verts.getItem(0).$clone())),length},SubdivideEvenly:function(divisions){for(var verts=new(System.Collections.Generic.List$1(Microsoft.Xna.Framework.Vector3).ctor),length=this.GetLength(),deltaLength=length/divisions+.001,t=0,start=this.ControlPoints.getItem(0).$clone(),end=this.GetPosition(t),i,normal,angle;deltaLength*.5>=Microsoft.Xna.Framework.Vector2.Distance(start.$clone(),end.$clone());)if(end=this.GetPosition(t),t+=.0001,t>=1)break;for(start=end.$clone(),i=1;i<divisions;i=i+1|0){for(normal=this.GetPositionNormal(t),angle=Math.atan2(normal.Y,normal.X),verts.add(new Microsoft.Xna.Framework.Vector3.$ctor1(end.$clone(),angle));deltaLength>=Microsoft.Xna.Framework.Vector2.Distance(start.$clone(),end.$clone());)if(end=this.GetPosition(t),t+=1e-5,t>=1)break;if(t>=1)break;start=end.$clone()}return verts}}});Bridge.define("VelcroPhysics.Tools.PathGenerator.PathManager",{statics:{methods:{ConvertPathToEdges:function(path,body,subdivisions){var verts=path.GetVertices(subdivisions),chain,i;if(path.Closed)chain=new VelcroPhysics.Collision.Shapes.ChainShape.$ctor1(verts,!0),body.CreateFixture(chain);else for(i=1;i<verts.Count;i=i+1|0)body.CreateFixture(new VelcroPhysics.Collision.Shapes.EdgeShape.$ctor1(verts.getItem(i).$clone(),verts.getItem(i-1|0).$clone()))},ConvertPathToPolygon:function(path,body,density,subdivisions){var $t,verts,decomposedVerts,item;if(!path.Closed)throw new System.Exception("The path must be closed to convert to a polygon.");verts=path.GetVertices(subdivisions);decomposedVerts=VelcroPhysics.Tools.Triangulation.TriangulationBase.Triangulate.ConvexPartition(new VelcroPhysics.Shared.Vertices.$ctor1(verts),VelcroPhysics.Tools.Triangulation.TriangulationBase.TriangulationAlgorithm.Bayazit);$t=Bridge.getEnumerator(decomposedVerts);try{while($t.moveNext())item=$t.Current,body.CreateFixture(new VelcroPhysics.Collision.Shapes.PolygonShape.$ctor2(item,density))}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}},EvenlyDistributeShapesAlongPath:function(world,path,shapes,type,copies,userData){var $t,centers,bodyList,i,b,shape;for(userData===void 0&&(userData=null),centers=path.SubdivideEvenly(copies),bodyList=new(System.Collections.Generic.List$1(VelcroPhysics.Dynamics.Body).ctor),i=0;i<centers.Count;i=i+1|0){b=VelcroPhysics.Factories.BodyFactory.CreateBody(world,new Microsoft.Xna.Framework.Vector2.$ctor2(centers.getItem(i).$clone().X,centers.getItem(i).$clone().Y),centers.getItem(i).$clone().Z,type,userData);$t=Bridge.getEnumerator(shapes,VelcroPhysics.Collision.Shapes.Shape);try{while($t.moveNext())shape=$t.Current,b.CreateFixture(shape)}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}bodyList.add(b)}return bodyList},EvenlyDistributeShapesAlongPath$2:function(world,path,shape,type,copies,userData){var shapes=new(System.Collections.Generic.List$1(VelcroPhysics.Collision.Shapes.Shape).$ctor2)(1);return shapes.add(shape),VelcroPhysics.Tools.PathGenerator.PathManager.EvenlyDistributeShapesAlongPath(world,path,shapes,type,copies,userData)},EvenlyDistributeShapesAlongPath$1:function(world,path,shape,type,copies){return VelcroPhysics.Tools.PathGenerator.PathManager.EvenlyDistributeShapesAlongPath$2(world,path,shape,type,copies,null)},MoveBodyOnPath:function(path,body,time,strength,timeStep){var destination=path.GetPosition(time),positionDelta=Microsoft.Xna.Framework.Vector2.op_Subtraction(body.Position.$clone(),destination.$clone()),velocity=Microsoft.Xna.Framework.Vector2.op_Multiply$1(Microsoft.Xna.Framework.Vector2.op_Division$1(positionDelta.$clone(),timeStep),strength);body.LinearVelocity=Microsoft.Xna.Framework.Vector2.op_UnaryNegation(velocity.$clone())},AttachBodiesWithRevoluteJoint:function(world,bodies,localAnchorA,localAnchorB,connectFirstAndLast,collideConnected){for(var joint,lastjoint,joints=new(System.Collections.Generic.List$1(VelcroPhysics.Dynamics.Joints.RevoluteJoint).$ctor2)(bodies.Count+1|0),i=1;i<bodies.Count;i=i+1|0)joint=new VelcroPhysics.Dynamics.Joints.RevoluteJoint.$ctor1(bodies.getItem(i),bodies.getItem(i-1|0),localAnchorA.$clone(),localAnchorB.$clone()),joint.CollideConnected=collideConnected,world.AddJoint(joint),joints.add(joint);return connectFirstAndLast&&(lastjoint=new VelcroPhysics.Dynamics.Joints.RevoluteJoint.$ctor1(bodies.getItem(0),bodies.getItem(bodies.Count-1|0),localAnchorA.$clone(),localAnchorB.$clone()),lastjoint.CollideConnected=collideConnected,world.AddJoint(lastjoint),joints.add(lastjoint)),joints}}}});Bridge.define("VelcroPhysics.Tools.PathGenerator.PathManager.LinkType",{$kind:"nested enum",statics:{fields:{Revolute:0,Slider:1}}});Bridge.define("VelcroPhysics.Tools.PolygonManipulation.SimpleCombiner",{statics:{methods:{PolygonizeTriangles:function(triangles,maxPolys,tolerance){var polys,covered,i,polyIndex,notDone,currTri,i1,poly,i2,index,i3,newP,i4;if(maxPolys===void 0&&(maxPolys=2147483647),tolerance===void 0&&(tolerance=.001),triangles.Count<=0)return triangles;for(polys=new(System.Collections.Generic.List$1(VelcroPhysics.Shared.Vertices).ctor),covered=System.Array.init(triangles.Count,!1,System.Boolean),i=0;i<triangles.Count;i=i+1|0){covered[i]=!1;var triangle=triangles.getItem(i),a=triangle.getItem(0).$clone(),b=triangle.getItem(1).$clone(),c=triangle.getItem(2).$clone();(a.X===b.X&&a.Y===b.Y||b.X===c.X&&b.Y===c.Y||a.X===c.X&&a.Y===c.Y)&&(covered[i]=!0)}for(polyIndex=0,notDone=!0;notDone;){for(currTri=-1,i1=0;i1<triangles.Count;i1=i1+1|0)if(!covered[i1]){currTri=i1;break}if(currTri===-1)notDone=!1;else{for(poly=new VelcroPhysics.Shared.Vertices.$ctor2(3),i2=0;i2<3;i2=i2+1|0)poly.add(triangles.getItem(currTri).getItem(i2).$clone());for(covered[currTri]=!0,index=0,i3=0;i3<Bridge.Int.mul(2,triangles.Count);i3=i3+1|0,index=index+1|0){while(index>=triangles.Count)index=index-triangles.Count|0;covered[index]||(newP=VelcroPhysics.Tools.PolygonManipulation.SimpleCombiner.AddTriangle(triangles.getItem(index),poly),newP!=null)&&(newP.Count>VelcroPhysics.Settings.MaxPolygonVertices||newP.IsConvex()&&(poly=new VelcroPhysics.Shared.Vertices.$ctor1(newP),covered[index]=!0))}polyIndex<maxPolys&&(VelcroPhysics.Tools.PolygonManipulation.SimplifyTools.MergeParallelEdges(poly,tolerance),poly.Count>=3?polys.add(new VelcroPhysics.Shared.Vertices.$ctor1(poly)):System.Diagnostics.Debug.WriteLine$2("Skipping corrupt poly."));poly.Count>=3&&(polyIndex=polyIndex+1|0)}}for(i4=polys.Count-1|0;i4>=0;i4=i4-1|0)polys.getItem(i4).Count===0&&polys.removeAt(i4);return polys},AddTriangle:function(t,vertices){for(var tipT,result,i1,firstP=-1,firstT=-1,secondP=-1,secondT=-1,i=0;i<vertices.Count;i=i+1|0)t.getItem(0).$clone().X===vertices.getItem(i).$clone().X&&t.getItem(0).$clone().Y===vertices.getItem(i).$clone().Y?firstP===-1?(firstP=i,firstT=0):(secondP=i,secondT=0):t.getItem(1).$clone().X===vertices.getItem(i).$clone().X&&t.getItem(1).$clone().Y===vertices.getItem(i).$clone().Y?firstP===-1?(firstP=i,firstT=1):(secondP=i,secondT=1):t.getItem(2).$clone().X===vertices.getItem(i).$clone().X&&t.getItem(2).$clone().Y===vertices.getItem(i).$clone().Y&&(firstP===-1?(firstP=i,firstT=2):(secondP=i,secondT=2));if(firstP===0&&secondP===(vertices.Count-1|0)&&(firstP=vertices.Count-1|0,secondP=0),secondP===-1)return null;for(tipT=0,(tipT===firstT||tipT===secondT)&&(tipT=1),(tipT===firstT||tipT===secondT)&&(tipT=2),result=new VelcroPhysics.Shared.Vertices.$ctor2(vertices.Count+1|0),i1=0;i1<vertices.Count;i1=i1+1|0)result.add(vertices.getItem(i1).$clone()),i1===firstP&&result.add(t.getItem(tipT).$clone());return result}}}});Bridge.define("VelcroPhysics.Tools.PolygonManipulation.SimplifyTools",{statics:{methods:{CollinearSimplify:function(vertices,collinearityTolerance){var simplified,i;if(collinearityTolerance===void 0&&(collinearityTolerance=0),vertices.Count<=3)return vertices;for(simplified=new VelcroPhysics.Shared.Vertices.$ctor2(vertices.Count),i=0;i<vertices.Count;i=i+1|0){var prev={v:vertices.PreviousVertex(i)},current={v:vertices.getItem(i).$clone()},next={v:vertices.NextVertex(i)};VelcroPhysics.Utilities.MathUtils.IsCollinear(prev,current,next,collinearityTolerance)||simplified.add(current.v.$clone())}return simplified},DouglasPeuckerSimplify:function(vertices,distanceTolerance){var usePoint,i,simplified,i1;if(vertices.Count<=3)return vertices;for(usePoint=System.Array.init(vertices.Count,!1,System.Boolean),i=0;i<vertices.Count;i=i+1|0)usePoint[i]=!0;for(VelcroPhysics.Tools.PolygonManipulation.SimplifyTools.SimplifySection(vertices,0,vertices.Count-1|0,usePoint,distanceTolerance),simplified=new VelcroPhysics.Shared.Vertices.$ctor2(vertices.Count),i1=0;i1<vertices.Count;i1=i1+1|0)usePoint[i1]&&simplified.add(vertices.getItem(i1).$clone());return simplified},SimplifySection:function(vertices,i,j,usePoint,distanceTolerance){var k,point,distance,k1;if((i+1|0)!==j){var a={v:vertices.getItem(i).$clone()},b={v:vertices.getItem(j).$clone()},maxDistance=-1,maxIndex=i;for(k=i+1|0;k<j;k=k+1|0)point={v:vertices.getItem(k).$clone()},distance=VelcroPhysics.Utilities.LineUtils.DistanceBetweenPointAndLineSegment(point,a,b),distance>maxDistance&&(maxDistance=distance,maxIndex=k);if(maxDistance<=distanceTolerance)for(k1=i+1|0;k1<j;k1=k1+1|0)usePoint[k1]=!1;else VelcroPhysics.Tools.PolygonManipulation.SimplifyTools.SimplifySection(vertices,i,maxIndex,usePoint,distanceTolerance),VelcroPhysics.Tools.PolygonManipulation.SimplifyTools.SimplifySection(vertices,maxIndex,j,usePoint,distanceTolerance)}},MergeParallelEdges:function(vertices,tolerance){var mergeMe,newNVertices,i,cross,dot,currIndex,newVertices,i1;if(vertices.Count<=3)return vertices;for(mergeMe=System.Array.init(vertices.Count,!1,System.Boolean),newNVertices=vertices.Count,i=0;i<vertices.Count;i=i+1|0){var lower=i===0?vertices.Count-1|0:i-1|0,middle=i,upper=i===(vertices.Count-1|0)?0:i+1|0,dx0=vertices.getItem(middle).$clone().X-vertices.getItem(lower).$clone().X,dy0=vertices.getItem(middle).$clone().Y-vertices.getItem(lower).$clone().Y,dx1=vertices.getItem(upper).$clone().X-vertices.getItem(middle).$clone().X,dy1=vertices.getItem(upper).$clone().Y-vertices.getItem(middle).$clone().Y,norm0=Math.sqrt(dx0*dx0+dy0*dy0),norm1=Math.sqrt(dx1*dx1+dy1*dy1);!(norm0>0&&norm1>0)&&newNVertices>3&&(mergeMe[i]=!0,newNVertices=newNVertices-1|0);dx0/=norm0;dy0/=norm0;dx1/=norm1;dy1/=norm1;cross=dx0*dy1-dx1*dy0;dot=dx0*dx1+dy0*dy1;Math.abs(cross)<tolerance&&dot>0&&newNVertices>3?(mergeMe[i]=!0,newNVertices=newNVertices-1|0):mergeMe[i]=!1}if(newNVertices===vertices.Count||newNVertices===0)return vertices;for(currIndex=0,newVertices=new VelcroPhysics.Shared.Vertices.$ctor2(newNVertices),i1=0;i1<vertices.Count;i1=i1+1|0)mergeMe[i1]||currIndex===newNVertices||(System.Diagnostics.Debug.Assert(currIndex<newNVertices),newVertices.add(vertices.getItem(i1).$clone()),currIndex=currIndex+1|0);return newVertices},MergeIdenticalPoints:function(vertices){var $t,unique=new(System.Collections.Generic.HashSet$1(Microsoft.Xna.Framework.Vector2).ctor),vertex;$t=Bridge.getEnumerator(vertices);try{while($t.moveNext())vertex=$t.Current.$clone(),unique.add(vertex.$clone())}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}return new VelcroPhysics.Shared.Vertices.$ctor1(unique)},ReduceByDistance:function(vertices,distance){var distance2,simplified,i,current,next;if(vertices.Count<=3)return vertices;for(distance2=distance*distance,simplified=new VelcroPhysics.Shared.Vertices.$ctor2(vertices.Count),i=0;i<vertices.Count;i=i+1|0)(current=vertices.getItem(i).$clone(),next=vertices.NextVertex(i),Microsoft.Xna.Framework.Vector2.op_Subtraction(next.$clone(),current.$clone()).LengthSquared()<=distance2)||simplified.add(current.$clone());return simplified},ReduceByNth:function(vertices,nth){var simplified,i;if(vertices.Count<=3||nth===0)return vertices;for(simplified=new VelcroPhysics.Shared.Vertices.$ctor2(vertices.Count),i=0;i<vertices.Count;i=i+1|0)i%nth!=0&&simplified.add(vertices.getItem(i).$clone());return simplified},ReduceByArea:function(vertices,areaTolerance){var i,old1,old2,new1;if(vertices.Count<=3)return vertices;if(areaTolerance<0)throw new System.ArgumentOutOfRangeException.$ctor4("areaTolerance","must be equal to or greater than zero.");var simplified=new VelcroPhysics.Shared.Vertices.$ctor2(vertices.Count),v3={v:new Microsoft.Xna.Framework.Vector2},v1={v:vertices.getItem(vertices.Count-2|0).$clone()},v2={v:vertices.getItem(vertices.Count-1|0).$clone()};for(areaTolerance*=2,i=0;i<vertices.Count;i=i+1|0,v2.v=v3.v.$clone())v3.v=i===(vertices.Count-1|0)?simplified.getItem(0).$clone():vertices.getItem(i).$clone(),old1={},VelcroPhysics.Utilities.MathUtils.Cross$5(v1,v2,old1),old2={},VelcroPhysics.Utilities.MathUtils.Cross$5(v2,v3,old2),new1={},VelcroPhysics.Utilities.MathUtils.Cross$5(v1,v3,new1),Math.abs(new1.v-(old1.v+old2.v))>areaTolerance&&(simplified.add(v2.v.$clone()),v1.v=v2.v.$clone());return simplified}}}});Bridge.define("VelcroPhysics.Tools.TextureTools.MarchingSquares",{statics:{fields:{_lookMarch:null},ctors:{init:function(){this._lookMarch=System.Array.init([0,224,56,216,14,238,54,214,131,99,187,91,141,109,181,85],System.Int32)}},methods:{DetectSquares:function(domain,cellWidth,cellHeight,f,lerpCount,combine){var $t,$t1,ret=new(VelcroPhysics.Tools.TextureTools.MarchingSquares.CxFastList$1(VelcroPhysics.Tools.TextureTools.MarchingSquares.GeomPoly)),verticesList=new(System.Collections.Generic.List$1(VelcroPhysics.Shared.Vertices).ctor),polyList,gp={},xn=Bridge.Int.clip32(domain.Extents.X*2/cellWidth),xp=xn===domain.Extents.X*2/cellWidth,yn=Bridge.Int.clip32(domain.Extents.Y*2/cellHeight),yp=yn===domain.Extents.Y*2/cellHeight,fs,ps,x,x0,y,y0,y1,y01,y11,pre,x1,x01,x11,key,poly,y2,x2,p,u,bi,b1,brk,ai,bj,p2,p21,poly1;for(xp||(xn=xn+1|0),yp||(yn=yn+1|0),fs=System.Array.create(0,null,System.SByte,xn+1|0,yn+1|0),ps=System.Array.create(null,null,VelcroPhysics.Tools.TextureTools.MarchingSquares.GeomPolyVal,xn+1|0,yn+1|0),x=0;x<(xn+1|0);x=x+1|0)for(x0=x===xn?Bridge.Int.clip32(domain.UpperBound.X):Bridge.Int.clip32(x*cellWidth+domain.LowerBound.X),y=0;y<(yn+1|0);y=y+1|0)y0=y===yn?Bridge.Int.clip32(domain.UpperBound.Y):Bridge.Int.clip32(y*cellHeight+domain.LowerBound.Y),fs.set([x,y],f.get([x0,y0]));for(y1=0;y1<yn;y1=y1+1|0)for(y01=y1*cellHeight+domain.LowerBound.Y,y11=y1===(yn-1|0)?domain.UpperBound.Y:y01+cellHeight,pre={v:null},x1=0;x1<xn;x1=x1+1|0)x01=x1*cellWidth+domain.LowerBound.X,x11=x1===(xn-1|0)?domain.UpperBound.X:x01+cellWidth,gp.v=new VelcroPhysics.Tools.TextureTools.MarchingSquares.GeomPoly,key=VelcroPhysics.Tools.TextureTools.MarchingSquares.MarchSquare(f,fs,gp,x1,y1,x01,y01,x11,y11,lerpCount),gp.v.Length!==0?(combine&&pre.v!=null&&(key&9)!=0?(VelcroPhysics.Tools.TextureTools.MarchingSquares.combLeft(pre,gp),gp.v=pre.v):ret.Add(gp.v),ps.set([x1,y1],new VelcroPhysics.Tools.TextureTools.MarchingSquares.GeomPolyVal(gp.v,key))):gp.v=null,pre.v=gp.v;if(!combine){polyList=ret.GetListOfElements();$t=Bridge.getEnumerator(polyList);try{while($t.moveNext())poly=$t.Current,verticesList.add(new VelcroPhysics.Shared.Vertices.$ctor1(poly.Points.GetListOfElements()))}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}return verticesList}for(y2=1;y2<yn;y2=y2+1|0)for(x2=0;x2<xn;){if(p=ps.get([x2,y2]),p==null){x2=x2+1|0;continue}if((p.Key&12)==0){x2=x2+1|0;continue}if(u=ps.get([x2,y2-1|0]),u==null){x2=x2+1|0;continue}if((u.Key&3)==0){x2=x2+1|0;continue}var ax=x2*cellWidth+domain.LowerBound.X,ay=y2*cellHeight+domain.LowerBound.Y,bp=p.GeomP.Points,ap=u.GeomP.Points;if(Bridge.referenceEquals(u.GeomP,p.GeomP)){x2=x2+1|0;continue}for(bi=bp.Begin();VelcroPhysics.Tools.TextureTools.MarchingSquares.Square(bi.Elem().Y-ay)>VelcroPhysics.Settings.Epsilon||bi.Elem().X<ax;)bi=bi.Next();if(b1=bi.Next().Elem().$clone(),VelcroPhysics.Tools.TextureTools.MarchingSquares.Square(b1.Y-ay)>VelcroPhysics.Settings.Epsilon){x2=x2+1|0;continue}for(brk=!0,ai=ap.Begin();!Bridge.referenceEquals(ai,ap.End());){if(VelcroPhysics.Tools.TextureTools.MarchingSquares.VecDsq(ai.Elem().$clone(),b1.$clone())<VelcroPhysics.Settings.Epsilon){brk=!1;break}ai=ai.Next()}if(brk){x2=x2+1|0;continue}for(bj=bi.Next().Next(),Bridge.referenceEquals(bj,bp.End())&&(bj=bp.Begin());!Bridge.referenceEquals(bj,bi);)ai=ap.Insert(ai,bj.Elem().$clone()),bj=bj.Next(),Bridge.referenceEquals(bj,bp.End())&&(bj=bp.Begin()),u.GeomP.Length=u.GeomP.Length+1|0;for(ax=x2+1|0;ax<xn;){if(p2=ps.get([Bridge.Int.clip32(ax),y2]),p2==null||!Bridge.referenceEquals(p2.GeomP,p.GeomP)){ax++;continue}p2.GeomP=u.GeomP;ax++}for(ax=x2-1|0;ax>=0;){if(p21=ps.get([Bridge.Int.clip32(ax),y2]),p21==null||!Bridge.referenceEquals(p21.GeomP,p.GeomP)){ax--;continue}p21.GeomP=u.GeomP;ax--}ret.Remove(p.GeomP);p.GeomP=u.GeomP;x2=Bridge.Int.clip32((bi.Next().Elem().X-domain.LowerBound.X)/cellWidth)+1|0}polyList=ret.GetListOfElements();$t1=Bridge.getEnumerator(polyList);try{while($t1.moveNext())poly1=$t1.Current,verticesList.add(new VelcroPhysics.Shared.Vertices.$ctor1(poly1.Points.GetListOfElements()))}finally{Bridge.is($t1,System.IDisposable)&&$t1.System$IDisposable$Dispose()}return verticesList},Lerp:function(x0,x1,v0,v1){var dv=v0-v1,t;return t=dv*dv<VelcroPhysics.Settings.Epsilon?.5:v0/dv,x0+t*(x1-x0)},Xlerp:function(x0,x1,y,v0,v1,f,c){var xm=VelcroPhysics.Tools.TextureTools.MarchingSquares.Lerp(x0,x1,v0,v1),vm;return c===0?xm:(vm=f.get([Bridge.Int.clip32(xm),Bridge.Int.clip32(y)]),v0*vm<0)?VelcroPhysics.Tools.TextureTools.MarchingSquares.Xlerp(x0,xm,y,v0,vm,f,c-1|0):VelcroPhysics.Tools.TextureTools.MarchingSquares.Xlerp(xm,x1,y,vm,v1,f,c-1|0)},Ylerp:function(y0,y1,x,v0,v1,f,c){var ym=VelcroPhysics.Tools.TextureTools.MarchingSquares.Lerp(y0,y1,v0,v1),vm;return c===0?ym:(vm=f.get([Bridge.Int.clip32(x),Bridge.Int.clip32(ym)]),v0*vm<0)?VelcroPhysics.Tools.TextureTools.MarchingSquares.Ylerp(y0,ym,x,v0,vm,f,c-1|0):VelcroPhysics.Tools.TextureTools.MarchingSquares.Ylerp(ym,y1,x,vm,v1,f,c-1|0)},Square:function(x){return x*x},VecDsq:function(a,b){var d=Microsoft.Xna.Framework.Vector2.op_Subtraction(a.$clone(),b.$clone());return d.X*d.X+d.Y*d.Y},VecCross:function(a,b){return a.X*b.Y-a.Y*b.X},MarchSquare:function(f,fs,poly,ax,ay,x0,y0,x1,y1,bin){var key=0,v0=fs.get([ax,ay]),v1,v2,v3,val,pi,i,p;if(v0<0&&(key=key|8),v1=fs.get([ax+1|0,ay]),v1<0&&(key=key|4),v2=fs.get([ax+1|0,ay+1|0]),v2<0&&(key=key|2),v3=fs.get([ax,ay+1|0]),v3<0&&(key=key|1),val=VelcroPhysics.Tools.TextureTools.MarchingSquares._lookMarch[key],val!==0)for(pi=null,i=0;i<8;i=i+1|0)p=new Microsoft.Xna.Framework.Vector2,(val&1<<i)!=0&&(i===7&&(val&1)==0?poly.v.Points.Add((p=new Microsoft.Xna.Framework.Vector2.$ctor2(x0,VelcroPhysics.Tools.TextureTools.MarchingSquares.Ylerp(y0,y1,x0,v0,v3,f,bin))).$clone()):(p=i===0?new Microsoft.Xna.Framework.Vector2.$ctor2(x0,y0):i===2?new Microsoft.Xna.Framework.Vector2.$ctor2(x1,y0):i===4?new Microsoft.Xna.Framework.Vector2.$ctor2(x1,y1):i===6?new Microsoft.Xna.Framework.Vector2.$ctor2(x0,y1):i===1?new Microsoft.Xna.Framework.Vector2.$ctor2(VelcroPhysics.Tools.TextureTools.MarchingSquares.Xlerp(x0,x1,y0,v0,v1,f,bin),y0):i===5?new Microsoft.Xna.Framework.Vector2.$ctor2(VelcroPhysics.Tools.TextureTools.MarchingSquares.Xlerp(x0,x1,y1,v3,v2,f,bin),y1):i===3?new Microsoft.Xna.Framework.Vector2.$ctor2(x1,VelcroPhysics.Tools.TextureTools.MarchingSquares.Ylerp(y0,y1,x1,v1,v2,f,bin)):new Microsoft.Xna.Framework.Vector2.$ctor2(x0,VelcroPhysics.Tools.TextureTools.MarchingSquares.Ylerp(y0,y1,x0,v0,v3,f,bin)),pi=poly.v.Points.Insert(pi,p.$clone())),poly.v.Length=poly.v.Length+1|0);return key},combLeft:function(polya,polyb){for(var ap=polya.v.Points,bp=polyb.v.Points,ai=ap.Begin(),bi=bp.Begin(),b=bi.Elem().$clone(),prea=null,a,a0,fst,preb,bb,a1;!Bridge.referenceEquals(ai,ap.End());){if(a=ai.Elem().$clone(),VelcroPhysics.Tools.TextureTools.MarchingSquares.VecDsq(a.$clone(),b.$clone())<VelcroPhysics.Settings.Epsilon){if(prea!=null){a0=prea.Elem().$clone();b=bi.Next().Elem().$clone();var u=Microsoft.Xna.Framework.Vector2.op_Subtraction(a.$clone(),a0.$clone()),v=Microsoft.Xna.Framework.Vector2.op_Subtraction(b.$clone(),a.$clone()),dot=VelcroPhysics.Tools.TextureTools.MarchingSquares.VecCross(u.$clone(),v.$clone());dot*dot<VelcroPhysics.Settings.Epsilon&&(ap.Erase(prea,ai),polya.v.Length=polya.v.Length-1|0,ai=prea)}for(fst=!0,preb=null;!bp.Empty();)bb=bp.Front().$clone(),bp.Pop(),fst||bp.Empty()||(ai=ap.Insert(ai,bb.$clone()),polya.v.Length=polya.v.Length+1|0,preb=ai),fst=!1;ai=ai.Next();a1=ai.Elem().$clone();ai=ai.Next();Bridge.referenceEquals(ai,ap.End())&&(ai=ap.Begin());var a2=ai.Elem().$clone(),a00=preb.Elem().$clone(),uu=Microsoft.Xna.Framework.Vector2.op_Subtraction(a1.$clone(),a00.$clone()),vv=Microsoft.Xna.Framework.Vector2.op_Subtraction(a2.$clone(),a1.$clone()),dot1=VelcroPhysics.Tools.TextureTools.MarchingSquares.VecCross(uu.$clone(),vv.$clone());dot1*dot1<VelcroPhysics.Settings.Epsilon&&(ap.Erase(preb,preb.Next()),polya.v.Length=polya.v.Length-1|0);return}prea=ai;ai=ai.Next()}}}}});Bridge.define("VelcroPhysics.Tools.TextureTools.MarchingSquares.CxFastList$1",function(T){return{$kind:"nested class",fields:{_count:0,_head:null},methods:{Begin:function(){return this._head},End:function(){return null},Front:function(){return this._head.Elem()},Add:function(value){var newNode=new(VelcroPhysics.Tools.TextureTools.MarchingSquares.CxFastListNode$1(T))(value);return this._head==null?(newNode._next=null,this._head=newNode,this._count=this._count+1|0,newNode):(newNode._next=this._head,this._head=newNode,this._count=this._count+1|0,newNode)},Remove:function(value){var head=this._head,prev=this._head,comparer=System.Collections.Generic.EqualityComparer$1(T).def;if(head!=null&&value!=null)do{if(comparer.equals2(head._elt,value))return Bridge.referenceEquals(head,this._head)?(this._head=head._next,this._count=this._count-1|0,!0):(prev._next=head._next,this._count=this._count-1|0,!0);prev=head;head=head._next}while(head!=null);return!1},Pop:function(){return this.Erase(null,this._head)},Insert:function(node,value){if(node==null)return this.Add(value);var newNode=new(VelcroPhysics.Tools.TextureTools.MarchingSquares.CxFastListNode$1(T))(value),nextNode=node._next;return newNode._next=nextNode,node._next=newNode,this._count=this._count+1|0,newNode},Erase:function(prev,node){var nextNode=node._next;if(prev!=null)prev._next=nextNode;else if(this._head!=null)this._head=this._head._next;else return null;return this._count=this._count-1|0,nextNode},Empty:function(){return this._head==null?!0:!1},Size:function(){var i=this.Begin(),count=0;do count=count+1|0;while(i.Next()!=null);return count},Clear:function(){for(var head=this._head,node2;head!=null;)node2=head,head=head._next,node2._next=null;this._head=null;this._count=0},Has:function(value){return this.Find(value)!=null},Find:function(value){var head=this._head,comparer=System.Collections.Generic.EqualityComparer$1(T).def;if(head!=null)if(value!=null){do{if(comparer.equals2(head._elt,value))return head;head=head._next}while(!Bridge.referenceEquals(head,this._head))}else do{if(head._elt==null)return head;head=head._next}while(!Bridge.referenceEquals(head,this._head));return null},GetListOfElements:function(){var list=new(System.Collections.Generic.List$1(T).ctor),iter=this.Begin();if(iter!=null)do list.add(iter._elt),iter=iter._next;while(iter!=null);return list}}}});Bridge.define("VelcroPhysics.Tools.TextureTools.MarchingSquares.CxFastListNode$1",function(T){return{$kind:"nested class",fields:{_elt:Bridge.getDefaultValue(T),_next:null},ctors:{ctor:function(obj){this.$initialize();this._elt=obj}},methods:{Elem:function(){return this._elt},Next:function(){return this._next}}}});Bridge.define("VelcroPhysics.Tools.TextureTools.MarchingSquares.GeomPoly",{$kind:"nested class",fields:{Length:0,Points:null},ctors:{ctor:function(){this.$initialize();this.Points=new(VelcroPhysics.Tools.TextureTools.MarchingSquares.CxFastList$1(Microsoft.Xna.Framework.Vector2));this.Length=0}}});Bridge.define("VelcroPhysics.Tools.TextureTools.MarchingSquares.GeomPolyVal",{$kind:"nested class",fields:{GeomP:null,Key:0},ctors:{ctor:function(geomP,K){this.$initialize();this.GeomP=geomP;this.Key=K}}});Bridge.define("VelcroPhysics.Tools.TextureTools.Terrain",{fields:{_bodyMap:null,_dirtyArea:null,_localHeight:0,_localWidth:0,_terrainMap:null,_topLeft:null,_xnum:0,_ynum:0,CellSize:0,Center:null,Decomposer:0,Height:0,Iterations:0,PointsPerUnit:0,SubCellSize:0,Width:0,World:null},ctors:{init:function(){this._dirtyArea=new VelcroPhysics.Shared.AABB;this._topLeft=new Microsoft.Xna.Framework.Vector2;this.Center=new Microsoft.Xna.Framework.Vector2;this.Iterations=2},$ctor1:function(world,area){this.$initialize();this.World=world;this.Width=area.Width;this.Height=area.Height;this.Center=area.Center.$clone()},ctor:function(world,position,width,height){this.$initialize();this.World=world;this.Width=width;this.Height=height;this.Center=position.$clone()}},methods:{Initialize:function(){var x,y;for(this._topLeft=new Microsoft.Xna.Framework.Vector2.$ctor2(this.Center.X-this.Width*.5,this.Center.Y- -this.Height*.5),this._localWidth=this.Width*this.PointsPerUnit,this._localHeight=this.Height*this.PointsPerUnit,this._terrainMap=System.Array.create(0,null,System.SByte,Bridge.Int.clip32(this._localWidth)+1|0,Bridge.Int.clip32(this._localHeight)+1|0),x=0;x<this._localWidth;x=x+1|0)for(y=0;y<this._localHeight;y=y+1|0)this._terrainMap.set([x,y],1);this._xnum=Bridge.Int.clip32(this._localWidth/this.CellSize);this._ynum=Bridge.Int.clip32(this._localHeight/this.CellSize);this._bodyMap=System.Array.create(null,null,System.Collections.Generic.List$1(VelcroPhysics.Dynamics.Body),this._xnum,this._ynum);this._dirtyArea=new VelcroPhysics.Shared.AABB.$ctor1(new Microsoft.Xna.Framework.Vector2.$ctor2(340282347e30,340282347e30),new Microsoft.Xna.Framework.Vector2.$ctor2(-340282347e30,-340282347e30))},ApplyData:function(data,offset){var x,y;for(offset===void 0&&(offset=new Microsoft.Xna.Framework.Vector2),x=0;x<System.Array.getLength(data,0)-1;x=x+1|0)for(y=0;y<System.Array.getLength(data,1)-1;y=y+1|0)x+offset.X>=0&&x+offset.X<this._localWidth&&y+offset.Y>=0&&y+offset.Y<this._localHeight&&this._terrainMap.set([Bridge.Int.clip32(x+offset.X),Bridge.Int.clip32(y+offset.Y)],data.get([x,y]));this.RemoveOldData(0,this._xnum,0,this._ynum)},ModifyTerrain:function(location,value){var p=Microsoft.Xna.Framework.Vector2.op_Subtraction(location.$clone(),this._topLeft.$clone());p.X=p.X*this._localWidth/this.Width;p.Y=p.Y*-this._localHeight/this.Height;p.X>=0&&p.X<this._localWidth&&p.Y>=0&&p.Y<this._localHeight&&(this._terrainMap.set([Bridge.Int.clip32(p.X),Bridge.Int.clip32(p.Y)],value),p.X<this._dirtyArea.LowerBound.X&&(this._dirtyArea.LowerBound.X=p.X),p.X>this._dirtyArea.UpperBound.X&&(this._dirtyArea.UpperBound.X=p.X),p.Y<this._dirtyArea.LowerBound.Y&&(this._dirtyArea.LowerBound.Y=p.Y),p.Y>this._dirtyArea.UpperBound.Y&&(this._dirtyArea.UpperBound.Y=p.Y))},RegenerateTerrain:function(){var xStart=Bridge.Int.clip32(this._dirtyArea.LowerBound.X/this.CellSize),xEnd,yStart,yEnd;xStart<0&&(xStart=0);xEnd=Bridge.Int.clip32(this._dirtyArea.UpperBound.X/this.CellSize)+1|0;xEnd>this._xnum&&(xEnd=this._xnum);yStart=Bridge.Int.clip32(this._dirtyArea.LowerBound.Y/this.CellSize);yStart<0&&(yStart=0);yEnd=Bridge.Int.clip32(this._dirtyArea.UpperBound.Y/this.CellSize)+1|0;yEnd>this._ynum&&(yEnd=this._ynum);this.RemoveOldData(xStart,xEnd,yStart,yEnd);this._dirtyArea=new VelcroPhysics.Shared.AABB.$ctor1(new Microsoft.Xna.Framework.Vector2.$ctor2(340282347e30,340282347e30),new Microsoft.Xna.Framework.Vector2.$ctor2(-340282347e30,-340282347e30))},RemoveOldData:function(xStart,xEnd,yStart,yEnd){for(var y,i,x=xStart;x<xEnd;x=x+1|0)for(y=yStart;y<yEnd;y=y+1|0){if(this._bodyMap.get([x,y])!=null)for(i=0;i<this._bodyMap.get([x,y]).Count;i=i+1|0)this.World.RemoveBody(this._bodyMap.get([x,y]).getItem(i));this._bodyMap.set([x,y],null);this.GenerateTerrain(x,y)}},GenerateTerrain:function(gx,gy){var $t,$t1,ax=Bridge.Int.mul(gx,this.CellSize),ay=Bridge.Int.mul(gy,this.CellSize),polys=VelcroPhysics.Tools.TextureTools.MarchingSquares.DetectSquares(new VelcroPhysics.Shared.AABB.$ctor1(new Microsoft.Xna.Framework.Vector2.$ctor2(ax,ay),new Microsoft.Xna.Framework.Vector2.$ctor2(ax+this.CellSize,ay+this.CellSize)),this.SubCellSize,this.SubCellSize,this._terrainMap,this.Iterations,!0),scale,item,simplified,decompPolys,poly;if(polys.Count!==0){this._bodyMap.set([gx,gy],new(System.Collections.Generic.List$1(VelcroPhysics.Dynamics.Body).ctor));scale={v:new Microsoft.Xna.Framework.Vector2.$ctor2(1/this.PointsPerUnit,1/(-this.PointsPerUnit|0))};$t=Bridge.getEnumerator(polys);try{while($t.moveNext()){item=$t.Current;item.Scale$1(scale);item.Translate$1(Bridge.ref(this,"_topLeft"));simplified=VelcroPhysics.Tools.PolygonManipulation.SimplifyTools.CollinearSimplify(item);decompPolys=VelcroPhysics.Tools.Triangulation.TriangulationBase.Triangulate.ConvexPartition(simplified,this.Decomposer);$t1=Bridge.getEnumerator(decompPolys);try{while($t1.moveNext())poly=$t1.Current,poly.Count>2&&this._bodyMap.get([gx,gy]).add(VelcroPhysics.Factories.BodyFactory.CreatePolygon(this.World,poly,1))}finally{Bridge.is($t1,System.IDisposable)&&$t1.System$IDisposable$Dispose()}}}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}}}}});Bridge.define("VelcroPhysics.Tools.TextureTools.TextureConverter",{statics:{fields:{ClosepixelsLength:0,_closePixels:null},ctors:{init:function(){this.ClosepixelsLength=8;this._closePixels=System.Array.create(0,[[-1,-1],[0,-1],[1,-1],[1,0],[1,1],[0,1],[-1,1],[-1,0]],System.Int32,8,2)}},methods:{DetectVertices$1:function(data,width){var tc=new VelcroPhysics.Tools.TextureTools.TextureConverter.$ctor2(data,width),detectedVerticesList=tc.DetectVertices();return detectedVerticesList.getItem(0)},DetectVertices$2:function(data,width,holeDetection){var $t,tc=($t=new VelcroPhysics.Tools.TextureTools.TextureConverter.$ctor2(data,width),$t.HoleDetection=holeDetection,$t),detectedVerticesList=tc.DetectVertices();return detectedVerticesList.getItem(0)},DetectVertices:function(data,width,hullTolerance,alphaTolerance,multiPartDetection,holeDetection){for(var $t,tc=($t=new VelcroPhysics.Tools.TextureTools.TextureConverter.$ctor2(data,width),$t.HullTolerance=hullTolerance,$t.AlphaTolerance=alphaTolerance,$t.MultipartDetection=multiPartDetection,$t.HoleDetection=holeDetection,$t),detectedVerticesList=tc.DetectVertices(),result=new(System.Collections.Generic.List$1(VelcroPhysics.Shared.Vertices).ctor),i=0;i<detectedVerticesList.Count;i=i+1|0)result.add(detectedVerticesList.getItem(i));return result}}},fields:{_alphaTolerance:0,_data:null,_dataLength:0,_height:0,_holeDetection:!1,_hullTolerance:0,_multipartDetection:!1,_pixelOffsetOptimization:!1,_polygonDetectionType:0,_transform:null,_width:0,_tempIsSolidX:0,_tempIsSolidY:0},props:{PolygonDetectionType:{get:function(){return this._polygonDetectionType},set:function(value){this._polygonDetectionType=value}},HoleDetection:{get:function(){return this._holeDetection},set:function(value){this._holeDetection=value}},MultipartDetection:{get:function(){return this._multipartDetection},set:function(value){this._multipartDetection=value}},PixelOffsetOptimization:{get:function(){return this._pixelOffsetOptimization},set:function(value){this._pixelOffsetOptimization=value}},Transform:{get:function(){return this._transform.$clone()},set:function(value){this._transform=value.$clone()}},AlphaTolerance:{get:function(){return this._alphaTolerance>>>24&255},set:function(value){this._alphaTolerance=value<<24>>>0}},HullTolerance:{get:function(){return this._hullTolerance},set:function(value){this._hullTolerance=value>4?4:value<.9?.9:value}}},ctors:{init:function(){this._transform=new Microsoft.Xna.Framework.Matrix;this._transform=Microsoft.Xna.Framework.Matrix.Identity.$clone()},ctor:function(){this.$initialize();this.Initialize(null,null,null,null,null,null,null,null)},$ctor1:function(alphaTolerance,hullTolerance,holeDetection,multipartDetection,pixelOffsetOptimization,transform){this.$initialize();this.Initialize(null,null,alphaTolerance,hullTolerance,holeDetection,multipartDetection,pixelOffsetOptimization,System.Nullable.lift1("$clone",transform))},$ctor2:function(data,width){this.$initialize();this.Initialize(data,width,null,null,null,null,null,null)},$ctor3:function(data,width,alphaTolerance,hullTolerance,holeDetection,multipartDetection,pixelOffsetOptimization,transform){this.$initialize();this.Initialize(data,width,alphaTolerance,hullTolerance,holeDetection,multipartDetection,pixelOffsetOptimization,System.Nullable.lift1("$clone",transform))}},methods:{Initialize:function(data,width,alphaTolerance,hullTolerance,holeDetection,multipartDetection,pixelOffsetOptimization,transform){if(data!=null&&!System.Nullable.hasValue(width))throw new System.ArgumentNullException.$ctor3("width","'width' can't be null if 'data' is set.");if(data==null&&System.Nullable.hasValue(width))throw new System.ArgumentNullException.$ctor3("data","'data' can't be null if 'width' is set.");data!=null&&System.Nullable.hasValue(width)&&this.SetTextureData(data,System.Nullable.getValue(width));this.AlphaTolerance=System.Nullable.hasValue(alphaTolerance)?System.Nullable.getValue(alphaTolerance):20;this.HullTolerance=System.Nullable.hasValue(hullTolerance)?System.Nullable.getValue(hullTolerance):1.5;this.HoleDetection=System.Nullable.hasValue(holeDetection)?System.Nullable.getValue(holeDetection):!1;this.MultipartDetection=System.Nullable.hasValue(multipartDetection)?System.Nullable.getValue(multipartDetection):!1;this.PixelOffsetOptimization=System.Nullable.hasValue(pixelOffsetOptimization)?System.Nullable.getValue(pixelOffsetOptimization):!1;this.Transform=System.Nullable.hasValue(transform)?System.Nullable.getValue(transform).$clone():Microsoft.Xna.Framework.Matrix.Identity.$clone()},SetTextureData:function(data,width){if(data==null)throw new System.ArgumentNullException.$ctor3("data","'data' can't be null.");if(data.length<4)throw new System.ArgumentOutOfRangeException.$ctor4("data","'data' length can't be less then 4. Your texture must be at least 2 x 2 pixels in size.");if(width<2)throw new System.ArgumentOutOfRangeException.$ctor4("width","'width' can't be less then 2. Your texture must be at least 2 x 2 pixels in size.");if(data.length%width!=0)throw new System.ArgumentException.$ctor1("'width' has an invalid value.");this._data=data;this._dataLength=this._data.length;this._width=width;this._height=Bridge.Int.div(this._dataLength,width)|0},DetectVertices:function(){var polygon,holePolygon,vertex1Index,vertex2Index;if(this._data==null)throw new System.Exception("'_data' can't be null. You have to use SetTextureData(uint[] data, int width) before calling this method.");if(this._data.length<4)throw new System.Exception("'_data' length can't be less then 4. Your texture must be at least 2 x 2 pixels in size. You have to use SetTextureData(uint[] data, int width) before calling this method.");if(this._width<2)throw new System.Exception("'_width' can't be less then 2. Your texture must be at least 2 x 2 pixels in size. You have to use SetTextureData(uint[] data, int width) before calling this method.");if(this._data.length%this._width!=0)throw new System.Exception("'_width' has an invalid value. You have to use SetTextureData(uint[] data, int width) before calling this method.");var detectedPolygons={v:new(System.Collections.Generic.List$1(VelcroPhysics.Shared.Vertices).ctor)},holeEntrance=null,polygonEntrance={v:null},blackList=new(System.Collections.Generic.List$1(Microsoft.Xna.Framework.Vector2).ctor),searchOn;do{if(detectedPolygons.v.Count===0)polygon=new VelcroPhysics.Shared.Vertices.$ctor1(this.CreateSimplePolygon(Microsoft.Xna.Framework.Vector2.Zero.$clone(),Microsoft.Xna.Framework.Vector2.Zero.$clone())),polygon.Count>2&&(polygonEntrance.v=this.GetTopMostVertex(polygon));else if(System.Nullable.hasValue(polygonEntrance.v))polygon=new VelcroPhysics.Shared.Vertices.$ctor1(this.CreateSimplePolygon(System.Nullable.getValue(polygonEntrance.v).$clone(),new Microsoft.Xna.Framework.Vector2.$ctor2(System.Nullable.getValue(polygonEntrance.v).X-1,System.Nullable.getValue(polygonEntrance.v).Y)));else break;if(searchOn=!1,polygon.Count>2){if(this._holeDetection)do if(holeEntrance=this.SearchHoleEntrance(polygon,System.Nullable.lift1("$clone",holeEntrance)),System.Nullable.hasValue(holeEntrance)){if(blackList.contains(System.Nullable.getValue(holeEntrance).$clone()))break;else if(blackList.add(System.Nullable.getValue(holeEntrance).$clone()),holePolygon=this.CreateSimplePolygon(System.Nullable.getValue(holeEntrance).$clone(),new Microsoft.Xna.Framework.Vector2.$ctor2(System.Nullable.getValue(holeEntrance).X+1,System.Nullable.getValue(holeEntrance).Y)),holePolygon!=null&&holePolygon.Count>2)switch(this._polygonDetectionType){case VelcroPhysics.Tools.TextureTools.VerticesDetectionType.Integrated:holePolygon.add(holePolygon.getItem(0).$clone());vertex1Index={};vertex2Index={};this.SplitPolygonEdge(polygon,System.Nullable.getValue(holeEntrance).$clone(),vertex1Index,vertex2Index)&&polygon.InsertRange(vertex2Index.v,holePolygon);break;case VelcroPhysics.Tools.TextureTools.VerticesDetectionType.Separated:polygon.Holes==null&&(polygon.Holes=new(System.Collections.Generic.List$1(VelcroPhysics.Shared.Vertices).ctor));polygon.Holes.add(holePolygon);break}}else break;while(1);detectedPolygons.v.add(polygon)}(this._multipartDetection||polygon.Count<=2)&&this.SearchNextHullEntrance(detectedPolygons.v,System.Nullable.getValue(polygonEntrance.v).$clone(),polygonEntrance)&&(searchOn=!0)}while(searchOn);if(detectedPolygons.v.Count===0)throw new System.Exception("Couldn't detect any vertices.");return this.PolygonDetectionType===VelcroPhysics.Tools.TextureTools.VerticesDetectionType.Separated&&this.ApplyTriangulationCompatibleWinding(detectedPolygons),Microsoft.Xna.Framework.Matrix.op_Inequality(this._transform.$clone(),Microsoft.Xna.Framework.Matrix.Identity.$clone())&&this.ApplyTransform(detectedPolygons),detectedPolygons.v},ApplyTriangulationCompatibleWinding:function(detectedPolygons){for(var j,i=0;i<detectedPolygons.v.Count;i=i+1|0)if(detectedPolygons.v.getItem(i).Reverse(),detectedPolygons.v.getItem(i).Holes!=null&&detectedPolygons.v.getItem(i).Holes.Count>0)for(j=0;j<detectedPolygons.v.getItem(i).Holes.Count;j=j+1|0)detectedPolygons.v.getItem(i).Holes.getItem(j).Reverse()},ApplyTransform:function(detectedPolygons){for(var i=0;i<detectedPolygons.v.Count;i=i+1|0)detectedPolygons.v.getItem(i).Transform(Bridge.ref(this,"_transform"))},SearchHoleEntrance:function(polygon,lastHoleEntrance){var xCoords,entrance,startY,endY,lastSolid,foundSolid,foundTransparent,y,i,x;if(polygon==null)throw new System.ArgumentNullException.$ctor1("'polygon' can't be null.");if(polygon.Count<3)throw new System.ArgumentException.$ctor1("'polygon.MainPolygon.Count' can't be less then 3.");if(lastSolid=0,startY=System.Nullable.hasValue(lastHoleEntrance)?Bridge.Int.clip32(System.Nullable.getValue(lastHoleEntrance).Y):Bridge.Int.clip32(this.GetTopMostCoord(polygon)),endY=Bridge.Int.clip32(this.GetBottomMostCoord(polygon)),startY>0&&startY<this._height&&endY>0&&endY<this._height)for(y={v:startY};y.v<=endY;y.v=y.v+1|0)if(xCoords=this.SearchCrossingEdges(polygon,y.v),xCoords.Count>1&&xCoords.Count%2==0)for(i=0;i<xCoords.Count;i=i+2|0)for(foundSolid=!1,foundTransparent=!1,x={v:Bridge.Int.clip32(xCoords.getItem(i))};x.v<=Bridge.Int.clip32(xCoords.getItem(i+1|0));x.v=x.v+1|0)if(this.IsSolid$2(x,y)){if(foundTransparent||(foundSolid=!0,lastSolid=x.v),foundSolid&&foundTransparent){if(entrance=new Microsoft.Xna.Framework.Vector2.$ctor2(lastSolid,y.v),this.DistanceToHullAcceptable(polygon,System.Nullable.getValue(entrance).$clone(),!0))return System.Nullable.lift1("$clone",entrance);entrance=null;break}}else foundSolid&&(foundTransparent=!0);else xCoords.Count%2==0&&System.Diagnostics.Debug.WriteLine$2("SearchCrossingEdges() % 2 != 0");return null},DistanceToHullAcceptableHoles:function(polygon,point,higherDetail){if(polygon==null)throw new System.ArgumentNullException.$ctor3("polygon","'polygon' can't be null.");if(polygon.Count<3)throw new System.ArgumentException.$ctor1("'polygon.MainPolygon.Count' can't be less then 3.");if(this.DistanceToHullAcceptable(polygon,point.$clone(),higherDetail)){if(polygon.Holes!=null)for(var i=0;i<polygon.Holes.Count;i=i+1|0)if(!this.DistanceToHullAcceptable(polygon.Holes.getItem(i),point.$clone(),higherDetail))return!1;return!0}return!1},DistanceToHullAcceptable:function(polygon,point,higherDetail){var edgeVertex2,edgeVertex1,i,i1;if(point={v:point},polygon==null)throw new System.ArgumentNullException.$ctor3("polygon","'polygon' can't be null.");if(polygon.Count<3)throw new System.ArgumentException.$ctor1("'polygon.Count' can't be less then 3.");if(edgeVertex2={v:polygon.getItem(polygon.Count-1|0).$clone()},edgeVertex1={v:new Microsoft.Xna.Framework.Vector2},higherDetail){for(i=0;i<polygon.Count;i=i+1|0){if(edgeVertex1.v=polygon.getItem(i).$clone(),VelcroPhysics.Utilities.LineUtils.DistanceBetweenPointAndLineSegment(point,edgeVertex1,edgeVertex2)<=this._hullTolerance||Microsoft.Xna.Framework.Vector2.Distance(point.v.$clone(),edgeVertex1.v.$clone())<=this._hullTolerance)return!1;edgeVertex2.v=polygon.getItem(i).$clone()}return!0}else{for(i1=0;i1<polygon.Count;i1=i1+1|0){if(edgeVertex1.v=polygon.getItem(i1).$clone(),VelcroPhysics.Utilities.LineUtils.DistanceBetweenPointAndLineSegment(point,edgeVertex1,edgeVertex2)<=this._hullTolerance)return!1;edgeVertex2.v=polygon.getItem(i1).$clone()}return!0}},InPolygon:function(polygon,point){var inPolygon=!this.DistanceToHullAcceptableHoles(polygon,point.$clone(),!0),xCoords,i;if(!inPolygon){if(xCoords=this.SearchCrossingEdgesHoles(polygon,Bridge.Int.clip32(point.Y)),xCoords.Count>0&&xCoords.Count%2==0)for(i=0;i<xCoords.Count;i=i+2|0)if(xCoords.getItem(i)<=point.X&&xCoords.getItem(i+1|0)>=point.X)return!0;return!1}return!0},GetTopMostVertex:function(vertices){for(var topMostValue=340282347e30,topMost=null,i=0;i<vertices.Count;i=i+1|0)topMostValue>vertices.getItem(i).$clone().Y&&(topMostValue=vertices.getItem(i).$clone().Y,topMost=vertices.getItem(i).$clone());return System.Nullable.lift1("$clone",topMost)},GetTopMostCoord:function(vertices){for(var returnValue=340282347e30,i=0;i<vertices.Count;i=i+1|0)returnValue>vertices.getItem(i).$clone().Y&&(returnValue=vertices.getItem(i).$clone().Y);return returnValue},GetBottomMostCoord:function(vertices){for(var returnValue=-340282347e30,i=0;i<vertices.Count;i=i+1|0)returnValue<vertices.getItem(i).$clone().Y&&(returnValue=vertices.getItem(i).$clone().Y);return returnValue},SearchCrossingEdgesHoles:function(polygon,y){var result,i;if(polygon==null)throw new System.ArgumentNullException.$ctor3("polygon","'polygon' can't be null.");if(polygon.Count<3)throw new System.ArgumentException.$ctor1("'polygon.MainPolygon.Count' can't be less then 3.");if(result=this.SearchCrossingEdges(polygon,y),polygon.Holes!=null)for(i=0;i<polygon.Holes.Count;i=i+1|0)result.AddRange(this.SearchCrossingEdges(polygon.Holes.getItem(i),y));return result.Sort(),result},SearchCrossingEdges:function(polygon,y){var edges=new(System.Collections.Generic.List$1(System.Single).ctor),slope=new Microsoft.Xna.Framework.Vector2,vertex1=new Microsoft.Xna.Framework.Vector2,vertex2=new Microsoft.Xna.Framework.Vector2,nextSlope=new Microsoft.Xna.Framework.Vector2,nextVertex=new Microsoft.Xna.Framework.Vector2,addFind,i;if(polygon.Count>2)for(vertex2=polygon.getItem(polygon.Count-1|0).$clone(),i=0;i<polygon.Count;i=i+1|0)vertex1=polygon.getItem(i).$clone(),(vertex1.Y>=y&&vertex2.Y<=y||vertex1.Y<=y&&vertex2.Y>=y)&&vertex1.Y!==vertex2.Y&&(addFind=!0,slope=Microsoft.Xna.Framework.Vector2.op_Subtraction(vertex2.$clone(),vertex1.$clone()),vertex1.Y===y&&(nextVertex=polygon.getItem((i+1|0)%polygon.Count).$clone(),nextSlope=Microsoft.Xna.Framework.Vector2.op_Subtraction(vertex1.$clone(),nextVertex.$clone()),addFind=slope.Y>0?nextSlope.Y<=0:nextSlope.Y>=0),addFind&&edges.add((y-vertex1.Y)/slope.Y*slope.X+vertex1.X)),vertex2=vertex1.$clone();return edges.Sort(),edges},SplitPolygonEdge:function(polygon,coordInsideThePolygon,vertex1Index,vertex2Index){var slope=new Microsoft.Xna.Framework.Vector2,nearestEdgeVertex1Index=0,nearestEdgeVertex2Index=0,edgeFound=!1,shortestDistance=340282347e30,edgeCoordFound=!1,foundEdgeCoord={v:Microsoft.Xna.Framework.Vector2.Zero.$clone()},xCoords=this.SearchCrossingEdges(polygon,Bridge.Int.clip32(coordInsideThePolygon.Y)),distance,i,edgeVertex2Index,edgeVertex1Index,tempVector1,tempVector2,tempVector;if(vertex1Index.v=0,vertex2Index.v=0,foundEdgeCoord.v.Y=coordInsideThePolygon.Y,xCoords!=null&&xCoords.Count>1&&xCoords.Count%2==0){for(i=0;i<xCoords.Count;i=i+1|0)xCoords.getItem(i)<coordInsideThePolygon.X&&(distance=coordInsideThePolygon.X-xCoords.getItem(i),distance<shortestDistance&&(shortestDistance=distance,foundEdgeCoord.v.X=xCoords.getItem(i),edgeCoordFound=!0));if(edgeCoordFound){for(shortestDistance=340282347e30,edgeVertex2Index=polygon.Count-1|0,edgeVertex1Index=0;edgeVertex1Index<polygon.Count;edgeVertex1Index=edgeVertex1Index+1|0)tempVector1={v:polygon.getItem(edgeVertex1Index).$clone()},tempVector2={v:polygon.getItem(edgeVertex2Index).$clone()},distance=VelcroPhysics.Utilities.LineUtils.DistanceBetweenPointAndLineSegment(foundEdgeCoord,tempVector1,tempVector2),distance<shortestDistance&&(shortestDistance=distance,nearestEdgeVertex1Index=edgeVertex1Index,nearestEdgeVertex2Index=edgeVertex2Index,edgeFound=!0),edgeVertex2Index=edgeVertex1Index;if(edgeFound)return slope=Microsoft.Xna.Framework.Vector2.op_Subtraction(polygon.getItem(nearestEdgeVertex2Index).$clone(),polygon.getItem(nearestEdgeVertex1Index).$clone()),slope.Normalize(),tempVector=polygon.getItem(nearestEdgeVertex1Index).$clone(),distance=Microsoft.Xna.Framework.Vector2.Distance(tempVector.$clone(),foundEdgeCoord.v.$clone()),vertex1Index.v=nearestEdgeVertex1Index,vertex2Index.v=nearestEdgeVertex1Index+1|0,polygon.insert(nearestEdgeVertex1Index,Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(distance,slope.$clone()),polygon.getItem(vertex1Index.v).$clone())),polygon.insert(nearestEdgeVertex1Index,Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(distance,slope.$clone()),polygon.getItem(vertex2Index.v).$clone())),!0}}return!1},CreateSimplePolygon:function(entrance,last){var temp,next,outstanding;entrance={v:entrance};last={v:last};var entranceFound=!1,endOfHull=!1,polygon=new VelcroPhysics.Shared.Vertices.$ctor2(32),hullArea=new VelcroPhysics.Shared.Vertices.$ctor2(32),endOfHullArea=new VelcroPhysics.Shared.Vertices.$ctor2(32),current={v:Microsoft.Xna.Framework.Vector2.Zero.$clone()};if(Microsoft.Xna.Framework.Vector2.op_Equality(entrance.v.$clone(),Microsoft.Xna.Framework.Vector2.Zero.$clone())||!this.InBounds(entrance)?(entranceFound=this.SearchHullEntrance(entrance),entranceFound&&(current.v=new Microsoft.Xna.Framework.Vector2.$ctor2(entrance.v.X-1,entrance.v.Y))):this.IsSolid(entrance)&&(this.IsNearPixel(entrance,last)?(current.v=last.v.$clone(),entranceFound=!0):(temp={v:new Microsoft.Xna.Framework.Vector2},this.SearchNearPixels(!1,entrance,temp)?(current.v=temp.v.$clone(),entranceFound=!0):entranceFound=!1)),entranceFound){polygon.add(entrance.v.$clone());hullArea.add(entrance.v.$clone());next={v:entrance.v.$clone()};do{if(outstanding={v:new Microsoft.Xna.Framework.Vector2},this.SearchForOutstandingVertex(hullArea,outstanding)){if(endOfHull){endOfHullArea.contains(outstanding.v.$clone())&&polygon.add(outstanding.v.$clone());break}polygon.add(outstanding.v.$clone());hullArea.RemoveRange(0,hullArea.indexOf(outstanding.v.$clone()))}if(last.v=current.v.$clone(),current.v=next.v.$clone(),this.GetNextHullPoint(last,current,next))hullArea.add(next.v.$clone());else break;Microsoft.Xna.Framework.Vector2.op_Equality(next.v.$clone(),entrance.v.$clone())&&!endOfHull&&(endOfHull=!0,endOfHullArea.AddRange(hullArea),endOfHullArea.contains(entrance.v.$clone())&&endOfHullArea.remove(entrance.v.$clone()))}while(1)}return polygon},SearchNearPixels:function(searchingForSolidPixel,current,foundPixel){for(var x,y,i=0;i<VelcroPhysics.Tools.TextureTools.TextureConverter.ClosepixelsLength;i=i+1|0)if(x={v:Bridge.Int.clip32(current.v.X)+VelcroPhysics.Tools.TextureTools.TextureConverter._closePixels.get([i,0])|0},y={v:Bridge.Int.clip32(current.v.Y)+VelcroPhysics.Tools.TextureTools.TextureConverter._closePixels.get([i,1])|0},!searchingForSolidPixel^this.IsSolid$2(x,y))return foundPixel.v=new Microsoft.Xna.Framework.Vector2.$ctor2(x.v,y.v),!0;return foundPixel.v=Microsoft.Xna.Framework.Vector2.Zero.$clone(),!1},IsNearPixel:function(current,near){for(var x,y,i=0;i<VelcroPhysics.Tools.TextureTools.TextureConverter.ClosepixelsLength;i=i+1|0)if(x=Bridge.Int.clip32(current.v.X)+VelcroPhysics.Tools.TextureTools.TextureConverter._closePixels.get([i,0])|0,y=Bridge.Int.clip32(current.v.Y)+VelcroPhysics.Tools.TextureTools.TextureConverter._closePixels.get([i,1])|0,x>=0&&x<=this._width&&y>=0&&y<=this._height&&x===Bridge.Int.clip32(near.v.X)&&y===Bridge.Int.clip32(near.v.Y))return!0;return!1},SearchHullEntrance:function(entrance){for(var x,y={v:0};y.v<=this._height;y.v=y.v+1|0)for(x={v:0};x.v<=this._width;x.v=x.v+1|0)if(this.IsSolid$2(x,y))return entrance.v=new Microsoft.Xna.Framework.Vector2.$ctor2(x.v,y.v),!0;return entrance.v=Microsoft.Xna.Framework.Vector2.Zero.$clone(),!1},SearchNextHullEntrance:function(detectedPolygons,start,entrance){for(var polygonIdx,x,foundTransparent=!1,inPolygon=!1,i={v:Bridge.Int.clip32(start.X)+Bridge.Int.mul(Bridge.Int.clip32(start.Y),this._width)|0};i.v<=this._dataLength;i.v=i.v+1|0)if(this.IsSolid$1(i)){if(foundTransparent){for(x=i.v%this._width,entrance.v=new Microsoft.Xna.Framework.Vector2.$ctor2(x,(i.v-x|0)/this._width),inPolygon=!1,polygonIdx=0;polygonIdx<detectedPolygons.Count;polygonIdx=polygonIdx+1|0)if(this.InPolygon(detectedPolygons.getItem(polygonIdx),System.Nullable.getValue(entrance.v).$clone())){inPolygon=!0;break}if(inPolygon)foundTransparent=!1;else return!0}}else foundTransparent=!0;return entrance.v=null,!1},GetNextHullPoint:function(last,current,next){for(var x={},y={},indexOfFirstPixelToCheck=this.GetIndexOfFirstPixelToCheck(last,current),indexOfPixelToCheck,i=0;i<VelcroPhysics.Tools.TextureTools.TextureConverter.ClosepixelsLength;i=i+1|0)if(indexOfPixelToCheck=(indexOfFirstPixelToCheck+i|0)%VelcroPhysics.Tools.TextureTools.TextureConverter.ClosepixelsLength,x.v=Bridge.Int.clip32(current.v.X)+VelcroPhysics.Tools.TextureTools.TextureConverter._closePixels.get([indexOfPixelToCheck,0])|0,y.v=Bridge.Int.clip32(current.v.Y)+VelcroPhysics.Tools.TextureTools.TextureConverter._closePixels.get([indexOfPixelToCheck,1])|0,x.v>=0&&x.v<this._width&&y.v>=0&&y.v<=this._height&&this.IsSolid$2(x,y))return next.v=new Microsoft.Xna.Framework.Vector2.$ctor2(x.v,y.v),!0;return next.v=Microsoft.Xna.Framework.Vector2.Zero.$clone(),!1},SearchForOutstandingVertex:function(hullArea,outstanding){var outstandingResult=Microsoft.Xna.Framework.Vector2.Zero.$clone(),found=!1,i;if(hullArea.Count>2){var hullAreaLastPoint=hullArea.Count-1|0,tempVector1={v:new Microsoft.Xna.Framework.Vector2},tempVector2={v:hullArea.getItem(0).$clone()},tempVector3={v:hullArea.getItem(hullAreaLastPoint).$clone()};for(i=1;i<hullAreaLastPoint;i=i+1|0)if(tempVector1.v=hullArea.getItem(i).$clone(),VelcroPhysics.Utilities.LineUtils.DistanceBetweenPointAndLineSegment(tempVector1,tempVector2,tempVector3)>=this._hullTolerance){outstandingResult=hullArea.getItem(i).$clone();found=!0;break}}return outstanding.v=outstandingResult.$clone(),found},GetIndexOfFirstPixelToCheck:function(last,current){switch(Bridge.Int.clip32(current.v.X-last.v.X)){case 1:switch(Bridge.Int.clip32(current.v.Y-last.v.Y)){case 1:return 1;case 0:return 0;case-1:return 7}break;case 0:switch(Bridge.Int.clip32(current.v.Y-last.v.Y)){case 1:return 2;case-1:return 6}break;case-1:switch(Bridge.Int.clip32(current.v.Y-last.v.Y)){case 1:return 3;case 0:return 4;case-1:return 5}break}return 0},IsSolid:function(v){return(this._tempIsSolidX=Bridge.Int.clip32(v.v.X),this._tempIsSolidY=Bridge.Int.clip32(v.v.Y),this._tempIsSolidX>=0&&this._tempIsSolidX<this._width&&this._tempIsSolidY>=0&&this._tempIsSolidY<this._height)?this._data[this._tempIsSolidX+Bridge.Int.mul(this._tempIsSolidY,this._width)|0]>=this._alphaTolerance:!1},IsSolid$2:function(x,y){return x.v>=0&&x.v<this._width&&y.v>=0&&y.v<this._height?this._data[x.v+Bridge.Int.mul(y.v,this._width)|0]>=this._alphaTolerance:!1},IsSolid$1:function(index){return index.v>=0&&index.v<this._dataLength?this._data[index.v]>=this._alphaTolerance:!1},InBounds:function(coord){return coord.v.X>=0&&coord.v.X<this._width&&coord.v.Y>=0&&coord.v.Y<this._height}}});Bridge.define("VelcroPhysics.Tools.TextureTools.VerticesDetectionType",{$kind:"enum",statics:{fields:{Integrated:0,Separated:1}}});Bridge.define("VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer",{statics:{methods:{ConvexPartition:function(vertices){return System.Diagnostics.Debug.Assert(vertices.Count>3),System.Diagnostics.Debug.Assert(vertices.IsCounterClockWise()),VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.TriangulatePolygon(vertices)},TriangulatePolygon:function(vertices){for(var upperDist,lowerDist,j,d,p,p1,highestScore,bestIndex,j1,score,list=new(System.Collections.Generic.List$1(VelcroPhysics.Shared.Vertices).ctor),lowerInt=new Microsoft.Xna.Framework.Vector2.ctor,upperInt=new Microsoft.Xna.Framework.Vector2.ctor,lowerIndex=0,upperIndex=0,lowerPoly,upperPoly,i=0;i<vertices.Count;i=i+1|0)if(VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.Reflex(i,vertices)){for(lowerDist=upperDist=340282347e30,j=0;j<vertices.Count;j=j+1|0)p=new Microsoft.Xna.Framework.Vector2,VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.Left(VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(i-1|0,vertices),VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(i,vertices),VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(j,vertices))&&VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.RightOn(VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(i-1|0,vertices),VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(i,vertices),VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(j-1|0,vertices))&&(p=VelcroPhysics.Utilities.LineUtils.LineIntersect(VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(i-1|0,vertices),VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(i,vertices),VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(j,vertices),VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(j-1|0,vertices)),VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.Right(VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(i+1|0,vertices),VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(i,vertices),p.$clone())&&(d=VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.SquareDist(VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(i,vertices),p.$clone()),d<lowerDist&&(lowerDist=d,lowerInt=p.$clone(),lowerIndex=j))),VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.Left(VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(i+1|0,vertices),VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(i,vertices),VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(j+1|0,vertices))&&VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.RightOn(VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(i+1|0,vertices),VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(i,vertices),VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(j,vertices))&&(p=VelcroPhysics.Utilities.LineUtils.LineIntersect(VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(i+1|0,vertices),VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(i,vertices),VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(j,vertices),VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(j+1|0,vertices)),VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.Left(VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(i-1|0,vertices),VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(i,vertices),p.$clone())&&(d=VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.SquareDist(VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(i,vertices),p.$clone()),d<upperDist&&(upperDist=d,upperIndex=j,upperInt=p.$clone())));if(lowerIndex===(upperIndex+1|0)%vertices.Count)p1=Microsoft.Xna.Framework.Vector2.op_Division$1(Microsoft.Xna.Framework.Vector2.op_Addition(lowerInt.$clone(),upperInt.$clone()),2),lowerPoly=VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.Copy(i,upperIndex,vertices),lowerPoly.add(p1.$clone()),upperPoly=VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.Copy(lowerIndex,i,vertices),upperPoly.add(p1.$clone());else{for(highestScore=0,bestIndex=lowerIndex;upperIndex<lowerIndex;)upperIndex=upperIndex+vertices.Count|0;for(j1=lowerIndex;j1<=upperIndex;j1=j1+1|0)VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.CanSee(i,j1,vertices)&&(score=1/(VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.SquareDist(VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(i,vertices),VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(j1,vertices))+1),score+=VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.Reflex(j1,vertices)?VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.RightOn(VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(j1-1|0,vertices),VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(j1,vertices),VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(i,vertices))&&VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.LeftOn(VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(j1+1|0,vertices),VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(j1,vertices),VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(i,vertices))?3:2:1,score>highestScore&&(bestIndex=j1,highestScore=score));lowerPoly=VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.Copy(i,Bridge.Int.clip32(bestIndex),vertices);upperPoly=VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.Copy(Bridge.Int.clip32(bestIndex),i,vertices)}return list.AddRange(VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.TriangulatePolygon(lowerPoly)),list.AddRange(VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.TriangulatePolygon(upperPoly)),list}return vertices.Count>VelcroPhysics.Settings.MaxPolygonVertices?(lowerPoly=VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.Copy(0,Bridge.Int.div(vertices.Count,2)|0,vertices),upperPoly=VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.Copy(Bridge.Int.div(vertices.Count,2)|0,0,vertices),list.AddRange(VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.TriangulatePolygon(lowerPoly)),list.AddRange(VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.TriangulatePolygon(upperPoly))):list.add(vertices),list},At:function(i,vertices){var s=vertices.Count;return vertices.getItem(i<0?(s-1|0)-((-i|0)-1|0)%s|0:i%s).$clone()},Copy:function(i,j,vertices){while(j<i)j=j+vertices.Count|0;for(var p=new VelcroPhysics.Shared.Vertices.$ctor2(j);i<=j;i=i+1|0)p.add(VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(i,vertices));return p},CanSee:function(i,j,vertices){var k,intersectionPoint;if(VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.Reflex(i,vertices)){if(VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.LeftOn(VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(i,vertices),VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(i-1|0,vertices),VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(j,vertices))&&VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.RightOn(VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(i,vertices),VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(i+1|0,vertices),VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(j,vertices)))return!1}else if(VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.RightOn(VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(i,vertices),VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(i+1|0,vertices),VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(j,vertices))||VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.LeftOn(VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(i,vertices),VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(i-1|0,vertices),VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(j,vertices)))return!1;if(VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.Reflex(j,vertices)){if(VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.LeftOn(VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(j,vertices),VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(j-1|0,vertices),VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(i,vertices))&&VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.RightOn(VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(j,vertices),VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(j+1|0,vertices),VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(i,vertices)))return!1}else if(VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.RightOn(VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(j,vertices),VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(j+1|0,vertices),VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(i,vertices))||VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.LeftOn(VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(j,vertices),VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(j-1|0,vertices),VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(i,vertices)))return!1;for(k=0;k<vertices.Count;k=k+1|0)if((k+1|0)%vertices.Count!==i&&k!==i&&(k+1|0)%vertices.Count!==j&&k!==j&&(intersectionPoint={v:new Microsoft.Xna.Framework.Vector2},VelcroPhysics.Utilities.LineUtils.LineIntersect$1(VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(i,vertices),VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(j,vertices),VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(k,vertices),VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(k+1|0,vertices),intersectionPoint)))return!1;return!0},Reflex:function(i,vertices){return VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.Right$1(i,vertices)},Right$1:function(i,vertices){return VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.Right(VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(i-1|0,vertices),VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(i,vertices),VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.At(i+1|0,vertices))},Right:function(a,b,c){return a={v:a},b={v:b},c={v:c},VelcroPhysics.Utilities.MathUtils.Area$1(a,b,c)<0},Left:function(a,b,c){return a={v:a},b={v:b},c={v:c},VelcroPhysics.Utilities.MathUtils.Area$1(a,b,c)>0},LeftOn:function(a,b,c){return a={v:a},b={v:b},c={v:c},VelcroPhysics.Utilities.MathUtils.Area$1(a,b,c)>=0},RightOn:function(a,b,c){return a={v:a},b={v:b},c={v:c},VelcroPhysics.Utilities.MathUtils.Area$1(a,b,c)<=0},SquareDist:function(a,b){var dx=b.X-a.X,dy=b.Y-a.Y;return dx*dx+dy*dy}}}});Bridge.define("VelcroPhysics.Tools.Triangulation.Delaunay.CDTDecomposer",{statics:{methods:{ConvexPartition:function(vertices){var $t,$t1,$t2,$t3,$t4,poly,vertex,holeVertices,hole,vertex1,tcx,results,triangle,v,p;System.Diagnostics.Debug.Assert(vertices.Count>3);poly=new VelcroPhysics.Tools.Triangulation.Delaunay.Polygon.Polygon.ctor;$t=Bridge.getEnumerator(vertices);try{while($t.moveNext())vertex=$t.Current.$clone(),System.Array.add(poly.Points,new VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationPoint(vertex.X,vertex.Y),VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationPoint)}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}if(vertices.Holes!=null){$t1=Bridge.getEnumerator(vertices.Holes);try{while($t1.moveNext()){holeVertices=$t1.Current;hole=new VelcroPhysics.Tools.Triangulation.Delaunay.Polygon.Polygon.ctor;$t2=Bridge.getEnumerator(holeVertices);try{while($t2.moveNext())vertex1=$t2.Current.$clone(),System.Array.add(hole.Points,new VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationPoint(vertex1.X,vertex1.Y),VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationPoint)}finally{Bridge.is($t2,System.IDisposable)&&$t2.System$IDisposable$Dispose()}poly.AddHole(hole)}}finally{Bridge.is($t1,System.IDisposable)&&$t1.System$IDisposable$Dispose()}}tcx=new VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweepContext;tcx.PrepareTriangulation(poly);VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.Triangulate(tcx);results=new(System.Collections.Generic.List$1(VelcroPhysics.Shared.Vertices).ctor);$t3=Bridge.getEnumerator(poly.Triangles,VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle);try{while($t3.moveNext()){triangle=$t3.Current;v=new VelcroPhysics.Shared.Vertices.ctor;$t4=Bridge.getEnumerator(triangle.Points);try{while($t4.moveNext())p=$t4.Current,v.add(new Microsoft.Xna.Framework.Vector2.$ctor2(p.X,p.Y))}finally{Bridge.is($t4,System.IDisposable)&&$t4.System$IDisposable$Dispose()}results.add(v)}}finally{Bridge.is($t3,System.IDisposable)&&$t3.System$IDisposable$Dispose()}return results}}}});Bridge.define("VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle",{fields:{EdgeIsConstrained:null,EdgeIsDelaunay:null,Neighbors:null,Points:null,IsInterior:!1},ctors:{init:function(){this.EdgeIsConstrained=new(VelcroPhysics.Shared.Optimization.FixedArray3$1(System.Boolean));this.EdgeIsDelaunay=new(VelcroPhysics.Shared.Optimization.FixedArray3$1(System.Boolean));this.Neighbors=new(VelcroPhysics.Shared.Optimization.FixedArray3$1(VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle));this.Points=new(VelcroPhysics.Shared.Optimization.FixedArray3$1(VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationPoint))},ctor:function(p1,p2,p3){this.$initialize();this.Points.setItem(0,p1);this.Points.setItem(1,p2);this.Points.setItem(2,p3)}},methods:{IndexOf:function(p){var i=this.Points.IndexOf(p);if(i===-1)throw new System.Exception("Calling index with a point that doesn't exist in triangle");return i},IndexCW:function(p){var index=this.IndexOf(p);switch(index){case 0:return 2;case 1:return 0;default:return 1}},IndexCCW:function(p){var index=this.IndexOf(p);switch(index){case 0:return 1;case 1:return 2;default:return 0}},Contains$1:function(p){return Bridge.referenceEquals(p,this.Points.getItem(0))||Bridge.referenceEquals(p,this.Points.getItem(1))||Bridge.referenceEquals(p,this.Points.getItem(2))},Contains:function(e){return this.Contains$1(e.P)&&this.Contains$1(e.Q)},Contains$2:function(p,q){return this.Contains$1(p)&&this.Contains$1(q)},MarkNeighbor$1:function(p1,p2,t){Bridge.referenceEquals(p1,this.Points.getItem(2))&&Bridge.referenceEquals(p2,this.Points.getItem(1))||Bridge.referenceEquals(p1,this.Points.getItem(1))&&Bridge.referenceEquals(p2,this.Points.getItem(2))?this.Neighbors.setItem(0,t):Bridge.referenceEquals(p1,this.Points.getItem(0))&&Bridge.referenceEquals(p2,this.Points.getItem(2))||Bridge.referenceEquals(p1,this.Points.getItem(2))&&Bridge.referenceEquals(p2,this.Points.getItem(0))?this.Neighbors.setItem(1,t):Bridge.referenceEquals(p1,this.Points.getItem(0))&&Bridge.referenceEquals(p2,this.Points.getItem(1))||Bridge.referenceEquals(p1,this.Points.getItem(1))&&Bridge.referenceEquals(p2,this.Points.getItem(0))?this.Neighbors.setItem(2,t):System.Diagnostics.Debug.WriteLine$2("Neighbor error, please report!")},MarkNeighbor:function(t){t.Contains$2(this.Points.getItem(1),this.Points.getItem(2))?(this.Neighbors.setItem(0,t),t.MarkNeighbor$1(this.Points.getItem(1),this.Points.getItem(2),this)):t.Contains$2(this.Points.getItem(0),this.Points.getItem(2))?(this.Neighbors.setItem(1,t),t.MarkNeighbor$1(this.Points.getItem(0),this.Points.getItem(2),this)):t.Contains$2(this.Points.getItem(0),this.Points.getItem(1))?(this.Neighbors.setItem(2,t),t.MarkNeighbor$1(this.Points.getItem(0),this.Points.getItem(1),this)):System.Diagnostics.Debug.WriteLine$2("markNeighbor failed")},ClearNeighbors:function(){var $t,$t1;this.Neighbors.setItem(0,($t=($t1=null,this.Neighbors.setItem(2,$t1),$t1),this.Neighbors.setItem(1,$t),$t))},ClearNeighbor:function(triangle){Bridge.referenceEquals(this.Neighbors.getItem(0),triangle)?this.Neighbors.setItem(0,null):Bridge.referenceEquals(this.Neighbors.getItem(1),triangle)?this.Neighbors.setItem(1,null):this.Neighbors.setItem(2,null)},Clear:function(){for(var $t,$t1,t,i=0;i<3;i=i+1|0)t=this.Neighbors.getItem(i),t!=null&&t.ClearNeighbor(this);this.ClearNeighbors();this.Points.setItem(0,($t=($t1=null,this.Points.setItem(2,$t1),$t1),this.Points.setItem(1,$t),$t))},OppositePoint:function(t,p){return System.Diagnostics.Debug.Assert$1(!Bridge.referenceEquals(t,this),"self-pointer error"),this.PointCW(t.PointCW(p))},NeighborCW:function(point){return this.Neighbors.getItem((this.Points.IndexOf(point)+1|0)%3)},NeighborCCW:function(point){return this.Neighbors.getItem((this.Points.IndexOf(point)+2|0)%3)},NeighborAcross:function(point){return this.Neighbors.getItem(this.Points.IndexOf(point))},PointCCW:function(point){return this.Points.getItem((this.IndexOf(point)+1|0)%3)},PointCW:function(point){return this.Points.getItem((this.IndexOf(point)+2|0)%3)},RotateCW:function(){var t=this.Points.getItem(2);this.Points.setItem(2,this.Points.getItem(1));this.Points.setItem(1,this.Points.getItem(0));this.Points.setItem(0,t)},Legalize:function(oPoint,nPoint){this.RotateCW();this.Points.setItem(this.IndexCCW(oPoint),nPoint)},toString:function(){return System.String.concat(System.String.concat(this.Points.getItem(0),",",this.Points.getItem(1))+",",this.Points.getItem(2))},MarkNeighborEdges:function(){for(var i=0;i<3;i=i+1|0)this.EdgeIsConstrained.getItem(i)&&this.Neighbors.getItem(i)!=null&&this.Neighbors.getItem(i).MarkConstrainedEdge$2(this.Points.getItem((i+1|0)%3),this.Points.getItem((i+2|0)%3))},MarkEdge$1:function(triangle){for(var i=0;i<3;i=i+1|0)this.EdgeIsConstrained.getItem(i)&&triangle.MarkConstrainedEdge$2(this.Points.getItem((i+1|0)%3),this.Points.getItem((i+2|0)%3))},MarkEdge:function(tList){var $t,t,i;$t=Bridge.getEnumerator(tList);try{while($t.moveNext())for(t=$t.Current,i=0;i<3;i=i+1|0)t.EdgeIsConstrained.getItem(i)&&this.MarkConstrainedEdge$2(t.Points.getItem((i+1|0)%3),t.Points.getItem((i+2|0)%3))}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}},MarkConstrainedEdge:function(index){this.EdgeIsConstrained.setItem(index,!0)},MarkConstrainedEdge$1:function(edge){this.MarkConstrainedEdge$2(edge.P,edge.Q)},MarkConstrainedEdge$2:function(p,q){var i=this.EdgeIndex(p,q);i!==-1&&this.EdgeIsConstrained.setItem(i,!0)},Area:function(){var b=this.Points.getItem(0).X-this.Points.getItem(1).X,h=this.Points.getItem(2).Y-this.Points.getItem(1).Y;return Math.abs(b*h*.5)},Centroid:function(){var cx=(this.Points.getItem(0).X+this.Points.getItem(1).X+this.Points.getItem(2).X)/3,cy=(this.Points.getItem(0).Y+this.Points.getItem(1).Y+this.Points.getItem(2).Y)/3;return new VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationPoint(cx,cy)},EdgeIndex:function(p1,p2){var i1=this.Points.IndexOf(p1),i2=this.Points.IndexOf(p2),a=i1===0||i2===0,b=i1===1||i2===1,c=i1===2||i2===2;return b&&c?0:a&&c?1:a&&b?2:-1},GetConstrainedEdgeCCW:function(p){return this.EdgeIsConstrained.getItem((this.IndexOf(p)+2|0)%3)},GetConstrainedEdgeCW:function(p){return this.EdgeIsConstrained.getItem((this.IndexOf(p)+1|0)%3)},GetConstrainedEdgeAcross:function(p){return this.EdgeIsConstrained.getItem(this.IndexOf(p))},SetConstrainedEdgeCCW:function(p,ce){this.EdgeIsConstrained.setItem((this.IndexOf(p)+2|0)%3,ce)},SetConstrainedEdgeCW:function(p,ce){this.EdgeIsConstrained.setItem((this.IndexOf(p)+1|0)%3,ce)},SetConstrainedEdgeAcross:function(p,ce){this.EdgeIsConstrained.setItem(this.IndexOf(p),ce)},GetDelaunayEdgeCCW:function(p){return this.EdgeIsDelaunay.getItem((this.IndexOf(p)+2|0)%3)},GetDelaunayEdgeCW:function(p){return this.EdgeIsDelaunay.getItem((this.IndexOf(p)+1|0)%3)},GetDelaunayEdgeAcross:function(p){return this.EdgeIsDelaunay.getItem(this.IndexOf(p))},SetDelaunayEdgeCCW:function(p,ce){this.EdgeIsDelaunay.setItem((this.IndexOf(p)+2|0)%3,ce)},SetDelaunayEdgeCW:function(p,ce){this.EdgeIsDelaunay.setItem((this.IndexOf(p)+1|0)%3,ce)},SetDelaunayEdgeAcross:function(p,ce){this.EdgeIsDelaunay.setItem(this.IndexOf(p),ce)}}});Bridge.define("VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFront",{fields:{Head:null,Search:null,Tail:null},ctors:{ctor:function(head,tail){this.$initialize();this.Head=head;this.Tail=tail;this.Search=head;this.AddNode(head);this.AddNode(tail)}},methods:{AddNode:function(node){},RemoveNode:function(node){},toString:function(){for(var sb=new System.Text.StringBuilder,node=this.Head;!Bridge.referenceEquals(node,this.Tail);)sb.append(node.Point.X).append("->"),node=node.Next;return sb.append(this.Tail.Point.X),sb.toString()},FindSearchNode:function(x){return this.Search},LocateNode:function(point){return this.LocateNode$1(point.X)},LocateNode$1:function(x){var node=this.FindSearchNode(x);if(x<node.Value){while((node=node.Prev)!=null)if(x>=node.Value)return this.Search=node,node}else while((node=node.Next)!=null)if(x<node.Value)return this.Search=node.Prev,node.Prev;return null},LocatePoint:function(point){var px=point.X,node=this.FindSearchNode(px),nx=node.Point.X;if(px===nx){if(!Bridge.referenceEquals(point,node.Point))if(Bridge.referenceEquals(point,node.Prev.Point))node=node.Prev;else if(Bridge.referenceEquals(point,node.Next.Point))node=node.Next;else throw new System.Exception("Failed to find Node for given afront point");}else if(px<nx){while((node=node.Prev)!=null)if(Bridge.referenceEquals(point,node.Point))break}else while((node=node.Next)!=null)if(Bridge.referenceEquals(point,node.Point))break;return this.Search=node,node}}});Bridge.define("VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode",{fields:{Next:null,Point:null,Prev:null,Triangle:null,Value:0},props:{HasNext:{get:function(){return this.Next!=null}},HasPrev:{get:function(){return this.Prev!=null}}},ctors:{ctor:function(point){this.$initialize();this.Point=point;this.Value=point.X}}});Bridge.define("VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep",{statics:{fields:{PI_div2:0,PI_3div4:0},ctors:{init:function(){this.PI_div2=1.5707963267948966;this.PI_3div4=2.3561944901923448}},methods:{Triangulate:function(tcx){tcx.CreateAdvancingFront();VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.Sweep(tcx);tcx.TriangulationMode===VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationMode.Polygon?VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.FinalizationPolygon(tcx):VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.FinalizationConvexHull(tcx);tcx.Done()},Sweep:function(tcx){for(var point,node,e,$t,points=tcx.Points,i=1;i<points.Count;i=i+1|0){if(point=points.getItem(i),node=VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.PointEvent(tcx,point),point.HasEdges){$t=Bridge.getEnumerator(point.Edges);try{while($t.moveNext())e=$t.Current,VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.EdgeEvent(tcx,e,node)}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}}tcx.Update(null)}},FinalizationConvexHull:function(tcx){var t1,t2,n1=tcx.aFront.Head.Next,n2=n1.Next,first,p1;VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.TurnAdvancingFrontConvex(tcx,n1,n2);n1=tcx.aFront.Tail.Prev;n1.Triangle.Contains$1(n1.Next.Point)&&n1.Triangle.Contains$1(n1.Prev.Point)&&(t1=n1.Triangle.NeighborAcross(n1.Point),VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.RotateTrianglePair(n1.Triangle,n1.Point,t1,t1.OppositePoint(n1.Triangle,n1.Point)),tcx.MapTriangleToNodes(n1.Triangle),tcx.MapTriangleToNodes(t1));n1=tcx.aFront.Head.Next;n1.Triangle.Contains$1(n1.Prev.Point)&&n1.Triangle.Contains$1(n1.Next.Point)&&(t1=n1.Triangle.NeighborAcross(n1.Point),VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.RotateTrianglePair(n1.Triangle,n1.Point,t1,t1.OppositePoint(n1.Triangle,n1.Point)),tcx.MapTriangleToNodes(n1.Triangle),tcx.MapTriangleToNodes(t1));first=tcx.aFront.Head.Point;n2=tcx.aFront.Tail.Prev;t1=n2.Triangle;p1=n2.Point;n2.Triangle=null;do{if(tcx.RemoveFromList(t1),p1=t1.PointCCW(p1),Bridge.referenceEquals(p1,first))break;t2=t1.NeighborCCW(p1);t1.Clear();t1=t2}while(1);for(first=tcx.aFront.Head.Next.Point,p1=t1.PointCW(tcx.aFront.Head.Point),t2=t1.NeighborCW(tcx.aFront.Head.Point),t1.Clear(),t1=t2;!Bridge.referenceEquals(p1,first);)tcx.RemoveFromList(t1),p1=t1.PointCCW(p1),t2=t1.NeighborCCW(p1),t1.Clear(),t1=t2;tcx.aFront.Head=tcx.aFront.Head.Next;tcx.aFront.Head.Prev=null;tcx.aFront.Tail=tcx.aFront.Tail.Prev;tcx.aFront.Tail.Next=null;tcx.FinalizeTriangulation()},TurnAdvancingFrontConvex:function(tcx,b,c){for(var first=b;!Bridge.referenceEquals(c,tcx.aFront.Tail);)VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationUtil.Orient2d(b.Point,c.Point,c.Next.Point)===VelcroPhysics.Tools.Triangulation.Delaunay.Orientation.CCW?(VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.Fill(tcx,c),c=c.Next):Bridge.referenceEquals(b,first)||VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationUtil.Orient2d(b.Prev.Point,b.Point,c.Point)!==VelcroPhysics.Tools.Triangulation.Delaunay.Orientation.CCW?(b=c,c=c.Next):(VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.Fill(tcx,b),b=b.Prev)},FinalizationPolygon:function(tcx){for(var t=tcx.aFront.Head.Next.Triangle,p=tcx.aFront.Head.Next.Point;!t.GetConstrainedEdgeCW(p);)t=t.NeighborCCW(p);tcx.MeshClean(t)},PointEvent:function(tcx,point){var node=tcx.LocateNode(point),newNode=VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.NewFrontTriangle(tcx,point,node);return point.X<=node.Point.X+VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationUtil.EPSILON&&VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.Fill(tcx,node),tcx.AddNode(newNode),VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.FillAdvancingFront(tcx,newNode),newNode},NewFrontTriangle:function(tcx,point,node){var triangle=new VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle(point,node.Point,node.Next.Point),newNode;return triangle.MarkNeighbor(node.Triangle),tcx.Triangles.add(triangle),newNode=new VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode(point),newNode.Next=node.Next,newNode.Prev=node,node.Next.Prev=newNode,node.Next=newNode,tcx.AddNode(newNode),VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.Legalize(tcx,triangle)||tcx.MapTriangleToNodes(triangle),newNode},EdgeEvent:function(tcx,edge,node){try{if(tcx.EdgeEvent.ConstrainedEdge=edge,tcx.EdgeEvent.Right=edge.P.X>edge.Q.X,VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.IsEdgeSideOfTriangle(node.Triangle,edge.P,edge.Q))return;VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.FillEdgeEvent(tcx,edge,node);VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.EdgeEvent$1(tcx,edge.P,edge.Q,node.Triangle,edge.Q)}catch($e1){$e1=System.Exception.create($e1);var e;if(Bridge.is($e1,VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.PointOnEdgeException))e=$e1,System.Diagnostics.Debug.WriteLine$4("Skipping Edge: {0}",e.Message);else throw $e1;}},EdgeEvent$1:function(tcx,ep,eq,triangle,point){var p1,o1,p2,o2;if(!VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.IsEdgeSideOfTriangle(triangle,ep,eq)){if(p1=triangle.PointCCW(point),o1=VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationUtil.Orient2d(eq,p1,ep),o1===VelcroPhysics.Tools.Triangulation.Delaunay.Orientation.Collinear){if(triangle.Contains$2(eq,p1))triangle.MarkConstrainedEdge$2(eq,p1),tcx.EdgeEvent.ConstrainedEdge.Q=p1,triangle=triangle.NeighborAcross(point),VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.EdgeEvent$1(tcx,ep,p1,triangle,p1);else throw new VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.PointOnEdgeException("EdgeEvent - Point on constrained edge not supported yet");tcx.IsDebugEnabled&&System.Diagnostics.Debug.WriteLine$2("EdgeEvent - Point on constrained edge");return}if(p2=triangle.PointCW(point),o2=VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationUtil.Orient2d(eq,p2,ep),o2===VelcroPhysics.Tools.Triangulation.Delaunay.Orientation.Collinear){if(triangle.Contains$2(eq,p2))triangle.MarkConstrainedEdge$2(eq,p2),tcx.EdgeEvent.ConstrainedEdge.Q=p2,triangle=triangle.NeighborAcross(point),VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.EdgeEvent$1(tcx,ep,p2,triangle,p2);else throw new VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.PointOnEdgeException("EdgeEvent - Point on constrained edge not supported yet");tcx.IsDebugEnabled&&System.Diagnostics.Debug.WriteLine$2("EdgeEvent - Point on constrained edge");return}o1===o2?(triangle=o1===VelcroPhysics.Tools.Triangulation.Delaunay.Orientation.CW?triangle.NeighborCCW(point):triangle.NeighborCW(point),VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.EdgeEvent$1(tcx,ep,eq,triangle,point)):VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.FlipEdgeEvent(tcx,ep,eq,triangle,point)}},FillEdgeEvent:function(tcx,edge,node){tcx.EdgeEvent.Right?VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.FillRightAboveEdgeEvent(tcx,edge,node):VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.FillLeftAboveEdgeEvent(tcx,edge,node)},FillRightConcaveEdgeEvent:function(tcx,edge,node){VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.Fill(tcx,node.Next);Bridge.referenceEquals(node.Next.Point,edge.P)||VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationUtil.Orient2d(edge.Q,node.Next.Point,edge.P)===VelcroPhysics.Tools.Triangulation.Delaunay.Orientation.CCW&&VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationUtil.Orient2d(node.Point,node.Next.Point,node.Next.Next.Point)===VelcroPhysics.Tools.Triangulation.Delaunay.Orientation.CCW&&VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.FillRightConcaveEdgeEvent(tcx,edge,node)},FillRightConvexEdgeEvent:function(tcx,edge,node){VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationUtil.Orient2d(node.Next.Point,node.Next.Next.Point,node.Next.Next.Next.Point)===VelcroPhysics.Tools.Triangulation.Delaunay.Orientation.CCW?VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.FillRightConcaveEdgeEvent(tcx,edge,node.Next):VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationUtil.Orient2d(edge.Q,node.Next.Next.Point,edge.P)===VelcroPhysics.Tools.Triangulation.Delaunay.Orientation.CCW&&VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.FillRightConvexEdgeEvent(tcx,edge,node.Next)},FillRightBelowEdgeEvent:function(tcx,edge,node){node.Point.X<edge.P.X&&(VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationUtil.Orient2d(node.Point,node.Next.Point,node.Next.Next.Point)===VelcroPhysics.Tools.Triangulation.Delaunay.Orientation.CCW?VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.FillRightConcaveEdgeEvent(tcx,edge,node):(VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.FillRightConvexEdgeEvent(tcx,edge,node),VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.FillRightBelowEdgeEvent(tcx,edge,node)))},FillRightAboveEdgeEvent:function(tcx,edge,node){while(node.Next.Point.X<edge.P.X){var o1=VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationUtil.Orient2d(edge.Q,node.Next.Point,edge.P);o1===VelcroPhysics.Tools.Triangulation.Delaunay.Orientation.CCW?VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.FillRightBelowEdgeEvent(tcx,edge,node):node=node.Next}},FillLeftConvexEdgeEvent:function(tcx,edge,node){VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationUtil.Orient2d(node.Prev.Point,node.Prev.Prev.Point,node.Prev.Prev.Prev.Point)===VelcroPhysics.Tools.Triangulation.Delaunay.Orientation.CW?VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.FillLeftConcaveEdgeEvent(tcx,edge,node.Prev):VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationUtil.Orient2d(edge.Q,node.Prev.Prev.Point,edge.P)===VelcroPhysics.Tools.Triangulation.Delaunay.Orientation.CW&&VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.FillLeftConvexEdgeEvent(tcx,edge,node.Prev)},FillLeftConcaveEdgeEvent:function(tcx,edge,node){VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.Fill(tcx,node.Prev);Bridge.referenceEquals(node.Prev.Point,edge.P)||VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationUtil.Orient2d(edge.Q,node.Prev.Point,edge.P)===VelcroPhysics.Tools.Triangulation.Delaunay.Orientation.CW&&VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationUtil.Orient2d(node.Point,node.Prev.Point,node.Prev.Prev.Point)===VelcroPhysics.Tools.Triangulation.Delaunay.Orientation.CW&&VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.FillLeftConcaveEdgeEvent(tcx,edge,node)},FillLeftBelowEdgeEvent:function(tcx,edge,node){node.Point.X>edge.P.X&&(VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationUtil.Orient2d(node.Point,node.Prev.Point,node.Prev.Prev.Point)===VelcroPhysics.Tools.Triangulation.Delaunay.Orientation.CW?VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.FillLeftConcaveEdgeEvent(tcx,edge,node):(VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.FillLeftConvexEdgeEvent(tcx,edge,node),VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.FillLeftBelowEdgeEvent(tcx,edge,node)))},FillLeftAboveEdgeEvent:function(tcx,edge,node){while(node.Prev.Point.X>edge.P.X){var o1=VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationUtil.Orient2d(edge.Q,node.Prev.Point,edge.P);o1===VelcroPhysics.Tools.Triangulation.Delaunay.Orientation.CW?VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.FillLeftBelowEdgeEvent(tcx,edge,node):node=node.Prev}},IsEdgeSideOfTriangle:function(triangle,ep,eq){var index=triangle.EdgeIndex(ep,eq);return index!==-1?(triangle.MarkConstrainedEdge(index),triangle=triangle.Neighbors.getItem(index),triangle!=null&&triangle.MarkConstrainedEdge$2(ep,eq),!0):!1},FlipEdgeEvent:function(tcx,ep,eq,t,p){var ot=t.NeighborAcross(p),op,inScanArea,o,newP;if(t.GetConstrainedEdgeAcross(p))throw new System.Exception("Intersecting Constraints");op=ot.OppositePoint(t,p);inScanArea=VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationUtil.InScanArea(p,t.PointCCW(p),t.PointCW(p),op);inScanArea?(VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.RotateTrianglePair(t,p,ot,op),tcx.MapTriangleToNodes(t),tcx.MapTriangleToNodes(ot),Bridge.referenceEquals(p,eq)&&Bridge.referenceEquals(op,ep)?Bridge.referenceEquals(eq,tcx.EdgeEvent.ConstrainedEdge.Q)&&Bridge.referenceEquals(ep,tcx.EdgeEvent.ConstrainedEdge.P)?(tcx.IsDebugEnabled&&System.Console.WriteLine("[FLIP] - constrained edge done"),t.MarkConstrainedEdge$2(ep,eq),ot.MarkConstrainedEdge$2(ep,eq),VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.Legalize(tcx,t),VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.Legalize(tcx,ot)):tcx.IsDebugEnabled&&System.Console.WriteLine("[FLIP] - subedge done"):(tcx.IsDebugEnabled&&System.Console.WriteLine("[FLIP] - flipping and continuing with triangle still crossing edge"),o=VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationUtil.Orient2d(eq,op,ep),t=VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.NextFlipTriangle(tcx,o,t,ot,p,op),VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.FlipEdgeEvent(tcx,ep,eq,t,p))):(newP=VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.NextFlipPoint(ep,eq,ot,op),VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.FlipScanEdgeEvent(tcx,ep,eq,t,ot,newP),VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.EdgeEvent$1(tcx,ep,eq,t,p))},NextFlipPoint:function(ep,eq,ot,op){var o2d=VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationUtil.Orient2d(eq,op,ep);if(o2d===VelcroPhysics.Tools.Triangulation.Delaunay.Orientation.CW)return ot.PointCCW(op);else if(o2d===VelcroPhysics.Tools.Triangulation.Delaunay.Orientation.CCW)return ot.PointCW(op);else throw new VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.PointOnEdgeException("Point on constrained edge not supported yet");},NextFlipTriangle:function(tcx,o,t,ot,p,op){var edgeIndex;return o===VelcroPhysics.Tools.Triangulation.Delaunay.Orientation.CCW?(edgeIndex=ot.EdgeIndex(p,op),ot.EdgeIsDelaunay.setItem(edgeIndex,!0),VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.Legalize(tcx,ot),ot.EdgeIsDelaunay.Clear(),t):(edgeIndex=t.EdgeIndex(p,op),t.EdgeIsDelaunay.setItem(edgeIndex,!0),VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.Legalize(tcx,t),t.EdgeIsDelaunay.Clear(),ot)},FlipScanEdgeEvent:function(tcx,ep,eq,flipTriangle,t,p){var ot=t.NeighborAcross(p),op=ot.OppositePoint(t,p),inScanArea=VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationUtil.InScanArea(eq,flipTriangle.PointCCW(eq),flipTriangle.PointCW(eq),op),newP;inScanArea?VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.FlipEdgeEvent(tcx,eq,op,ot,op):(newP=VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.NextFlipPoint(ep,eq,ot,op),VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.FlipScanEdgeEvent(tcx,ep,eq,flipTriangle,ot,newP))},FillAdvancingFront:function(tcx,n){for(var angle,node=n.Next;node.HasNext;){if(VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.LargeHole_DontFill(node))break;VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.Fill(tcx,node);node=node.Next}for(node=n.Prev;node.HasPrev;){if(VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.LargeHole_DontFill(node))break;if(angle=VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.HoleAngle(node),angle>VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.PI_div2||angle<-1.5707963267948966)break;VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.Fill(tcx,node);node=node.Prev}n.HasNext&&n.Next.HasNext&&(angle=VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.BasinAngle(n),angle<VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.PI_3div4&&VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.FillBasin(tcx,n))},LargeHole_DontFill:function(node){var nextNode=node.Next,prevNode=node.Prev,next2Node,prev2Node;return VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.AngleExceeds90Degrees(node.Point,nextNode.Point,prevNode.Point)?(next2Node=nextNode.Next,next2Node!=null&&!VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.AngleExceedsPlus90DegreesOrIsNegative(node.Point,next2Node.Point,prevNode.Point))?!1:(prev2Node=prevNode.Prev,prev2Node!=null&&!VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.AngleExceedsPlus90DegreesOrIsNegative(node.Point,nextNode.Point,prev2Node.Point))?!1:!0:!1},AngleExceeds90Degrees:function(origin,pa,pb){var angle=VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.Angle(origin,pa,pb);return angle>VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.PI_div2||angle<-1.5707963267948966},AngleExceedsPlus90DegreesOrIsNegative:function(origin,pa,pb){var angle=VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.Angle(origin,pa,pb);return angle>VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.PI_div2||angle<0},Angle:function(origin,pa,pb){var px=origin.X,py=origin.Y,ax=pa.X-px,ay=pa.Y-py,bx=pb.X-px,by=pb.Y-py,x=ax*by-ay*bx,y=ax*bx+ay*by;return Math.atan2(x,y)},FillBasin:function(tcx,node){for(tcx.Basin.leftNode=VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationUtil.Orient2d(node.Point,node.Next.Point,node.Next.Next.Point)===VelcroPhysics.Tools.Triangulation.Delaunay.Orientation.CCW?node:node.Next,tcx.Basin.bottomNode=tcx.Basin.leftNode;tcx.Basin.bottomNode.HasNext&&tcx.Basin.bottomNode.Point.Y>=tcx.Basin.bottomNode.Next.Point.Y;)tcx.Basin.bottomNode=tcx.Basin.bottomNode.Next;if(!Bridge.referenceEquals(tcx.Basin.bottomNode,tcx.Basin.leftNode)){for(tcx.Basin.rightNode=tcx.Basin.bottomNode;tcx.Basin.rightNode.HasNext&&tcx.Basin.rightNode.Point.Y<tcx.Basin.rightNode.Next.Point.Y;)tcx.Basin.rightNode=tcx.Basin.rightNode.Next;Bridge.referenceEquals(tcx.Basin.rightNode,tcx.Basin.bottomNode)||(tcx.Basin.width=tcx.Basin.rightNode.Point.X-tcx.Basin.leftNode.Point.X,tcx.Basin.leftHighest=tcx.Basin.leftNode.Point.Y>tcx.Basin.rightNode.Point.Y,VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.FillBasinReq(tcx,tcx.Basin.bottomNode))}},FillBasinReq:function(tcx,node){var o,o1;if(!VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.IsShallow(tcx,node)){if(VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.Fill(tcx,node),Bridge.referenceEquals(node.Prev,tcx.Basin.leftNode)&&Bridge.referenceEquals(node.Next,tcx.Basin.rightNode))return;else if(Bridge.referenceEquals(node.Prev,tcx.Basin.leftNode)){if(o=VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationUtil.Orient2d(node.Point,node.Next.Point,node.Next.Next.Point),o===VelcroPhysics.Tools.Triangulation.Delaunay.Orientation.CW)return;node=node.Next}else if(Bridge.referenceEquals(node.Next,tcx.Basin.rightNode)){if(o1=VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationUtil.Orient2d(node.Point,node.Prev.Point,node.Prev.Prev.Point),o1===VelcroPhysics.Tools.Triangulation.Delaunay.Orientation.CCW)return;node=node.Prev}else node=node.Prev.Point.Y<node.Next.Point.Y?node.Prev:node.Next;VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.FillBasinReq(tcx,node)}},IsShallow:function(tcx,node){var height;return(height=tcx.Basin.leftHighest?tcx.Basin.leftNode.Point.Y-node.Point.Y:tcx.Basin.rightNode.Point.Y-node.Point.Y,tcx.Basin.width>height)?!0:!1},HoleAngle:function(node){var px=node.Point.X,py=node.Point.Y,ax=node.Next.Point.X-px,ay=node.Next.Point.Y-py,bx=node.Prev.Point.X-px,by=node.Prev.Point.Y-py;return Math.atan2(ax*by-ay*bx,ax*bx+ay*by)},BasinAngle:function(node){var ax=node.Point.X-node.Next.Next.Point.X,ay=node.Point.Y-node.Next.Next.Point.Y;return Math.atan2(ay,ax)},Fill:function(tcx,node){var triangle=new VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle(node.Prev.Point,node.Point,node.Next.Point);triangle.MarkNeighbor(node.Prev.Triangle);triangle.MarkNeighbor(node.Triangle);tcx.Triangles.add(triangle);node.Prev.Next=node.Next;node.Next.Prev=node.Prev;tcx.RemoveNode(node);VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.Legalize(tcx,triangle)||tcx.MapTriangleToNodes(triangle)},Legalize:function(tcx,t){for(var ot,inside,notLegalized,i=0;i<3;i=i+1|0)if(!t.EdgeIsDelaunay.getItem(i)&&(ot=t.Neighbors.getItem(i),ot!=null)){var p=t.Points.getItem(i),op=ot.OppositePoint(t,p),oi=ot.IndexOf(op);if(ot.EdgeIsConstrained.getItem(oi)||ot.EdgeIsDelaunay.getItem(oi)){t.EdgeIsConstrained.setItem(i,ot.EdgeIsConstrained.getItem(oi));continue}if(inside=VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationUtil.SmartIncircle(p,t.PointCCW(p),t.PointCW(p),op),inside)return t.EdgeIsDelaunay.setItem(i,!0),ot.EdgeIsDelaunay.setItem(oi,!0),VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.RotateTrianglePair(t,p,ot,op),notLegalized=!VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.Legalize(tcx,t),notLegalized&&tcx.MapTriangleToNodes(t),notLegalized=!VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweep.Legalize(tcx,ot),notLegalized&&tcx.MapTriangleToNodes(ot),t.EdgeIsDelaunay.setItem(i,!1),ot.EdgeIsDelaunay.setItem(oi,!1),!0}return!1},RotateTrianglePair:function(t,p,ot,op){var n1=t.NeighborCCW(p),n2=t.NeighborCW(p),n3=ot.NeighborCCW(op),n4=ot.NeighborCW(op),ce1=t.GetConstrainedEdgeCCW(p),ce2=t.GetConstrainedEdgeCW(p),ce3=ot.GetConstrainedEdgeCCW(op),ce4=ot.GetConstrainedEdgeCW(op),de1=t.GetDelaunayEdgeCCW(p),de2=t.GetDelaunayEdgeCW(p),de3=ot.GetDelaunayEdgeCCW(op),de4=ot.GetDelaunayEdgeCW(op);t.Legalize(p,op);ot.Legalize(op,p);ot.SetDelaunayEdgeCCW(p,de1);t.SetDelaunayEdgeCW(p,de2);t.SetDelaunayEdgeCCW(op,de3);ot.SetDelaunayEdgeCW(op,de4);ot.SetConstrainedEdgeCCW(p,ce1);t.SetConstrainedEdgeCW(p,ce2);t.SetConstrainedEdgeCCW(op,ce3);ot.SetConstrainedEdgeCW(op,ce4);t.Neighbors.Clear();ot.Neighbors.Clear();n1!=null&&ot.MarkNeighbor(n1);n2!=null&&t.MarkNeighbor(n2);n3!=null&&t.MarkNeighbor(n3);n4!=null&&ot.MarkNeighbor(n4);t.MarkNeighbor(ot)}}}});Bridge.define("VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationConstraint",{fields:{P:null,Q:null}});Bridge.define("VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationContext",{fields:{Points:null,Triangles:null,_stepTime:0,TriangulationMode:0,Triangulatable:null,WaitUntilNotified:!1,Terminated:!1,StepCount:0,IsDebugEnabled:!1},ctors:{init:function(){this.Points=new(System.Collections.Generic.List$1(VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationPoint).$ctor2)(200);this.Triangles=new(System.Collections.Generic.List$1(VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle).ctor);this._stepTime=-1},ctor:function(){this.$initialize();this.Terminated=!1}},methods:{Done:function(){this.StepCount=this.StepCount+1|0},PrepareTriangulation:function(t){this.Triangulatable=t;this.TriangulationMode=t.VelcroPhysics$Tools$Triangulation$Delaunay$Triangulatable$TriangulationMode;t.VelcroPhysics$Tools$Triangulation$Delaunay$Triangulatable$PrepareTriangulation(this)},Update:function(message){},Clear:function(){this.Points.clear();this.Terminated=!1;this.StepCount=0}}});Bridge.define("VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweepContext.DTSweepBasin",{$kind:"nested class",fields:{bottomNode:null,leftHighest:!1,leftNode:null,rightNode:null,width:0}});Bridge.define("VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweepContext.DTSweepEdgeEvent",{$kind:"nested class",fields:{ConstrainedEdge:null,Right:!1}});Bridge.define("VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationPoint",{fields:{X:0,Y:0,Edges:null},props:{Xf:{get:function(){return this.X},set:function(value){this.X=value}},Yf:{get:function(){return this.Y},set:function(value){this.Y=value}},HasEdges:{get:function(){return this.Edges!=null}}},ctors:{ctor:function(x,y){this.$initialize();this.X=x;this.Y=y}},methods:{toString:function(){return"["+System.Double.format(this.X)+","+System.Double.format(this.Y)+"]"},AddEdge:function(e){this.Edges==null&&(this.Edges=new(System.Collections.Generic.List$1(VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweepConstraint).ctor));this.Edges.add(e)}}});Bridge.define("VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.PointOnEdgeException",{inherits:[System.NotImplementedException],ctors:{ctor:function(message){this.$initialize();System.NotImplementedException.$ctor1.call(this,message)}}});Bridge.define("VelcroPhysics.Tools.Triangulation.Delaunay.Orientation",{$kind:"enum",statics:{fields:{CW:0,CCW:1,Collinear:2}}});Bridge.define("VelcroPhysics.Tools.Triangulation.Delaunay.Triangulatable",{$kind:"interface"});Bridge.define("VelcroPhysics.Tools.Triangulation.Delaunay.Polygon.PolygonSet",{fields:{_polygons:null},props:{Polygons:{get:function(){return this._polygons}}},ctors:{init:function(){this._polygons=new(System.Collections.Generic.List$1(VelcroPhysics.Tools.Triangulation.Delaunay.Polygon.Polygon).ctor)},ctor:function(){this.$initialize()},$ctor1:function(poly){this.$initialize();this._polygons.add(poly)}},methods:{Add:function(p){this._polygons.add(p)}}});Bridge.define("VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationMode",{$kind:"enum",statics:{fields:{Unconstrained:0,Constrained:1,Polygon:2}}});Bridge.define("VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationUtil",{statics:{fields:{EPSILON:0},ctors:{init:function(){this.EPSILON=1e-12}},methods:{SmartIncircle:function(pa,pb,pc,pd){var pdx=pd.X,pdy=pd.Y,adx=pa.X-pdx,ady=pa.Y-pdy,bdx=pb.X-pdx,bdy=pb.Y-pdy,adxbdy=adx*bdy,bdxady=bdx*ady,oabd=adxbdy-bdxady;if(oabd<=0)return!1;var cdx=pc.X-pdx,cdy=pc.Y-pdy,cdxady=cdx*ady,adxcdy=adx*cdy,ocad=cdxady-adxcdy;if(ocad<=0)return!1;var bdxcdy=bdx*cdy,cdxbdy=cdx*bdy,alift=adx*adx+ady*ady,blift=bdx*bdx+bdy*bdy,clift=cdx*cdx+cdy*cdy,det=alift*(bdxcdy-cdxbdy)+blift*ocad+clift*oabd;return det>0},InScanArea:function(pa,pb,pc,pd){var oadb=(pa.X-pb.X)*(pd.Y-pb.Y)-(pd.X-pb.X)*(pa.Y-pb.Y),oadc;return oadb>=-VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationUtil.EPSILON?!1:(oadc=(pa.X-pc.X)*(pd.Y-pc.Y)-(pd.X-pc.X)*(pa.Y-pc.Y),oadc<=VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationUtil.EPSILON)?!1:!0},Orient2d:function(pa,pb,pc){var detleft=(pa.X-pc.X)*(pb.Y-pc.Y),detright=(pa.Y-pc.Y)*(pb.X-pc.X),val=detleft-detright;return val>-VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationUtil.EPSILON&&val<VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationUtil.EPSILON?VelcroPhysics.Tools.Triangulation.Delaunay.Orientation.Collinear:val>0?VelcroPhysics.Tools.Triangulation.Delaunay.Orientation.CCW:VelcroPhysics.Tools.Triangulation.Delaunay.Orientation.CW}}}});Bridge.define("VelcroPhysics.Tools.Triangulation.Delaunay.Util.PointGenerator",{statics:{fields:{RNG:null},ctors:{init:function(){this.RNG=new System.Random.ctor}},methods:{UniformDistribution:function(n,scale){for(var points=new(System.Collections.Generic.List$1(VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationPoint).ctor),i=0;i<n;i=i+1|0)points.add(new VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationPoint(scale*(.5-VelcroPhysics.Tools.Triangulation.Delaunay.Util.PointGenerator.RNG.NextDouble()),scale*(.5-VelcroPhysics.Tools.Triangulation.Delaunay.Util.PointGenerator.RNG.NextDouble())));return points},UniformGrid:function(n,scale){for(var j,x=0,size=scale/n,halfScale=.5*scale,points=new(System.Collections.Generic.List$1(VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationPoint).ctor),i=0;i<(n+1|0);i=i+1|0)for(x=halfScale-i*size,j=0;j<(n+1|0);j=j+1|0)points.add(new VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationPoint(x,halfScale-j*size));return points}}}});Bridge.define("VelcroPhysics.Tools.Triangulation.Delaunay.Util.PolygonGenerator",{statics:{fields:{RNG:null,PI_2:0},ctors:{init:function(){this.RNG=new System.Random.ctor;this.PI_2=6.2831853071795862}},methods:{RandomCircleSweep:function(scale,vertexCount){for(var point,radius=scale/4,points=System.Array.init(vertexCount,null,VelcroPhysics.Tools.Triangulation.Delaunay.Polygon.PolygonPoint),i=0;i<vertexCount;i=i+1|0){do radius+=i%250==0?scale/2*(.5-VelcroPhysics.Tools.Triangulation.Delaunay.Util.PolygonGenerator.RNG.NextDouble()):i%50==0?scale/5*(.5-VelcroPhysics.Tools.Triangulation.Delaunay.Util.PolygonGenerator.RNG.NextDouble()):25*scale/vertexCount*(.5-VelcroPhysics.Tools.Triangulation.Delaunay.Util.PolygonGenerator.RNG.NextDouble()),radius=radius>scale/2?scale/2:radius,radius=radius<scale/10?scale/10:radius;while(radius<scale/10||radius>scale/2);point=new VelcroPhysics.Tools.Triangulation.Delaunay.Polygon.PolygonPoint(radius*Math.cos(VelcroPhysics.Tools.Triangulation.Delaunay.Util.PolygonGenerator.PI_2*i/vertexCount),radius*Math.sin(VelcroPhysics.Tools.Triangulation.Delaunay.Util.PolygonGenerator.PI_2*i/vertexCount));points[i]=point}return new VelcroPhysics.Tools.Triangulation.Delaunay.Polygon.Polygon.$ctor2(points)},RandomCircleSweep2:function(scale,vertexCount){for(var point,radius=scale/4,points=System.Array.init(vertexCount,null,VelcroPhysics.Tools.Triangulation.Delaunay.Polygon.PolygonPoint),i=0;i<vertexCount;i=i+1|0){do radius+=scale/5*(.5-VelcroPhysics.Tools.Triangulation.Delaunay.Util.PolygonGenerator.RNG.NextDouble()),radius=radius>scale/2?scale/2:radius,radius=radius<scale/10?scale/10:radius;while(radius<scale/10||radius>scale/2);point=new VelcroPhysics.Tools.Triangulation.Delaunay.Polygon.PolygonPoint(radius*Math.cos(VelcroPhysics.Tools.Triangulation.Delaunay.Util.PolygonGenerator.PI_2*i/vertexCount),radius*Math.sin(VelcroPhysics.Tools.Triangulation.Delaunay.Util.PolygonGenerator.PI_2*i/vertexCount));points[i]=point}return new VelcroPhysics.Tools.Triangulation.Delaunay.Polygon.Polygon.$ctor2(points)}}}});Bridge.define("VelcroPhysics.Tools.Triangulation.Earclip.EarclipDecomposer",{statics:{methods:{ConvexPartition:function(vertices,tolerance){return tolerance===void 0&&(tolerance=.001),System.Diagnostics.Debug.Assert(vertices.Count>3),System.Diagnostics.Debug.Assert(!vertices.IsCounterClockWise()),VelcroPhysics.Tools.Triangulation.Earclip.EarclipDecomposer.TriangulatePolygon(vertices,tolerance)},TriangulatePolygon:function(vertices,tolerance){var mergeA,mergeB,i,i1,i2,vNum,earIndex,earMaxMinCross,i3,cross12,cross23,cross31,minCross,i4,i5,tooAdd,i6;if(vertices.Count<3)return new(System.Collections.Generic.List$1(VelcroPhysics.Shared.Vertices).ctor);var results=new(System.Collections.Generic.List$1(VelcroPhysics.Shared.Vertices).ctor),pA={},pB={},pin=new VelcroPhysics.Shared.Vertices.$ctor1(vertices);if(VelcroPhysics.Tools.Triangulation.Earclip.EarclipDecomposer.ResolvePinchPoint(pin,pA,pB,tolerance)){if(mergeA=VelcroPhysics.Tools.Triangulation.Earclip.EarclipDecomposer.TriangulatePolygon(pA.v,tolerance),mergeB=VelcroPhysics.Tools.Triangulation.Earclip.EarclipDecomposer.TriangulatePolygon(pB.v,tolerance),mergeA.Count===-1||mergeB.Count===-1)throw new System.Exception("Can't triangulate your polygon.");for(i=0;i<mergeA.Count;i=i+1|0)results.add(new VelcroPhysics.Shared.Vertices.$ctor1(mergeA.getItem(i)));for(i1=0;i1<mergeB.Count;i1=i1+1|0)results.add(new VelcroPhysics.Shared.Vertices.$ctor1(mergeB.getItem(i1)));return results}var buffer=System.Array.init(vertices.Count-2|0,null,VelcroPhysics.Shared.Vertices),bufferSize=0,xrem=System.Array.init(new Float32Array(vertices.Count),System.Single),yrem=System.Array.init(new Float32Array(vertices.Count),System.Single);for(i2=0;i2<vertices.Count;i2=i2+1|0)xrem[i2]=vertices.getItem(i2).$clone().X,yrem[i2]=vertices.getItem(i2).$clone().Y;for(vNum=vertices.Count;vNum>3;){for(earIndex=-1,earMaxMinCross=-10,i3=0;i3<vNum;i3=i3+1|0)if(VelcroPhysics.Tools.Triangulation.Earclip.EarclipDecomposer.IsEar(i3,xrem,yrem,vNum)){var lower=VelcroPhysics.Tools.Triangulation.Earclip.EarclipDecomposer.Remainder(i3-1|0,vNum),upper=VelcroPhysics.Tools.Triangulation.Earclip.EarclipDecomposer.Remainder(i3+1|0,vNum),d1={v:new Microsoft.Xna.Framework.Vector2.$ctor2(xrem[upper]-xrem[i3],yrem[upper]-yrem[i3])},d2={v:new Microsoft.Xna.Framework.Vector2.$ctor2(xrem[i3]-xrem[lower],yrem[i3]-yrem[lower])},d3={v:new Microsoft.Xna.Framework.Vector2.$ctor2(xrem[lower]-xrem[upper],yrem[lower]-yrem[upper])};d1.v.Normalize();d2.v.Normalize();d3.v.Normalize();cross12={};VelcroPhysics.Utilities.MathUtils.Cross$5(d1,d2,cross12);cross12.v=Math.abs(cross12.v);cross23={};VelcroPhysics.Utilities.MathUtils.Cross$5(d2,d3,cross23);cross23.v=Math.abs(cross23.v);cross31={};VelcroPhysics.Utilities.MathUtils.Cross$5(d3,d1,cross31);cross31.v=Math.abs(cross31.v);minCross=Math.min(cross12.v,Math.min(cross23.v,cross31.v));minCross>earMaxMinCross&&(earIndex=i3,earMaxMinCross=minCross)}if(earIndex===-1){for(i4=0;i4<bufferSize;i4=i4+1|0)results.add(buffer[i4]);return results}vNum=vNum-1|0;var newx=System.Array.init(new Float32Array(vNum),System.Single),newy=System.Array.init(new Float32Array(vNum),System.Single),currDest=0;for(i5=0;i5<vNum;i5=i5+1|0)currDest===earIndex&&(currDest=currDest+1|0),newx[i5]=xrem[currDest],newy[i5]=yrem[currDest],currDest=currDest+1|0;var under=earIndex===0?vNum:earIndex-1|0,over=earIndex===vNum?0:earIndex+1|0,toAdd=new VelcroPhysics.Tools.Triangulation.Earclip.Triangle(xrem[earIndex],yrem[earIndex],xrem[over],yrem[over],xrem[under],yrem[under]);buffer[bufferSize]=toAdd;bufferSize=bufferSize+1|0;xrem=newx;yrem=newy}for(tooAdd=new VelcroPhysics.Tools.Triangulation.Earclip.Triangle(xrem[1],yrem[1],xrem[2],yrem[2],xrem[0],yrem[0]),buffer[bufferSize]=tooAdd,bufferSize=bufferSize+1|0,i6=0;i6<bufferSize;i6=i6+1|0)results.add(new VelcroPhysics.Shared.Vertices.$ctor1(buffer[i6]));return results},ResolvePinchPoint:function(pin,poutA,poutB,tolerance){var i,j,sizeA,i1,ind,sizeB,i2,ind1;if(poutA.v=new VelcroPhysics.Shared.Vertices.ctor,poutB.v=new VelcroPhysics.Shared.Vertices.ctor,pin.Count<3)return!1;var hasPinchPoint=!1,pinchIndexA=-1,pinchIndexB=-1;for(i=0;i<pin.Count;i=i+1|0){for(j=i+1|0;j<pin.Count;j=j+1|0)if(Math.abs(pin.getItem(i).$clone().X-pin.getItem(j).$clone().X)<tolerance&&Math.abs(pin.getItem(i).$clone().Y-pin.getItem(j).$clone().Y)<tolerance&&j!==(i+1|0)){pinchIndexA=i;pinchIndexB=j;hasPinchPoint=!0;break}if(hasPinchPoint)break}if(hasPinchPoint){if(sizeA=pinchIndexB-pinchIndexA|0,sizeA===pin.Count)return!1;for(i1=0;i1<sizeA;i1=i1+1|0)ind=VelcroPhysics.Tools.Triangulation.Earclip.EarclipDecomposer.Remainder(pinchIndexA+i1|0,pin.Count),poutA.v.add(pin.getItem(ind).$clone());for(sizeB=pin.Count-sizeA|0,i2=0;i2<sizeB;i2=i2+1|0)ind1=VelcroPhysics.Tools.Triangulation.Earclip.EarclipDecomposer.Remainder(pinchIndexB+i2|0,pin.Count),poutB.v.add(pin.getItem(ind1).$clone())}return hasPinchPoint},Remainder:function(x,modulus){for(var rem=x%modulus;rem<0;)rem=rem+modulus|0;return rem},IsEar:function(i,xv,yv,xvLength){var dx0,dy0,dx1,dy1,upper,lower,cross,myTri,j;if(i>=xvLength||i<0||xvLength<3||(upper=i+1|0,lower=i-1|0,i===0?(dx0=xv[0]-xv[xvLength-1|0],dy0=yv[0]-yv[xvLength-1|0],dx1=xv[1]-xv[0],dy1=yv[1]-yv[0],lower=xvLength-1|0):i===(xvLength-1|0)?(dx0=xv[i]-xv[i-1|0],dy0=yv[i]-yv[i-1|0],dx1=xv[0]-xv[i],dy1=yv[0]-yv[i],upper=0):(dx0=xv[i]-xv[i-1|0],dy0=yv[i]-yv[i-1|0],dx1=xv[i+1|0]-xv[i],dy1=yv[i+1|0]-yv[i]),cross=dx0*dy1-dx1*dy0,cross>0))return!1;for(myTri=new VelcroPhysics.Tools.Triangulation.Earclip.Triangle(xv[i],yv[i],xv[upper],yv[upper],xv[lower],yv[lower]),j=0;j<xvLength;j=j+1|0)if(j!==i&&j!==lower&&j!==upper&&myTri.IsInside(xv[j],yv[j]))return!1;return!0}}}});Bridge.define("VelcroPhysics.Tools.Triangulation.FlipCode.FlipcodeDecomposer",{statics:{fields:{_tmpA:null,_tmpB:null,_tmpC:null},ctors:{init:function(){this._tmpA=new Microsoft.Xna.Framework.Vector2;this._tmpB=new Microsoft.Xna.Framework.Vector2;this._tmpC=new Microsoft.Xna.Framework.Vector2}},methods:{ConvexPartition:function(vertices){var polygon,v,v1,u,w,s,t,triangle;for(System.Diagnostics.Debug.Assert(vertices.Count>3),System.Diagnostics.Debug.Assert(vertices.IsCounterClockWise()),polygon=System.Array.init(new Int32Array(vertices.Count),System.Int32),v=0;v<vertices.Count;v=v+1|0)polygon[v]=v;var nv=vertices.Count,count=Bridge.Int.mul(2,nv),result=new(System.Collections.Generic.List$1(VelcroPhysics.Shared.Vertices).ctor);for(v1=nv-1|0;nv>2;){if(0>=Bridge.identity(count,count=count-1|0))return new(System.Collections.Generic.List$1(VelcroPhysics.Shared.Vertices).ctor);if(u=v1,nv<=u&&(u=0),v1=u+1|0,nv<=v1&&(v1=0),w=v1+1|0,nv<=w&&(w=0),VelcroPhysics.Tools.Triangulation.FlipCode.FlipcodeDecomposer._tmpA=vertices.getItem(polygon[u]).$clone(),VelcroPhysics.Tools.Triangulation.FlipCode.FlipcodeDecomposer._tmpB=vertices.getItem(polygon[v1]).$clone(),VelcroPhysics.Tools.Triangulation.FlipCode.FlipcodeDecomposer._tmpC=vertices.getItem(polygon[w]).$clone(),VelcroPhysics.Tools.Triangulation.FlipCode.FlipcodeDecomposer.Snip(vertices,u,v1,w,nv,polygon)){for(triangle=new VelcroPhysics.Shared.Vertices.$ctor2(3),triangle.add(VelcroPhysics.Tools.Triangulation.FlipCode.FlipcodeDecomposer._tmpA.$clone()),triangle.add(VelcroPhysics.Tools.Triangulation.FlipCode.FlipcodeDecomposer._tmpB.$clone()),triangle.add(VelcroPhysics.Tools.Triangulation.FlipCode.FlipcodeDecomposer._tmpC.$clone()),result.add(triangle),s=v1,t=v1+1|0;t<nv;s=s+1|0,t=t+1|0)polygon[s]=polygon[t];nv=nv-1|0;count=Bridge.Int.mul(2,nv)}}return result},InsideTriangle:function(a,b,c,p){var abp=(c.v.X-b.v.X)*(p.v.Y-b.v.Y)-(c.v.Y-b.v.Y)*(p.v.X-b.v.X),aap=(b.v.X-a.v.X)*(p.v.Y-a.v.Y)-(b.v.Y-a.v.Y)*(p.v.X-a.v.X),bcp=(a.v.X-c.v.X)*(p.v.Y-c.v.Y)-(a.v.Y-c.v.Y)*(p.v.X-c.v.X);return abp>=0&&bcp>=0&&aap>=0},Snip:function(contour,u,v,w,n,V){var p,point;if(VelcroPhysics.Settings.Epsilon>VelcroPhysics.Utilities.MathUtils.Area$1(Bridge.ref(VelcroPhysics.Tools.Triangulation.FlipCode.FlipcodeDecomposer,"_tmpA"),Bridge.ref(VelcroPhysics.Tools.Triangulation.FlipCode.FlipcodeDecomposer,"_tmpB"),Bridge.ref(VelcroPhysics.Tools.Triangulation.FlipCode.FlipcodeDecomposer,"_tmpC")))return!1;for(p=0;p<n;p=p+1|0)if(p!==u&&p!==v&&p!==w&&(point={v:contour.getItem(V[p]).$clone()},VelcroPhysics.Tools.Triangulation.FlipCode.FlipcodeDecomposer.InsideTriangle(Bridge.ref(VelcroPhysics.Tools.Triangulation.FlipCode.FlipcodeDecomposer,"_tmpA"),Bridge.ref(VelcroPhysics.Tools.Triangulation.FlipCode.FlipcodeDecomposer,"_tmpB"),Bridge.ref(VelcroPhysics.Tools.Triangulation.FlipCode.FlipcodeDecomposer,"_tmpC"),point)))return!1;return!0}}}});Bridge.define("VelcroPhysics.Tools.Triangulation.Seidel.Edge",{fields:{Above:null,B:0,Below:null,MPoints:null,P:null,Q:null,Slope:0},ctors:{ctor:function(p,q){this.$initialize();this.P=p;this.Q=q;this.Slope=q.X-p.X!=0?(q.Y-p.Y)/(q.X-p.X):0;this.B=p.Y-p.X*this.Slope;this.Above=null;this.Below=null;this.MPoints=new(System.Collections.Generic.HashSet$1(VelcroPhysics.Tools.Triangulation.Seidel.Point).ctor);this.MPoints.add(p);this.MPoints.add(q)}},methods:{IsAbove:function(point){return this.P.Orient2D(this.Q,point)<0},IsBelow:function(point){return this.P.Orient2D(this.Q,point)>0},AddMpoint:function(point){var $t,mp;$t=Bridge.getEnumerator(this.MPoints);try{while($t.moveNext())if(mp=$t.Current,!mp.Neq(point))return}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}this.MPoints.add(point)}}});Bridge.define("VelcroPhysics.Tools.Triangulation.Seidel.MonotoneMountain",{statics:{fields:{PiSlop:0},ctors:{init:function(){this.PiSlop=3.1}}},fields:{_convexPoints:null,_head:null,_monoPoly:null,_positive:!1,_size:0,_tail:null,Triangles:null},ctors:{ctor:function(){this.$initialize();this._size=0;this._tail=null;this._head=null;this._positive=!1;this._convexPoints=new(System.Collections.Generic.HashSet$1(VelcroPhysics.Tools.Triangulation.Seidel.Point).ctor);this._monoPoly=new(System.Collections.Generic.List$1(VelcroPhysics.Tools.Triangulation.Seidel.Point).ctor);this.Triangles=new(System.Collections.Generic.List$1(System.Collections.Generic.List$1(VelcroPhysics.Tools.Triangulation.Seidel.Point)).ctor)}},methods:{Add:function(point){this._size===0?(this._head=point,this._size=1):this._size===1?(this._tail=point,this._tail.Prev=this._head,this._head.Next=this._tail,this._size=2):(this._tail.Next=point,point.Prev=this._tail,this._tail=point,this._size=this._size+1|0)},Remove:function(point){var next=point.Next,prev=point.Prev;point.Prev.Next=next;point.Next.Prev=prev;this._size=this._size-1|0},Process:function(){var p,a;for(this._positive=this.AngleSign(),this.GenMonoPoly(),p=this._head.Next;p.Neq(this._tail);)a=this.Angle(p),a>=VelcroPhysics.Tools.Triangulation.Seidel.MonotoneMountain.PiSlop||a<=-3.1||a===0?this.Remove(p):this.IsConvex(p)&&this._convexPoints.add(p),p=p.Next;this.Triangulate()},Triangulate:function(){for(var e,ear;this._convexPoints.Count!==0;){e=this._convexPoints.GetEnumerator();e.System$Collections$IEnumerator$moveNext();ear=e[Bridge.geti(e,"System$Collections$Generic$IEnumerator$1$VelcroPhysics$Tools$Triangulation$Seidel$Point$Current$1","System$Collections$Generic$IEnumerator$1$Current$1")];this._convexPoints.remove(ear);var a=ear.Prev,b=ear,c=ear.Next,triangle=new(System.Collections.Generic.List$1(VelcroPhysics.Tools.Triangulation.Seidel.Point).$ctor2)(3);triangle.add(a);triangle.add(b);triangle.add(c);this.Triangles.add(triangle);this.Remove(ear);this.Valid(a)&&this._convexPoints.add(a);this.Valid(c)&&this._convexPoints.add(c)}System.Diagnostics.Debug.Assert$1(this._size<=3,"Triangulation bug, please report")},Valid:function(p){return p.Neq(this._head)&&p.Neq(this._tail)&&this.IsConvex(p)},GenMonoPoly:function(){for(var p=this._head;p!=null;)this._monoPoly.add(p),p=p.Next},Angle:function(p){var a=VelcroPhysics.Tools.Triangulation.Seidel.Point.op_Subtraction$1(p.Next,p),b=VelcroPhysics.Tools.Triangulation.Seidel.Point.op_Subtraction$1(p.Prev,p);return Math.atan2(a.Cross(b),a.Dot(b))},AngleSign:function(){var a=VelcroPhysics.Tools.Triangulation.Seidel.Point.op_Subtraction$1(this._head.Next,this._head),b=VelcroPhysics.Tools.Triangulation.Seidel.Point.op_Subtraction$1(this._tail,this._head);return Math.atan2(a.Cross(b),a.Dot(b))>=0},IsConvex:function(p){return this._positive!==this.Angle(p)>=0?!1:!0}}});Bridge.define("VelcroPhysics.Tools.Triangulation.Seidel.Node",{fields:{LeftChild:null,ParentList:null,RightChild:null},ctors:{ctor:function(left,right){this.$initialize();this.ParentList=new(System.Collections.Generic.List$1(VelcroPhysics.Tools.Triangulation.Seidel.Node).ctor);this.LeftChild=left;this.RightChild=right;left!=null&&left.ParentList.add(this);right!=null&&right.ParentList.add(this)}},methods:{Replace:function(node){var $t,parent;$t=Bridge.getEnumerator(node.ParentList);try{while($t.moveNext())parent=$t.Current,Bridge.referenceEquals(parent.LeftChild,node)?parent.LeftChild=this:parent.RightChild=this}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}this.ParentList.AddRange(node.ParentList)}}});Bridge.define("VelcroPhysics.Tools.Triangulation.Seidel.Point",{statics:{methods:{op_Subtraction$1:function(p1,p2){return new VelcroPhysics.Tools.Triangulation.Seidel.Point(p1.X-p2.X,p1.Y-p2.Y)},op_Subtraction:function(p1,f){return new VelcroPhysics.Tools.Triangulation.Seidel.Point(p1.X-f,p1.Y-f)},op_Addition$1:function(p1,p2){return new VelcroPhysics.Tools.Triangulation.Seidel.Point(p1.X+p2.X,p1.Y+p2.Y)},op_Addition:function(p1,f){return new VelcroPhysics.Tools.Triangulation.Seidel.Point(p1.X+f,p1.Y+f)}}},fields:{Next:null,Prev:null,X:0,Y:0},ctors:{ctor:function(x,y){this.$initialize();this.X=x;this.Y=y;this.Next=null;this.Prev=null}},methods:{Cross:function(p){return this.X*p.Y-this.Y*p.X},Dot:function(p){return this.X*p.X+this.Y*p.Y},Neq:function(p){return p.X!==this.X||p.Y!==this.Y},Orient2D:function(pb,pc){var acx=this.X-pc.X,bcx=pb.X-pc.X,acy=this.Y-pc.Y,bcy=pb.Y-pc.Y;return acx*bcy-acy*bcx}}});Bridge.define("VelcroPhysics.Tools.Triangulation.Seidel.QueryGraph",{fields:{_head:null},ctors:{ctor:function(head){this.$initialize();this._head=head}},methods:{Locate:function(edge){return this._head.Locate(edge).Trapezoid},FollowEdge:function(edge){var trapezoids=new(System.Collections.Generic.List$1(VelcroPhysics.Tools.Triangulation.Seidel.Trapezoid).ctor),j;for(trapezoids.add(this.Locate(edge)),j=0;edge.Q.X>trapezoids.getItem(j).RightPoint.X;)edge.IsAbove(trapezoids.getItem(j).RightPoint)?trapezoids.add(trapezoids.getItem(j).UpperRight):trapezoids.add(trapezoids.getItem(j).LowerRight),j=j+1|0;return trapezoids},Replace:function(sink,node){sink.ParentList.Count===0?this._head=node:node.Replace(sink)},Case1:function(sink,edge,tList){var yNode=new VelcroPhysics.Tools.Triangulation.Seidel.YNode(edge,VelcroPhysics.Tools.Triangulation.Seidel.Sink.Isink(tList[1]),VelcroPhysics.Tools.Triangulation.Seidel.Sink.Isink(tList[2])),qNode=new VelcroPhysics.Tools.Triangulation.Seidel.XNode(edge.Q,yNode,VelcroPhysics.Tools.Triangulation.Seidel.Sink.Isink(tList[3])),pNode=new VelcroPhysics.Tools.Triangulation.Seidel.XNode(edge.P,VelcroPhysics.Tools.Triangulation.Seidel.Sink.Isink(tList[0]),qNode);this.Replace(sink,pNode)},Case2:function(sink,edge,tList){var yNode=new VelcroPhysics.Tools.Triangulation.Seidel.YNode(edge,VelcroPhysics.Tools.Triangulation.Seidel.Sink.Isink(tList[1]),VelcroPhysics.Tools.Triangulation.Seidel.Sink.Isink(tList[2])),pNode=new VelcroPhysics.Tools.Triangulation.Seidel.XNode(edge.P,VelcroPhysics.Tools.Triangulation.Seidel.Sink.Isink(tList[0]),yNode);this.Replace(sink,pNode)},Case3:function(sink,edge,tList){var yNode=new VelcroPhysics.Tools.Triangulation.Seidel.YNode(edge,VelcroPhysics.Tools.Triangulation.Seidel.Sink.Isink(tList[0]),VelcroPhysics.Tools.Triangulation.Seidel.Sink.Isink(tList[1]));this.Replace(sink,yNode)},Case4:function(sink,edge,tList){var yNode=new VelcroPhysics.Tools.Triangulation.Seidel.YNode(edge,VelcroPhysics.Tools.Triangulation.Seidel.Sink.Isink(tList[0]),VelcroPhysics.Tools.Triangulation.Seidel.Sink.Isink(tList[1])),qNode=new VelcroPhysics.Tools.Triangulation.Seidel.XNode(edge.Q,yNode,VelcroPhysics.Tools.Triangulation.Seidel.Sink.Isink(tList[2]));this.Replace(sink,qNode)}}});Bridge.define("VelcroPhysics.Tools.Triangulation.Seidel.SeidelDecomposer",{statics:{methods:{ConvexPartition:function(vertices,sheer){var $t,$t1,$t2,compatList,vertex,t,list,triangle,outTriangles,outTriangle;sheer===void 0&&(sheer=.001);System.Diagnostics.Debug.Assert(vertices.Count>3);compatList=new(System.Collections.Generic.List$1(VelcroPhysics.Tools.Triangulation.Seidel.Point).$ctor2)(vertices.Count);$t=Bridge.getEnumerator(vertices);try{while($t.moveNext())vertex=$t.Current.$clone(),compatList.add(new VelcroPhysics.Tools.Triangulation.Seidel.Point(vertex.X,vertex.Y))}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}t=new VelcroPhysics.Tools.Triangulation.Seidel.Triangulator(compatList,sheer);list=new(System.Collections.Generic.List$1(VelcroPhysics.Shared.Vertices).ctor);$t1=Bridge.getEnumerator(t.Triangles);try{while($t1.moveNext()){triangle=$t1.Current;outTriangles=new VelcroPhysics.Shared.Vertices.$ctor2(triangle.Count);$t2=Bridge.getEnumerator(triangle);try{while($t2.moveNext())outTriangle=$t2.Current,outTriangles.add(new Microsoft.Xna.Framework.Vector2.$ctor2(outTriangle.X,outTriangle.Y))}finally{Bridge.is($t2,System.IDisposable)&&$t2.System$IDisposable$Dispose()}list.add(outTriangles)}}finally{Bridge.is($t1,System.IDisposable)&&$t1.System$IDisposable$Dispose()}return list},ConvexPartitionTrapezoid:function(vertices,sheer){var $t,$t1,$t2,compatList,vertex,t,list,point;sheer===void 0&&(sheer=.001);compatList=new(System.Collections.Generic.List$1(VelcroPhysics.Tools.Triangulation.Seidel.Point).$ctor2)(vertices.Count);$t=Bridge.getEnumerator(vertices);try{while($t.moveNext())vertex=$t.Current.$clone(),compatList.add(new VelcroPhysics.Tools.Triangulation.Seidel.Point(vertex.X,vertex.Y))}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}t=new VelcroPhysics.Tools.Triangulation.Seidel.Triangulator(compatList,sheer);list=new(System.Collections.Generic.List$1(VelcroPhysics.Shared.Vertices).ctor);$t1=Bridge.getEnumerator(t.Trapezoids);try{while($t1.moveNext()){var trapezoid=$t1.Current,verts=new VelcroPhysics.Shared.Vertices.ctor,points=trapezoid.GetVertices();$t2=Bridge.getEnumerator(points);try{while($t2.moveNext())point=$t2.Current,verts.add(new Microsoft.Xna.Framework.Vector2.$ctor2(point.X,point.Y))}finally{Bridge.is($t2,System.IDisposable)&&$t2.System$IDisposable$Dispose()}list.add(verts)}}finally{Bridge.is($t1,System.IDisposable)&&$t1.System$IDisposable$Dispose()}return list}}}});Bridge.define("VelcroPhysics.Tools.Triangulation.Seidel.Trapezoid",{fields:{Bottom:null,Inside:!1,LeftPoint:null,LowerLeft:null,LowerRight:null,RightPoint:null,Sink:null,Top:null,UpperLeft:null,UpperRight:null},ctors:{ctor:function(leftPoint,rightPoint,top,bottom){this.$initialize();this.LeftPoint=leftPoint;this.RightPoint=rightPoint;this.Top=top;this.Bottom=bottom;this.UpperLeft=null;this.UpperRight=null;this.LowerLeft=null;this.LowerRight=null;this.Inside=!0;this.Sink=null}},methods:{UpdateLeft:function(ul,ll){this.UpperLeft=ul;ul!=null&&(ul.UpperRight=this);this.LowerLeft=ll;ll!=null&&(ll.LowerRight=this)},UpdateRight:function(ur,lr){this.UpperRight=ur;ur!=null&&(ur.UpperLeft=this);this.LowerRight=lr;lr!=null&&(lr.LowerLeft=this)},UpdateLeftRight:function(ul,ll,ur,lr){this.UpperLeft=ul;ul!=null&&(ul.UpperRight=this);this.LowerLeft=ll;ll!=null&&(ll.LowerRight=this);this.UpperRight=ur;ur!=null&&(ur.UpperLeft=this);this.LowerRight=lr;lr!=null&&(lr.LowerLeft=this)},TrimNeighbors:function(){this.Inside&&(this.Inside=!1,this.UpperLeft!=null&&this.UpperLeft.TrimNeighbors(),this.LowerLeft!=null&&this.LowerLeft.TrimNeighbors(),this.UpperRight!=null&&this.UpperRight.TrimNeighbors(),this.LowerRight!=null&&this.LowerRight.TrimNeighbors())},Contains:function(point){return point.X>this.LeftPoint.X&&point.X<this.RightPoint.X&&this.Top.IsAbove(point)&&this.Bottom.IsBelow(point)},GetVertices:function(){var verts=new(System.Collections.Generic.List$1(VelcroPhysics.Tools.Triangulation.Seidel.Point).$ctor2)(4);return verts.add(this.LineIntersect(this.Top,this.LeftPoint.X)),verts.add(this.LineIntersect(this.Bottom,this.LeftPoint.X)),verts.add(this.LineIntersect(this.Bottom,this.RightPoint.X)),verts.add(this.LineIntersect(this.Top,this.RightPoint.X)),verts},LineIntersect:function(edge,x){var y=edge.Slope*x+edge.B;return new VelcroPhysics.Tools.Triangulation.Seidel.Point(x,y)},AddPoints:function(){Bridge.referenceEquals(this.LeftPoint,this.Bottom.P)||this.Bottom.AddMpoint(this.LeftPoint);Bridge.referenceEquals(this.RightPoint,this.Bottom.Q)||this.Bottom.AddMpoint(this.RightPoint);Bridge.referenceEquals(this.LeftPoint,this.Top.P)||this.Top.AddMpoint(this.LeftPoint);Bridge.referenceEquals(this.RightPoint,this.Top.Q)||this.Top.AddMpoint(this.RightPoint)}}});Bridge.define("VelcroPhysics.Tools.Triangulation.Seidel.TrapezoidalMap",{fields:{_bCross:null,_cross:null,_margin:0,Map:null},ctors:{ctor:function(){this.$initialize();this.Map=new(System.Collections.Generic.HashSet$1(VelcroPhysics.Tools.Triangulation.Seidel.Trapezoid).ctor);this._margin=50;this._bCross=null;this._cross=null}},methods:{Clear:function(){this._bCross=null;this._cross=null},Case1:function(t,e){var trapezoids=System.Array.init(4,null,VelcroPhysics.Tools.Triangulation.Seidel.Trapezoid);return trapezoids[0]=new VelcroPhysics.Tools.Triangulation.Seidel.Trapezoid(t.LeftPoint,e.P,t.Top,t.Bottom),trapezoids[1]=new VelcroPhysics.Tools.Triangulation.Seidel.Trapezoid(e.P,e.Q,t.Top,e),trapezoids[2]=new VelcroPhysics.Tools.Triangulation.Seidel.Trapezoid(e.P,e.Q,e,t.Bottom),trapezoids[3]=new VelcroPhysics.Tools.Triangulation.Seidel.Trapezoid(e.Q,t.RightPoint,t.Top,t.Bottom),trapezoids[0].UpdateLeft(t.UpperLeft,t.LowerLeft),trapezoids[1].UpdateLeftRight(trapezoids[0],null,trapezoids[3],null),trapezoids[2].UpdateLeftRight(null,trapezoids[0],null,trapezoids[3]),trapezoids[3].UpdateRight(t.UpperRight,t.LowerRight),trapezoids},Case2:function(t,e){var rp,trapezoids;return rp=e.Q.X===t.RightPoint.X?e.Q:t.RightPoint,trapezoids=System.Array.init(3,null,VelcroPhysics.Tools.Triangulation.Seidel.Trapezoid),trapezoids[0]=new VelcroPhysics.Tools.Triangulation.Seidel.Trapezoid(t.LeftPoint,e.P,t.Top,t.Bottom),trapezoids[1]=new VelcroPhysics.Tools.Triangulation.Seidel.Trapezoid(e.P,rp,t.Top,e),trapezoids[2]=new VelcroPhysics.Tools.Triangulation.Seidel.Trapezoid(e.P,rp,e,t.Bottom),trapezoids[0].UpdateLeft(t.UpperLeft,t.LowerLeft),trapezoids[1].UpdateLeftRight(trapezoids[0],null,t.UpperRight,null),trapezoids[2].UpdateLeftRight(null,trapezoids[0],null,t.LowerRight),this._bCross=t.Bottom,this._cross=t.Top,e.Above=trapezoids[1],e.Below=trapezoids[2],trapezoids},Case3:function(t,e){var lp,rp,trapezoids;return lp=e.P.X===t.LeftPoint.X?e.P:t.LeftPoint,rp=e.Q.X===t.RightPoint.X?e.Q:t.RightPoint,trapezoids=System.Array.init(2,null,VelcroPhysics.Tools.Triangulation.Seidel.Trapezoid),Bridge.referenceEquals(this._cross,t.Top)?(trapezoids[0]=t.UpperLeft,trapezoids[0].UpdateRight(t.UpperRight,null),trapezoids[0].RightPoint=rp):(trapezoids[0]=new VelcroPhysics.Tools.Triangulation.Seidel.Trapezoid(lp,rp,t.Top,e),trapezoids[0].UpdateLeftRight(t.UpperLeft,e.Above,t.UpperRight,null)),Bridge.referenceEquals(this._bCross,t.Bottom)?(trapezoids[1]=t.LowerLeft,trapezoids[1].UpdateRight(null,t.LowerRight),trapezoids[1].RightPoint=rp):(trapezoids[1]=new VelcroPhysics.Tools.Triangulation.Seidel.Trapezoid(lp,rp,e,t.Bottom),trapezoids[1].UpdateLeftRight(e.Below,t.LowerLeft,null,t.LowerRight)),this._bCross=t.Bottom,this._cross=t.Top,e.Above=trapezoids[0],e.Below=trapezoids[1],trapezoids},Case4:function(t,e){var lp,trapezoids;return lp=e.P.X===t.LeftPoint.X?e.P:t.LeftPoint,trapezoids=System.Array.init(3,null,VelcroPhysics.Tools.Triangulation.Seidel.Trapezoid),Bridge.referenceEquals(this._cross,t.Top)?(trapezoids[0]=t.UpperLeft,trapezoids[0].RightPoint=e.Q):(trapezoids[0]=new VelcroPhysics.Tools.Triangulation.Seidel.Trapezoid(lp,e.Q,t.Top,e),trapezoids[0].UpdateLeft(t.UpperLeft,e.Above)),Bridge.referenceEquals(this._bCross,t.Bottom)?(trapezoids[1]=t.LowerLeft,trapezoids[1].RightPoint=e.Q):(trapezoids[1]=new VelcroPhysics.Tools.Triangulation.Seidel.Trapezoid(lp,e.Q,e,t.Bottom),trapezoids[1].UpdateLeft(e.Below,t.LowerLeft)),trapezoids[2]=new VelcroPhysics.Tools.Triangulation.Seidel.Trapezoid(e.Q,t.RightPoint,t.Top,t.Bottom),trapezoids[2].UpdateLeftRight(trapezoids[0],trapezoids[1],t.UpperRight,t.LowerRight),trapezoids},BoundingBox:function(edges){var $t,max=VelcroPhysics.Tools.Triangulation.Seidel.Point.op_Addition(edges.getItem(0).P,this._margin),min=VelcroPhysics.Tools.Triangulation.Seidel.Point.op_Subtraction(edges.getItem(0).Q,this._margin),e;$t=Bridge.getEnumerator(edges);try{while($t.moveNext())e=$t.Current,e.P.X>max.X&&(max=new VelcroPhysics.Tools.Triangulation.Seidel.Point(e.P.X+this._margin,max.Y)),e.P.Y>max.Y&&(max=new VelcroPhysics.Tools.Triangulation.Seidel.Point(max.X,e.P.Y+this._margin)),e.Q.X>max.X&&(max=new VelcroPhysics.Tools.Triangulation.Seidel.Point(e.Q.X+this._margin,max.Y)),e.Q.Y>max.Y&&(max=new VelcroPhysics.Tools.Triangulation.Seidel.Point(max.X,e.Q.Y+this._margin)),e.P.X<min.X&&(min=new VelcroPhysics.Tools.Triangulation.Seidel.Point(e.P.X-this._margin,min.Y)),e.P.Y<min.Y&&(min=new VelcroPhysics.Tools.Triangulation.Seidel.Point(min.X,e.P.Y-this._margin)),e.Q.X<min.X&&(min=new VelcroPhysics.Tools.Triangulation.Seidel.Point(e.Q.X-this._margin,min.Y)),e.Q.Y<min.Y&&(min=new VelcroPhysics.Tools.Triangulation.Seidel.Point(min.X,e.Q.Y-this._margin))}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}var top=new VelcroPhysics.Tools.Triangulation.Seidel.Edge(new VelcroPhysics.Tools.Triangulation.Seidel.Point(min.X,max.Y),new VelcroPhysics.Tools.Triangulation.Seidel.Point(max.X,max.Y)),bottom=new VelcroPhysics.Tools.Triangulation.Seidel.Edge(new VelcroPhysics.Tools.Triangulation.Seidel.Point(min.X,min.Y),new VelcroPhysics.Tools.Triangulation.Seidel.Point(max.X,min.Y)),left=bottom.P,right=top.Q;return new VelcroPhysics.Tools.Triangulation.Seidel.Trapezoid(left,right,top,bottom)}}});Bridge.define("VelcroPhysics.Tools.Triangulation.Seidel.Triangulator",{statics:{methods:{Shuffle:function(T,list){for(var rng=new System.Random.ctor,n=System.Array.getCount(list,T),k,value;n>1;)n=n-1|0,k=rng.Next$1(n+1|0),value=System.Array.getItem(list,k,T),System.Array.setItem(list,k,System.Array.getItem(list,n,T),T),System.Array.setItem(list,n,value,T)}}},fields:{_boundingBox:null,_edgeList:null,_queryGraph:null,_sheer:0,_trapezoidalMap:null,_xMonoPoly:null,Trapezoids:null,Triangles:null},ctors:{init:function(){this._sheer=.001},ctor:function(polyLine,sheer){this.$initialize();this._sheer=sheer;this.Triangles=new(System.Collections.Generic.List$1(System.Collections.Generic.List$1(VelcroPhysics.Tools.Triangulation.Seidel.Point)).ctor);this.Trapezoids=new(System.Collections.Generic.List$1(VelcroPhysics.Tools.Triangulation.Seidel.Trapezoid).ctor);this._xMonoPoly=new(System.Collections.Generic.List$1(VelcroPhysics.Tools.Triangulation.Seidel.MonotoneMountain).ctor);this._edgeList=this.InitEdges(polyLine);this._trapezoidalMap=new VelcroPhysics.Tools.Triangulation.Seidel.TrapezoidalMap;this._boundingBox=this._trapezoidalMap.BoundingBox(this._edgeList);this._queryGraph=new VelcroPhysics.Tools.Triangulation.Seidel.QueryGraph(VelcroPhysics.Tools.Triangulation.Seidel.Sink.Isink(this._boundingBox));this.Process()}},methods:{Process:function(){var $t,$t1,$t2,$t3,$t4,edge,traps,t,cp,cq,tList,y,t1,t2;$t=Bridge.getEnumerator(this._edgeList);try{while($t.moveNext()){edge=$t.Current;traps=this._queryGraph.FollowEdge(edge);$t1=Bridge.getEnumerator(traps);try{while($t1.moveNext()){t=$t1.Current;this._trapezoidalMap.Map.remove(t);cp=t.Contains(edge.P);cq=t.Contains(edge.Q);cp&&cq?(tList=this._trapezoidalMap.Case1(t,edge),this._queryGraph.Case1(t.Sink,edge,tList)):cp&&!cq?(tList=this._trapezoidalMap.Case2(t,edge),this._queryGraph.Case2(t.Sink,edge,tList)):cp||cq?(tList=this._trapezoidalMap.Case4(t,edge),this._queryGraph.Case4(t.Sink,edge,tList)):(tList=this._trapezoidalMap.Case3(t,edge),this._queryGraph.Case3(t.Sink,edge,tList));$t2=Bridge.getEnumerator(tList);try{while($t2.moveNext())y=$t2.Current,this._trapezoidalMap.Map.add(y)}finally{Bridge.is($t2,System.IDisposable)&&$t2.System$IDisposable$Dispose()}}}finally{Bridge.is($t1,System.IDisposable)&&$t1.System$IDisposable$Dispose()}this._trapezoidalMap.Clear()}}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}$t3=Bridge.getEnumerator(this._trapezoidalMap.Map);try{while($t3.moveNext())t1=$t3.Current,this.MarkOutside(t1)}finally{Bridge.is($t3,System.IDisposable)&&$t3.System$IDisposable$Dispose()}$t4=Bridge.getEnumerator(this._trapezoidalMap.Map);try{while($t4.moveNext())t2=$t4.Current,t2.Inside&&(this.Trapezoids.add(t2),t2.AddPoints())}finally{Bridge.is($t4,System.IDisposable)&&$t4.System$IDisposable$Dispose()}this.CreateMountains()},CreateMountains:function(){var $t,$t1,$t2,edge,mountain,points,p,t;$t=Bridge.getEnumerator(this._edgeList);try{while($t.moveNext())if(edge=$t.Current,edge.MPoints.Count>2){mountain=new VelcroPhysics.Tools.Triangulation.Seidel.MonotoneMountain;points=new(System.Collections.Generic.List$1(VelcroPhysics.Tools.Triangulation.Seidel.Point).$ctor1)(edge.MPoints);points.Sort$2(function(p1,p2){return Bridge.compare(p1.X,p2.X)});$t1=Bridge.getEnumerator(points);try{while($t1.moveNext())p=$t1.Current,mountain.Add(p)}finally{Bridge.is($t1,System.IDisposable)&&$t1.System$IDisposable$Dispose()}mountain.Process();$t2=Bridge.getEnumerator(mountain.Triangles);try{while($t2.moveNext())t=$t2.Current,this.Triangles.add(t)}finally{Bridge.is($t2,System.IDisposable)&&$t2.System$IDisposable$Dispose()}this._xMonoPoly.add(mountain)}}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}},MarkOutside:function(t){(Bridge.referenceEquals(t.Top,this._boundingBox.Top)||Bridge.referenceEquals(t.Bottom,this._boundingBox.Bottom))&&t.TrimNeighbors()},InitEdges:function(points){for(var edges=new(System.Collections.Generic.List$1(VelcroPhysics.Tools.Triangulation.Seidel.Edge).ctor),i=0;i<(points.Count-1|0);i=i+1|0)edges.add(new VelcroPhysics.Tools.Triangulation.Seidel.Edge(points.getItem(i),points.getItem(i+1|0)));return edges.add(new VelcroPhysics.Tools.Triangulation.Seidel.Edge(points.getItem(0),points.getItem(points.Count-1|0))),this.OrderSegments(edges)},OrderSegments:function(edgeInput){var $t,edges=new(System.Collections.Generic.List$1(VelcroPhysics.Tools.Triangulation.Seidel.Edge).ctor);$t=Bridge.getEnumerator(edgeInput);try{while($t.moveNext()){var e=$t.Current,p=this.ShearTransform(e.P),q=this.ShearTransform(e.Q);p.X>q.X?edges.add(new VelcroPhysics.Tools.Triangulation.Seidel.Edge(q,p)):p.X<q.X&&edges.add(new VelcroPhysics.Tools.Triangulation.Seidel.Edge(p,q))}}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}return VelcroPhysics.Tools.Triangulation.Seidel.Triangulator.Shuffle(Bridge.global.VelcroPhysics.Tools.Triangulation.Seidel.Edge,edges),edges},ShearTransform:function(point){return new VelcroPhysics.Tools.Triangulation.Seidel.Point(point.X+this._sheer*point.Y,point.Y)}}});Bridge.define("VelcroPhysics.Tools.Triangulation.TriangulationBase.Triangulate",{statics:{methods:{ConvexPartition:function(vertices,algorithm,discardAndFixInvalid,tolerance){var results,temp,temp1,temp2,i,polygon;if(discardAndFixInvalid===void 0&&(discardAndFixInvalid=!0),tolerance===void 0&&(tolerance=.001),vertices.Count<=3)return function(_o1){return _o1.add(vertices),_o1}(new(System.Collections.Generic.List$1(VelcroPhysics.Shared.Vertices).ctor));switch(algorithm){case VelcroPhysics.Tools.Triangulation.TriangulationBase.TriangulationAlgorithm.Earclip:VelcroPhysics.Settings.SkipSanityChecks?System.Diagnostics.Debug.Assert$1(!vertices.IsCounterClockWise(),"The Ear-clip algorithm expects the polygon to be clockwise."):vertices.IsCounterClockWise()?(temp=new VelcroPhysics.Shared.Vertices.$ctor1(vertices),temp.Reverse(),results=VelcroPhysics.Tools.Triangulation.Earclip.EarclipDecomposer.ConvexPartition(temp,tolerance)):results=VelcroPhysics.Tools.Triangulation.Earclip.EarclipDecomposer.ConvexPartition(vertices,tolerance);break;case VelcroPhysics.Tools.Triangulation.TriangulationBase.TriangulationAlgorithm.Bayazit:VelcroPhysics.Settings.SkipSanityChecks?System.Diagnostics.Debug.Assert$1(vertices.IsCounterClockWise(),"The polygon is not counter clockwise. This is needed for Bayazit to work correctly."):vertices.IsCounterClockWise()?results=VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.ConvexPartition(vertices):(temp1=new VelcroPhysics.Shared.Vertices.$ctor1(vertices),temp1.Reverse(),results=VelcroPhysics.Tools.Triangulation.Bayazit.BayazitDecomposer.ConvexPartition(temp1));break;case VelcroPhysics.Tools.Triangulation.TriangulationBase.TriangulationAlgorithm.Flipcode:VelcroPhysics.Settings.SkipSanityChecks?System.Diagnostics.Debug.Assert$1(vertices.IsCounterClockWise(),"The polygon is not counter clockwise. This is needed for Bayazit to work correctly."):vertices.IsCounterClockWise()?results=VelcroPhysics.Tools.Triangulation.FlipCode.FlipcodeDecomposer.ConvexPartition(vertices):(temp2=new VelcroPhysics.Shared.Vertices.$ctor1(vertices),temp2.Reverse(),results=VelcroPhysics.Tools.Triangulation.FlipCode.FlipcodeDecomposer.ConvexPartition(temp2));break;case VelcroPhysics.Tools.Triangulation.TriangulationBase.TriangulationAlgorithm.Seidel:results=VelcroPhysics.Tools.Triangulation.Seidel.SeidelDecomposer.ConvexPartition(vertices,tolerance);break;case VelcroPhysics.Tools.Triangulation.TriangulationBase.TriangulationAlgorithm.SeidelTrapezoids:results=VelcroPhysics.Tools.Triangulation.Seidel.SeidelDecomposer.ConvexPartitionTrapezoid(vertices,tolerance);break;case VelcroPhysics.Tools.Triangulation.TriangulationBase.TriangulationAlgorithm.Delauny:results=VelcroPhysics.Tools.Triangulation.Delaunay.CDTDecomposer.ConvexPartition(vertices);break;default:throw new System.ArgumentOutOfRangeException.$ctor1("algorithm");}if(discardAndFixInvalid)for(i=results.Count-1|0;i>=0;i=i-1|0)polygon=results.getItem(i),VelcroPhysics.Tools.Triangulation.TriangulationBase.Triangulate.ValidatePolygon(polygon)||results.removeAt(i);return results},ValidatePolygon:function(polygon){var errorCode=polygon.CheckPolygon();return errorCode===VelcroPhysics.Shared.PolygonError.InvalidAmountOfVertices||errorCode===VelcroPhysics.Shared.PolygonError.AreaTooSmall||errorCode===VelcroPhysics.Shared.PolygonError.SideTooSmall||errorCode===VelcroPhysics.Shared.PolygonError.NotSimple?!1:(errorCode===VelcroPhysics.Shared.PolygonError.NotCounterClockWise&&polygon.Reverse(),errorCode===VelcroPhysics.Shared.PolygonError.NotConvex)?(polygon=VelcroPhysics.Tools.ConvexHull.GiftWrap.GiftWrap.GetConvexHull(polygon),VelcroPhysics.Tools.Triangulation.TriangulationBase.Triangulate.ValidatePolygon(polygon)):!0}}}});Bridge.define("VelcroPhysics.Tools.Triangulation.TriangulationBase.TriangulationAlgorithm",{$kind:"enum",statics:{fields:{Earclip:0,Bayazit:1,Flipcode:2,Seidel:3,SeidelTrapezoids:4,Delauny:5}}});Bridge.define("VelcroPhysics.Utilities.ConvertUnits",{statics:{fields:{_displayUnitsToSimUnitsRatio:0,_simUnitsToDisplayUnitsRatio:0},ctors:{init:function(){this._displayUnitsToSimUnitsRatio=100;this._simUnitsToDisplayUnitsRatio=1/VelcroPhysics.Utilities.ConvertUnits._displayUnitsToSimUnitsRatio}},methods:{SetDisplayUnitToSimUnitRatio:function(displayUnitsPerSimUnit){VelcroPhysics.Utilities.ConvertUnits._displayUnitsToSimUnitsRatio=displayUnitsPerSimUnit;VelcroPhysics.Utilities.ConvertUnits._simUnitsToDisplayUnitsRatio=1/displayUnitsPerSimUnit},ToDisplayUnits$4:function(simUnits){return simUnits*VelcroPhysics.Utilities.ConvertUnits._displayUnitsToSimUnitsRatio},ToDisplayUnits$3:function(simUnits){return simUnits*VelcroPhysics.Utilities.ConvertUnits._displayUnitsToSimUnitsRatio},ToDisplayUnits:function(simUnits){return Microsoft.Xna.Framework.Vector2.op_Multiply$1(simUnits.$clone(),VelcroPhysics.Utilities.ConvertUnits._displayUnitsToSimUnitsRatio)},ToDisplayUnits$5:function(simUnits,displayUnits){Microsoft.Xna.Framework.Vector2.Multiply$3(simUnits,VelcroPhysics.Utilities.ConvertUnits._displayUnitsToSimUnitsRatio,displayUnits)},ToDisplayUnits$2:function(simUnits){return Microsoft.Xna.Framework.Vector3.op_Multiply$1(simUnits.$clone(),VelcroPhysics.Utilities.ConvertUnits._displayUnitsToSimUnitsRatio)},ToDisplayUnits$1:function(x,y){return Microsoft.Xna.Framework.Vector2.op_Multiply$1(new Microsoft.Xna.Framework.Vector2.$ctor2(x,y),VelcroPhysics.Utilities.ConvertUnits._displayUnitsToSimUnitsRatio)},ToDisplayUnits$6:function(x,y,displayUnits){displayUnits.v=Microsoft.Xna.Framework.Vector2.Zero.$clone();displayUnits.v.X=x*VelcroPhysics.Utilities.ConvertUnits._displayUnitsToSimUnitsRatio;displayUnits.v.Y=y*VelcroPhysics.Utilities.ConvertUnits._displayUnitsToSimUnitsRatio},ToSimUnits$6:function(displayUnits){return displayUnits*VelcroPhysics.Utilities.ConvertUnits._simUnitsToDisplayUnitsRatio},ToSimUnits$4:function(displayUnits){return displayUnits*VelcroPhysics.Utilities.ConvertUnits._simUnitsToDisplayUnitsRatio},ToSimUnits$5:function(displayUnits){return displayUnits*VelcroPhysics.Utilities.ConvertUnits._simUnitsToDisplayUnitsRatio},ToSimUnits:function(displayUnits){return Microsoft.Xna.Framework.Vector2.op_Multiply$1(displayUnits.$clone(),VelcroPhysics.Utilities.ConvertUnits._simUnitsToDisplayUnitsRatio)},ToSimUnits$3:function(displayUnits){return Microsoft.Xna.Framework.Vector3.op_Multiply$1(displayUnits.$clone(),VelcroPhysics.Utilities.ConvertUnits._simUnitsToDisplayUnitsRatio)},ToSimUnits$7:function(displayUnits,simUnits){Microsoft.Xna.Framework.Vector2.Multiply$3(displayUnits,VelcroPhysics.Utilities.ConvertUnits._simUnitsToDisplayUnitsRatio,simUnits)},ToSimUnits$2:function(x,y){return Microsoft.Xna.Framework.Vector2.op_Multiply$1(new Microsoft.Xna.Framework.Vector2.$ctor2(x,y),VelcroPhysics.Utilities.ConvertUnits._simUnitsToDisplayUnitsRatio)},ToSimUnits$1:function(x,y){return Microsoft.Xna.Framework.Vector2.op_Multiply$1(new Microsoft.Xna.Framework.Vector2.$ctor2(x,y),VelcroPhysics.Utilities.ConvertUnits._simUnitsToDisplayUnitsRatio)},ToSimUnits$8:function(x,y,simUnits){simUnits.v=Microsoft.Xna.Framework.Vector2.Zero.$clone();simUnits.v.X=x*VelcroPhysics.Utilities.ConvertUnits._simUnitsToDisplayUnitsRatio;simUnits.v.Y=y*VelcroPhysics.Utilities.ConvertUnits._simUnitsToDisplayUnitsRatio}}}});Bridge.define("VelcroPhysics.Utilities.LineUtils",{statics:{methods:{DistanceBetweenPointAndLineSegment:function(point,start,end){var c2,b,pointOnLine;if(Microsoft.Xna.Framework.Vector2.op_Equality(start.v.$clone(),end.v.$clone()))return Microsoft.Xna.Framework.Vector2.Distance(point.v.$clone(),start.v.$clone());var v=Microsoft.Xna.Framework.Vector2.Subtract(end.v.$clone(),start.v.$clone()),w=Microsoft.Xna.Framework.Vector2.Subtract(point.v.$clone(),start.v.$clone()),c1=Microsoft.Xna.Framework.Vector2.Dot(w.$clone(),v.$clone());return c1<=0?Microsoft.Xna.Framework.Vector2.Distance(point.v.$clone(),start.v.$clone()):(c2=Microsoft.Xna.Framework.Vector2.Dot(v.$clone(),v.$clone()),c2<=c1)?Microsoft.Xna.Framework.Vector2.Distance(point.v.$clone(),end.v.$clone()):(b=c1/c2,pointOnLine=Microsoft.Xna.Framework.Vector2.Add(start.v.$clone(),Microsoft.Xna.Framework.Vector2.Multiply$1(v.$clone(),b)),Microsoft.Xna.Framework.Vector2.Distance(point.v.$clone(),pointOnLine.$clone()))},LineIntersect2:function(a0,a1,b0,b1,intersectionPoint){if(intersectionPoint.v=Microsoft.Xna.Framework.Vector2.Zero.$clone(),Microsoft.Xna.Framework.Vector2.op_Equality(a0.v.$clone(),b0.v.$clone())||Microsoft.Xna.Framework.Vector2.op_Equality(a0.v.$clone(),b1.v.$clone())||Microsoft.Xna.Framework.Vector2.op_Equality(a1.v.$clone(),b0.v.$clone())||Microsoft.Xna.Framework.Vector2.op_Equality(a1.v.$clone(),b1.v.$clone()))return!1;var x1=a0.v.X,y1=a0.v.Y,x2=a1.v.X,y2=a1.v.Y,x3=b0.v.X,y3=b0.v.Y,x4=b1.v.X,y4=b1.v.Y;if(Math.max(x1,x2)<Math.min(x3,x4)||Math.max(x3,x4)<Math.min(x1,x2)||Math.max(y1,y2)<Math.min(y3,y4)||Math.max(y3,y4)<Math.min(y1,y2))return!1;var ua=(x4-x3)*(y1-y3)-(y4-y3)*(x1-x3),ub=(x2-x1)*(y1-y3)-(y2-y1)*(x1-x3),denom=(y4-y3)*(x2-x1)-(x4-x3)*(y2-y1);return Math.abs(denom)<VelcroPhysics.Settings.Epsilon?!1:(ua/=denom,ub/=denom,0<ua&&ua<1&&0<ub&&ub<1)?(intersectionPoint.v.X=x1+ua*(x2-x1),intersectionPoint.v.Y=y1+ua*(y2-y1),!0):!1},LineIntersect:function(p1,p2,q1,q2){var i=Microsoft.Xna.Framework.Vector2.Zero.$clone(),a1=p2.Y-p1.Y,b1=p1.X-p2.X,c1=a1*p1.X+b1*p1.Y,a2=q2.Y-q1.Y,b2=q1.X-q2.X,c2=a2*q1.X+b2*q1.Y,det=a1*b2-a2*b1;return VelcroPhysics.Utilities.MathUtils.FloatEquals(det,0)||(i.X=(b2*c1-b1*c2)/det,i.Y=(a1*c2-a2*c1)/det),i.$clone()},LineIntersect$4:function(point1,point2,point3,point4,firstIsSegment,secondIsSegment,point){var ub;point.v=new Microsoft.Xna.Framework.Vector2.ctor;var a=point4.v.Y-point3.v.Y,b=point2.v.X-point1.v.X,c=point4.v.X-point3.v.X,d=point2.v.Y-point1.v.Y,denom=a*b-c*d;if(!(denom>=-11920929e-14&&denom<=VelcroPhysics.Settings.Epsilon)){var e=point1.v.Y-point3.v.Y,f=point1.v.X-point3.v.X,oneOverDenom=1/denom,ua=c*e-a*f;if(ua*=oneOverDenom,(!firstIsSegment||ua>=0&&ua<=1)&&(ub=b*e-d*f,ub*=oneOverDenom,(!secondIsSegment||ub>=0&&ub<=1)&&(ua!==0||ub!==0)))return point.v.X=point1.v.X+ua*b,point.v.Y=point1.v.Y+ua*d,!0}return!1},LineIntersect$2:function(point1,point2,point3,point4,firstIsSegment,secondIsSegment,intersectionPoint){return point1={v:point1},point2={v:point2},point3={v:point3},point4={v:point4},VelcroPhysics.Utilities.LineUtils.LineIntersect$4(point1,point2,point3,point4,firstIsSegment,secondIsSegment,intersectionPoint)},LineIntersect$3:function(point1,point2,point3,point4,intersectionPoint){return VelcroPhysics.Utilities.LineUtils.LineIntersect$4(point1,point2,point3,point4,!0,!0,intersectionPoint)},LineIntersect$1:function(point1,point2,point3,point4,intersectionPoint){return point1={v:point1},point2={v:point2},point3={v:point3},point4={v:point4},VelcroPhysics.Utilities.LineUtils.LineIntersect$4(point1,point2,point3,point4,!0,!0,intersectionPoint)},LineSegmentVerticesIntersect:function(point1,point2,vertices){for(var point,intersectionPoints=new VelcroPhysics.Shared.Vertices.ctor,i=0;i<vertices.Count;i=i+1|0)point={v:new Microsoft.Xna.Framework.Vector2},VelcroPhysics.Utilities.LineUtils.LineIntersect$2(vertices.getItem(i).$clone(),vertices.getItem(vertices.NextIndex(i)).$clone(),point1.v.$clone(),point2.v.$clone(),!0,!0,point)&&intersectionPoints.add(point.v.$clone());return intersectionPoints},LineSegmentAABBIntersect:function(point1,point2,aabb){return VelcroPhysics.Utilities.LineUtils.LineSegmentVerticesIntersect(point1,point2,aabb.Vertices)}}}});Bridge.define("VelcroPhysics.Utilities.MathUtils",{statics:{methods:{Cross$4:function(a,b){return a.v.X*b.v.Y-a.v.Y*b.v.X},Cross$3:function(a,b){return a={v:a},b={v:b},VelcroPhysics.Utilities.MathUtils.Cross$4(a,b)},Cross$2:function(a,b){return new Microsoft.Xna.Framework.Vector3.$ctor3(a.Y*b.Z-a.Z*b.Y,a.Z*b.X-a.X*b.Z,a.X*b.Y-a.Y*b.X)},Cross:function(a,s){return new Microsoft.Xna.Framework.Vector2.$ctor2(s*a.Y,-s*a.X)},Cross$1:function(s,a){return new Microsoft.Xna.Framework.Vector2.$ctor2(-s*a.Y,s*a.X)},Cross$5:function(a,b,c){c.v=a.v.X*b.v.Y-a.v.Y*b.v.X},Cross$6:function(s,a,b){b.v=new Microsoft.Xna.Framework.Vector2.$ctor2(-s*a.v.Y,s*a.v.X)},Abs:function(v){return new Microsoft.Xna.Framework.Vector2.$ctor2(Math.abs(v.X),Math.abs(v.Y))},Mul:function(A,v){return v={v:v},VelcroPhysics.Utilities.MathUtils.Mul$1(A,v)},Mul$1:function(A,v){return new Microsoft.Xna.Framework.Vector2.$ctor2(A.v.ex.X*v.v.X+A.v.ey.X*v.v.Y,A.v.ex.Y*v.v.X+A.v.ey.Y*v.v.Y)},Mul$4:function(T,v){return v={v:v},VelcroPhysics.Utilities.MathUtils.Mul$5(T,v)},Mul$5:function(T,v){var x=T.v.q.c*v.v.X-T.v.q.s*v.v.Y+T.v.p.X,y=T.v.q.s*v.v.X+T.v.q.c*v.v.Y+T.v.p.Y;return new Microsoft.Xna.Framework.Vector2.$ctor2(x,y)},Mul$6:function(A,v){return Microsoft.Xna.Framework.Vector3.op_Addition(Microsoft.Xna.Framework.Vector3.op_Addition(Microsoft.Xna.Framework.Vector3.op_Multiply$2(v.X,A.ex.$clone()),Microsoft.Xna.Framework.Vector3.op_Multiply$2(v.Y,A.ey.$clone())),Microsoft.Xna.Framework.Vector3.op_Multiply$2(v.Z,A.ez.$clone()))},Mul$8:function(A,B){var C=new VelcroPhysics.Shared.Transform.ctor;return C.q=VelcroPhysics.Utilities.MathUtils.Mul$7(A.q.$clone(),B.q.$clone()),C.p=Microsoft.Xna.Framework.Vector2.op_Addition(VelcroPhysics.Utilities.MathUtils.Mul$2(A.q.$clone(),B.p.$clone()),A.p.$clone()),C.$clone()},Mul$7:function(q,r){var qr=new VelcroPhysics.Shared.Rot;return qr.s=q.s*r.c+q.c*r.s,qr.c=q.c*r.c-q.s*r.s,qr.$clone()},Mul$2:function(q,v){return new Microsoft.Xna.Framework.Vector2.$ctor2(q.c*v.X-q.s*v.Y,q.s*v.X+q.c*v.Y)},Mul$3:function(rot,axis){return VelcroPhysics.Utilities.MathUtils.Mul$2(rot.v.$clone(),axis.$clone())},MulT:function(A,v){return v={v:v},VelcroPhysics.Utilities.MathUtils.MulT$1(A,v)},MulT$1:function(A,v){return new Microsoft.Xna.Framework.Vector2.$ctor2(v.v.X*A.v.ex.X+v.v.Y*A.v.ex.Y,v.v.X*A.v.ey.X+v.v.Y*A.v.ey.Y)},MulT$5:function(T,v){return v={v:v},VelcroPhysics.Utilities.MathUtils.MulT$6(T,v)},MulT$6:function(T,v){var px=v.v.X-T.v.p.X,py=v.v.Y-T.v.p.Y,x=T.v.q.c*px+T.v.q.s*py,y=-T.v.q.s*px+T.v.q.c*py;return new Microsoft.Xna.Framework.Vector2.$ctor2(x,y)},MulT$7:function(A,B,C){C.v=new VelcroPhysics.Shared.Mat22.ctor;C.v.ex.X=A.v.ex.X*B.v.ex.X+A.v.ex.Y*B.v.ex.Y;C.v.ex.Y=A.v.ey.X*B.v.ex.X+A.v.ey.Y*B.v.ex.Y;C.v.ey.X=A.v.ex.X*B.v.ey.X+A.v.ex.Y*B.v.ey.Y;C.v.ey.Y=A.v.ey.X*B.v.ey.X+A.v.ey.Y*B.v.ey.Y},MulT$8:function(A,B,C){C.v=new VelcroPhysics.Shared.Transform.ctor;C.v.q=VelcroPhysics.Utilities.MathUtils.MulT$9(A.v.q.$clone(),B.v.q.$clone());C.v.p=VelcroPhysics.Utilities.MathUtils.MulT$2(A.v.q.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(B.v.p.$clone(),A.v.p.$clone()))},MulT$4:function(T,v){var px=v.X-T.p.X,py=v.Y-T.p.Y,x=T.q.c*px+T.q.s*py,y=-T.q.s*px+T.q.c*py;return new Microsoft.Xna.Framework.Vector2.$ctor2(x,y)},MulT$9:function(q,r){var qr=new VelcroPhysics.Shared.Rot;return qr.s=q.c*r.s-q.s*r.c,qr.c=q.c*r.c+q.s*r.s,qr.$clone()},MulT$10:function(A,B){var C=new VelcroPhysics.Shared.Transform.ctor;return C.q=VelcroPhysics.Utilities.MathUtils.MulT$9(A.q.$clone(),B.q.$clone()),C.p=VelcroPhysics.Utilities.MathUtils.MulT$2(A.q.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(B.p.$clone(),A.p.$clone())),C.$clone()},MulT$2:function(q,v){return new Microsoft.Xna.Framework.Vector2.$ctor2(q.c*v.X+q.s*v.Y,-q.s*v.X+q.c*v.Y)},MulT$3:function(rot,axis){return VelcroPhysics.Utilities.MathUtils.MulT$2(rot.v.$clone(),axis.$clone())},Swap:function(T,a,b){var tmp=a.v;a.v=b.v;b.v=tmp},Mul22:function(A,v){return new Microsoft.Xna.Framework.Vector2.$ctor2(A.ex.X*v.X+A.ey.X*v.Y,A.ex.Y*v.X+A.ey.Y*v.Y)},Skew:function(input){return new Microsoft.Xna.Framework.Vector2.$ctor2(-input.Y,input.X)},IsValid$1:function(x){return isNaN(x)?!1:!(Math.abs(x)===Number.POSITIVE_INFINITY)},IsValid:function(x){return VelcroPhysics.Utilities.MathUtils.IsValid$1(x.X)&&VelcroPhysics.Utilities.MathUtils.IsValid$1(x.Y)},InvSqrt:function(x){var convert=new VelcroPhysics.Utilities.MathUtils.FloatConverter,xhalf;return convert.x=x,xhalf=.5*x,convert.i=1597463007-(convert.i>>1)|0,x=convert.x,x*(1.5-xhalf*x*x)},Clamp$1:function(a,low,high){return Math.max(low,Math.min(a,high))},Clamp$2:function(a,low,high){return Math.max(low,Math.min(a,high))},Clamp:function(a,low,high){return Microsoft.Xna.Framework.Vector2.Max(low.$clone(),Microsoft.Xna.Framework.Vector2.Min(a.$clone(),high.$clone()))},VectorAngle$1:function(p1,p2){for(var theta1=Math.atan2(p1.v.Y,p1.v.X),theta2=Math.atan2(p2.v.Y,p2.v.X),dtheta=theta2-theta1;dtheta>Math.PI;)dtheta-=6.2831853071795862;while(dtheta<-3.1415926535897931)dtheta+=6.2831853071795862;return dtheta},VectorAngle:function(p1,p2){return p1={v:p1},p2={v:p2},VelcroPhysics.Utilities.MathUtils.VectorAngle$1(p1,p2)},Dot:function(a,b){return a.X*b.X+a.Y*b.Y+a.Z*b.Z},Area:function(a,b,c){return a={v:a},b={v:b},c={v:c},VelcroPhysics.Utilities.MathUtils.Area$1(a,b,c)},Area$1:function(a,b,c){return a.v.X*(b.v.Y-c.v.Y)+b.v.X*(c.v.Y-a.v.Y)+c.v.X*(a.v.Y-b.v.Y)},IsCollinear:function(a,b,c,tolerance){return tolerance===void 0&&(tolerance=0),VelcroPhysics.Utilities.MathUtils.FloatInRange(VelcroPhysics.Utilities.MathUtils.Area$1(a,b,c),-tolerance,tolerance)},FloatEquals:function(value1,value2){return Math.abs(value1-value2)<=VelcroPhysics.Settings.Epsilon},FloatEquals$1:function(value1,value2,delta){return VelcroPhysics.Utilities.MathUtils.FloatInRange(value1,value2-delta,value2+delta)},FloatInRange:function(value,min,max){return value>=min&&value<=max}}}});Bridge.define("VelcroPhysics.Utilities.MathUtils.FloatConverter",{$kind:"nested struct",statics:{methods:{getDefaultValue:function(){return new VelcroPhysics.Utilities.MathUtils.FloatConverter}}},fields:{x:0,i:0},ctors:{ctor:function(){this.$initialize()}},methods:{getHashCode:function(){return Bridge.addHash([5441161109,this.x,this.i])},equals:function(o){return Bridge.is(o,VelcroPhysics.Utilities.MathUtils.FloatConverter)?Bridge.equals(this.x,o.x)&&Bridge.equals(this.i,o.i):!1},$clone:function(to){var s=to||new VelcroPhysics.Utilities.MathUtils.FloatConverter;return s.x=this.x,s.i=this.i,s}}});Bridge.define("VelcroPhysics.Utilities.PolygonUtils",{statics:{methods:{CreateRectangle:function(hx,hy){var vertices=new VelcroPhysics.Shared.Vertices.$ctor2(4);return vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(-hx,-hy)),vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(hx,-hy)),vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(hx,hy)),vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(-hx,hy)),vertices},CreateRectangle$1:function(hx,hy,center,angle){var vertices=VelcroPhysics.Utilities.PolygonUtils.CreateRectangle(hx,hy),xf={v:new VelcroPhysics.Shared.Transform.ctor},i;for(xf.v.p=center.$clone(),xf.v.q.Set(angle),i=0;i<4;i=i+1|0)vertices.setItem(i,VelcroPhysics.Utilities.MathUtils.Mul$4(xf,vertices.getItem(i).$clone()));return vertices},CreateRoundedRectangle:function(width,height,xRadius,yRadius,segments){var vertices,phase,i;if(yRadius>height/2||xRadius>width/2)throw new System.Exception("Rounding amount can't be more than half the height and width respectively.");if(segments<0)throw new System.Exception("Segments must be zero or more.");if(vertices=new VelcroPhysics.Shared.Vertices.ctor,segments===0)vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(width*.5-xRadius,-height*.5)),vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(width*.5,-height*.5+yRadius)),vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(width*.5,height*.5-yRadius)),vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(width*.5-xRadius,height*.5)),vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(-width*.5+xRadius,height*.5)),vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(-width*.5,height*.5-yRadius)),vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(-width*.5,-height*.5+yRadius)),vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(-width*.5+xRadius,-height*.5));else{var numberOfEdges=Bridge.Int.mul(segments,4)+8|0,stepSize=Microsoft.Xna.Framework.MathHelper.TwoPi/(numberOfEdges-4|0),perPhase=Bridge.Int.div(numberOfEdges,4)|0,posOffset=new Microsoft.Xna.Framework.Vector2.$ctor2(width/2-xRadius,height/2-yRadius);for(vertices.add(Microsoft.Xna.Framework.Vector2.op_Addition(posOffset.$clone(),new Microsoft.Xna.Framework.Vector2.$ctor2(xRadius,-yRadius+yRadius))),phase=0,i=1;i<numberOfEdges;i=i+1|0)(i-perPhase|0)==0||(i-Bridge.Int.mul(perPhase,3)|0)==0?(posOffset.X*=-1,phase=Bridge.Int.sxs(phase-1&65535)):(i-Bridge.Int.mul(perPhase,2)|0)==0&&(posOffset.Y*=-1,phase=Bridge.Int.sxs(phase-1&65535)),vertices.add(Microsoft.Xna.Framework.Vector2.op_Addition(posOffset.$clone(),new Microsoft.Xna.Framework.Vector2.$ctor2(xRadius*Math.cos(stepSize*(-(i+phase|0)|0)),-yRadius*Math.sin(stepSize*(-(i+phase|0)|0)))))}return vertices},CreateLine:function(start,end){var vertices=new VelcroPhysics.Shared.Vertices.$ctor2(2);return vertices.add(start.$clone()),vertices.add(end.$clone()),vertices},CreateCircle:function(radius,numberOfEdges){return VelcroPhysics.Utilities.PolygonUtils.CreateEllipse(radius,radius,numberOfEdges)},CreateEllipse:function(xRadius,yRadius,numberOfEdges){var vertices=new VelcroPhysics.Shared.Vertices.ctor,stepSize=Microsoft.Xna.Framework.MathHelper.TwoPi/numberOfEdges,i;for(vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(xRadius,0)),i=numberOfEdges-1|0;i>0;i=i-1|0)vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(xRadius*Math.cos(stepSize*i),-yRadius*Math.sin(stepSize*i)));return vertices},CreateArc:function(radians,sides,radius){var vertices,stepSize,i;for(System.Diagnostics.Debug.Assert$1(radians>0,"The arc needs to be larger than 0"),System.Diagnostics.Debug.Assert$1(sides>1,"The arc needs to have more than 1 sides"),System.Diagnostics.Debug.Assert$1(radius>0,"The arc needs to have a radius larger than 0"),vertices=new VelcroPhysics.Shared.Vertices.ctor,stepSize=radians/sides,i=sides-1|0;i>0;i=i-1|0)vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(radius*Math.cos(stepSize*i),radius*Math.sin(stepSize*i)));return vertices},CreateCapsule:function(height,endRadius,edges){if(endRadius>=height/2)throw new System.ArgumentException.$ctor3("The radius must be lower than height / 2. Higher values of radius would create a circle, and not a half circle.","endRadius");return VelcroPhysics.Utilities.PolygonUtils.CreateCapsule$1(height,endRadius,edges,endRadius,edges)},CreateCapsule$1:function(height,topRadius,topEdges,bottomRadius,bottomEdges){var vertices,newHeight,stepSize,i,i1;if(height<=0)throw new System.ArgumentException.$ctor3("Height must be longer than 0","height");if(topRadius<=0)throw new System.ArgumentException.$ctor3("The top radius must be more than 0","topRadius");if(topEdges<=0)throw new System.ArgumentException.$ctor3("Top edges must be more than 0","topEdges");if(bottomRadius<=0)throw new System.ArgumentException.$ctor3("The bottom radius must be more than 0","bottomRadius");if(bottomEdges<=0)throw new System.ArgumentException.$ctor3("Bottom edges must be more than 0","bottomEdges");if(topRadius>=height/2)throw new System.ArgumentException.$ctor3("The top radius must be lower than height / 2. Higher values of top radius would create a circle, and not a half circle.","topRadius");if(bottomRadius>=height/2)throw new System.ArgumentException.$ctor3("The bottom radius must be lower than height / 2. Higher values of bottom radius would create a circle, and not a half circle.","bottomRadius");for(vertices=new VelcroPhysics.Shared.Vertices.ctor,newHeight=(height-topRadius-bottomRadius)*.5,vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(topRadius,newHeight)),stepSize=Microsoft.Xna.Framework.MathHelper.Pi/topEdges,i=1;i<topEdges;i=i+1|0)vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(topRadius*Math.cos(stepSize*i),topRadius*Math.sin(stepSize*i)+newHeight));for(vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(-topRadius,newHeight)),vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(-bottomRadius,-newHeight)),stepSize=Microsoft.Xna.Framework.MathHelper.Pi/bottomEdges,i1=1;i1<bottomEdges;i1=i1+1|0)vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(-bottomRadius*Math.cos(stepSize*i1),-bottomRadius*Math.sin(stepSize*i1)-newHeight));return vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(bottomRadius,-newHeight)),vertices},CreateGear:function(radius,numberOfTeeth,tipPercentage,toothHeight){var vertices=new VelcroPhysics.Shared.Vertices.ctor,stepSize=Microsoft.Xna.Framework.MathHelper.TwoPi/numberOfTeeth,toothTipStepSize,toothAngleStepSize,i;for(tipPercentage/=100,Microsoft.Xna.Framework.MathHelper.Clamp$1(tipPercentage,0,1),toothTipStepSize=stepSize/2*tipPercentage,toothAngleStepSize=(stepSize-toothTipStepSize*2)/2,i=numberOfTeeth-1|0;i>=0;i=i-1|0)toothTipStepSize>0&&(vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(radius*Math.cos(stepSize*i+toothAngleStepSize*2+toothTipStepSize),-radius*Math.sin(stepSize*i+toothAngleStepSize*2+toothTipStepSize))),vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2((radius+toothHeight)*Math.cos(stepSize*i+toothAngleStepSize+toothTipStepSize),-(radius+toothHeight)*Math.sin(stepSize*i+toothAngleStepSize+toothTipStepSize)))),vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2((radius+toothHeight)*Math.cos(stepSize*i+toothAngleStepSize),-(radius+toothHeight)*Math.sin(stepSize*i+toothAngleStepSize))),vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(radius*Math.cos(stepSize*i),-radius*Math.sin(stepSize*i)));return vertices},CreatePolygon$1:function(data,width){return VelcroPhysics.Tools.TextureTools.TextureConverter.DetectVertices$1(data,width)},CreatePolygon$2:function(data,width,holeDetection){return VelcroPhysics.Tools.TextureTools.TextureConverter.DetectVertices$2(data,width,holeDetection)},CreatePolygon:function(data,width,hullTolerance,alphaTolerance,multiPartDetection,holeDetection){return VelcroPhysics.Tools.TextureTools.TextureConverter.DetectVertices(data,width,hullTolerance,alphaTolerance,multiPartDetection,holeDetection)}}}});Bridge.define("VelcroPhysics.Collision.Broadphase.DynamicTreeBroadPhase",{inherits:[VelcroPhysics.Collision.Broadphase.IBroadPhase],statics:{fields:{NullProxy:0},ctors:{init:function(){this.NullProxy=-1}}},fields:{_moveBuffer:null,_moveCapacity:0,_moveCount:0,_pairBuffer:null,_pairCapacity:0,_pairCount:0,_proxyCount:0,_queryCallback:null,_queryProxyId:0,_tree:null},props:{TreeQuality:{get:function(){return this._tree.AreaRatio}},TreeHeight:{get:function(){return this._tree.Height}},ProxyCount:{get:function(){return this._proxyCount}}},alias:["ProxyCount","VelcroPhysics$Collision$Broadphase$IBroadPhase$ProxyCount","AddProxy","VelcroPhysics$Collision$Broadphase$IBroadPhase$AddProxy","RemoveProxy","VelcroPhysics$Collision$Broadphase$IBroadPhase$RemoveProxy","MoveProxy","VelcroPhysics$Collision$Broadphase$IBroadPhase$MoveProxy","TouchProxy","VelcroPhysics$Collision$Broadphase$IBroadPhase$TouchProxy","GetFatAABB","VelcroPhysics$Collision$Broadphase$IBroadPhase$GetFatAABB","GetProxy","VelcroPhysics$Collision$Broadphase$IBroadPhase$GetProxy","TestOverlap","VelcroPhysics$Collision$Broadphase$IBroadPhase$TestOverlap","UpdatePairs","VelcroPhysics$Collision$Broadphase$IBroadPhase$UpdatePairs","Query","VelcroPhysics$Collision$Broadphase$IBroadPhase$Query","RayCast","VelcroPhysics$Collision$Broadphase$IBroadPhase$RayCast","ShiftOrigin","VelcroPhysics$Collision$Broadphase$IBroadPhase$ShiftOrigin"],ctors:{init:function(){this._tree=new(VelcroPhysics.Collision.Broadphase.DynamicTree$1(VelcroPhysics.Dynamics.FixtureProxy))},ctor:function(){this.$initialize();this._queryCallback=Bridge.fn.cacheBind(this,this.QueryCallback);this._proxyCount=0;this._pairCapacity=16;this._pairCount=0;this._pairBuffer=System.Array.init(this._pairCapacity,function(){return new VelcroPhysics.Collision.Broadphase.Pair},VelcroPhysics.Collision.Broadphase.Pair);this._moveCapacity=16;this._moveCount=0;this._moveBuffer=System.Array.init(new Int32Array(this._moveCapacity),System.Int32)}},methods:{AddProxy:function(proxy){var proxyId=this._tree.AddProxy(Bridge.ref(proxy.v,"AABB"),proxy.v.$clone());return this._proxyCount=this._proxyCount+1|0,this.BufferMove(proxyId),proxyId},RemoveProxy:function(proxyId){this.UnBufferMove(proxyId);this._proxyCount=this._proxyCount-1|0;this._tree.RemoveProxy(proxyId)},MoveProxy:function(proxyId,aabb,displacement){var buffer=this._tree.MoveProxy(proxyId,aabb,displacement.$clone());buffer&&this.BufferMove(proxyId)},TouchProxy:function(proxyId){this.BufferMove(proxyId)},GetFatAABB:function(proxyId,aabb){this._tree.GetFatAABB(proxyId,aabb)},GetProxy:function(proxyId){return this._tree.GetUserData(proxyId)},TestOverlap:function(proxyIdA,proxyIdB){var aabbA={v:new VelcroPhysics.Shared.AABB},aabbB;return this._tree.GetFatAABB(proxyIdA,aabbA),aabbB={v:new VelcroPhysics.Shared.AABB},this._tree.GetFatAABB(proxyIdB,aabbB),VelcroPhysics.Shared.AABB.TestOverlap(aabbA,aabbB)},UpdatePairs:function(callback){var j,fatAABB,i,pair;for(this._pairCount=0,j=0;j<this._moveCount;j=j+1|0)(this._queryProxyId=this._moveBuffer[j],this._queryProxyId!==VelcroPhysics.Collision.Broadphase.DynamicTreeBroadPhase.NullProxy)&&(fatAABB={v:new VelcroPhysics.Shared.AABB},this._tree.GetFatAABB(this._queryProxyId,fatAABB),this._tree.Query(this._queryCallback,fatAABB));for(this._moveCount=0,System.Array.sort(this._pairBuffer,0,this._pairCount),i=0;i<this._pairCount;){var primaryPair=this._pairBuffer[i].$clone(),userDataA={v:this._tree.GetUserData(primaryPair.ProxyIdA).$clone()},userDataB={v:this._tree.GetUserData(primaryPair.ProxyIdB).$clone()};for(callback(userDataA,userDataB),i=i+1|0;i<this._pairCount;){if(pair=this._pairBuffer[i].$clone(),pair.ProxyIdA!==primaryPair.ProxyIdA||pair.ProxyIdB!==primaryPair.ProxyIdB)break;i=i+1|0}}},Query:function(callback,aabb){this._tree.Query(callback,aabb)},RayCast:function(callback,input){this._tree.RayCast(callback,input)},ShiftOrigin:function(newOrigin){this._tree.ShiftOrigin(newOrigin.$clone())},BufferMove:function(proxyId){if(this._moveCount===this._moveCapacity){var oldBuffer=this._moveBuffer;this._moveCapacity=Bridge.Int.mul(this._moveCapacity,2);this._moveBuffer=System.Array.init(new Int32Array(this._moveCapacity),System.Int32);System.Array.copy(oldBuffer,0,this._moveBuffer,0,this._moveCount)}this._moveBuffer[this._moveCount]=proxyId;this._moveCount=this._moveCount+1|0},UnBufferMove:function(proxyId){for(var i=0;i<this._moveCount;i=i+1|0)this._moveBuffer[i]===proxyId&&(this._moveBuffer[i]=VelcroPhysics.Collision.Broadphase.DynamicTreeBroadPhase.NullProxy)},QueryCallback:function(proxyId){if(proxyId===this._queryProxyId)return!0;if(this._pairCount===this._pairCapacity){var oldBuffer=this._pairBuffer;this._pairCapacity=Bridge.Int.mul(this._pairCapacity,2);this._pairBuffer=System.Array.init(this._pairCapacity,function(){return new VelcroPhysics.Collision.Broadphase.Pair},VelcroPhysics.Collision.Broadphase.Pair);System.Array.copy(oldBuffer,0,this._pairBuffer,0,this._pairCount)}return this._pairBuffer[this._pairCount].ProxyIdA=Math.min(proxyId,this._queryProxyId),this._pairBuffer[this._pairCount].ProxyIdB=Math.max(proxyId,this._queryProxyId),this._pairCount=this._pairCount+1|0,!0}}});Bridge.define("VelcroPhysics.Collision.Shapes.ChainShape",{inherits:[VelcroPhysics.Collision.Shapes.Shape],fields:{_hasPrevVertex:!1,_hasNextVertex:!1,_prevVertex:null,_nextVertex:null,Vertices:null},props:{ChildCount:{get:function(){return this.Vertices.Count-1|0}},PrevVertex:{get:function(){return this._prevVertex.$clone()},set:function(value){this._prevVertex=value.$clone();this._hasPrevVertex=!0}},NextVertex:{get:function(){return this._nextVertex.$clone()},set:function(value){this._nextVertex=value.$clone();this._hasNextVertex=!0}}},ctors:{init:function(){this._prevVertex=new Microsoft.Xna.Framework.Vector2;this._nextVertex=new Microsoft.Xna.Framework.Vector2},$ctor1:function(vertices,createLoop){createLoop===void 0&&(createLoop=!1);this.$initialize();VelcroPhysics.Collision.Shapes.Shape.ctor.call(this,VelcroPhysics.Collision.Shapes.ShapeType.Chain,VelcroPhysics.Settings.PolygonRadius);System.Diagnostics.Debug.Assert(vertices!=null&&vertices.Count>=3);System.Diagnostics.Debug.Assert(Microsoft.Xna.Framework.Vector2.op_Inequality(vertices.getItem(0).$clone(),vertices.getItem(vertices.Count-1|0).$clone()));for(var i=1;i<vertices.Count;i=i+1|0)System.Diagnostics.Debug.Assert(Microsoft.Xna.Framework.Vector2.DistanceSquared(vertices.getItem(i-1|0).$clone(),vertices.getItem(i).$clone())>25e-6);this.Vertices=new VelcroPhysics.Shared.Vertices.$ctor1(vertices);createLoop&&(this.Vertices.add(vertices.getItem(0).$clone()),this.PrevVertex=this.Vertices.getItem(this.Vertices.Count-2|0).$clone(),this.NextVertex=this.Vertices.getItem(1).$clone());this.ComputeProperties()},ctor:function(){this.$initialize();VelcroPhysics.Collision.Shapes.Shape.ctor.call(this,VelcroPhysics.Collision.Shapes.ShapeType.Chain,VelcroPhysics.Settings.PolygonRadius)}},methods:{GetChildEdge$1:function(edge,index){System.Diagnostics.Debug.Assert(0<=index&&index<(this.Vertices.Count-1|0));System.Diagnostics.Debug.Assert(edge!=null);edge.ShapeType=VelcroPhysics.Collision.Shapes.ShapeType.Edge;edge._radius=this._radius;edge.Vertex1=this.Vertices.getItem(index+0|0).$clone();edge.Vertex2=this.Vertices.getItem(index+1|0).$clone();index>0?(edge.Vertex0=this.Vertices.getItem(index-1|0).$clone(),edge.HasVertex0=!0):(edge.Vertex0=this._prevVertex.$clone(),edge.HasVertex0=this._hasPrevVertex);index<(this.Vertices.Count-2|0)?(edge.Vertex3=this.Vertices.getItem(index+2|0).$clone(),edge.HasVertex3=!0):(edge.Vertex3=this._nextVertex.$clone(),edge.HasVertex3=this._hasNextVertex)},GetChildEdge:function(index){var edgeShape=new VelcroPhysics.Collision.Shapes.EdgeShape.ctor;return this.GetChildEdge$1(edgeShape,index),edgeShape},TestPoint:function(transform,point){return!1},RayCast:function(input,transform,childIndex,output){var i1,i2,v1,v2;return System.Diagnostics.Debug.Assert(childIndex<this.Vertices.Count),i1=childIndex,i2=childIndex+1|0,i2===this.Vertices.Count&&(i2=0),v1={v:this.Vertices.getItem(i1).$clone()},v2={v:this.Vertices.getItem(i2).$clone()},VelcroPhysics.Collision.RayCast.RayCastHelper.RayCastEdge(v1,v2,input,transform,output)},ComputeAABB:function(transform,childIndex,aabb){var i1,i2,v1,v2;System.Diagnostics.Debug.Assert(childIndex<this.Vertices.Count);i1=childIndex;i2=childIndex+1|0;i2===this.Vertices.Count&&(i2=0);v1={v:this.Vertices.getItem(i1).$clone()};v2={v:this.Vertices.getItem(i2).$clone()};VelcroPhysics.Collision.AABBHelper.ComputeEdgeAABB(v1,v2,transform,aabb)},ComputeProperties:function(){},CompareTo:function(shape){if(this.Vertices.Count!==shape.Vertices.Count)return!1;for(var i=0;i<this.Vertices.Count;i=i+1|0)if(Microsoft.Xna.Framework.Vector2.op_Inequality(this.Vertices.getItem(i).$clone(),shape.Vertices.getItem(i).$clone()))return!1;return Microsoft.Xna.Framework.Vector2.op_Equality(this.PrevVertex.$clone(),shape.PrevVertex.$clone())&&Microsoft.Xna.Framework.Vector2.op_Equality(this.NextVertex.$clone(),shape.NextVertex.$clone())},Clone:function(){var clone=new VelcroPhysics.Collision.Shapes.ChainShape.ctor;return clone.ShapeType=this.ShapeType,clone._density=this._density,clone._radius=this._radius,clone.PrevVertex=this._prevVertex.$clone(),clone.NextVertex=this._nextVertex.$clone(),clone._hasNextVertex=this._hasNextVertex,clone._hasPrevVertex=this._hasPrevVertex,clone.Vertices=new VelcroPhysics.Shared.Vertices.$ctor1(this.Vertices),clone}}});Bridge.define("VelcroPhysics.Collision.Shapes.CircleShape",{inherits:[VelcroPhysics.Collision.Shapes.Shape],fields:{_position:null},props:{ChildCount:{get:function(){return 1}},Position:{get:function(){return this._position.$clone()},set:function(value){this._position=value.$clone();this.ComputeInertia()}}},ctors:{init:function(){this._position=new Microsoft.Xna.Framework.Vector2},$ctor1:function(radius,density){this.$initialize();VelcroPhysics.Collision.Shapes.Shape.ctor.call(this,VelcroPhysics.Collision.Shapes.ShapeType.Circle,radius,density);this.ComputeProperties()},ctor:function(){this.$initialize();VelcroPhysics.Collision.Shapes.Shape.ctor.call(this,VelcroPhysics.Collision.Shapes.ShapeType.Circle)}},methods:{TestPoint:function(transform,point){return VelcroPhysics.Collision.TestPointHelper.TestPointCircle(Bridge.ref(this,"_position"),this._radius,point,transform)},RayCast:function(input,transform,childIndex,output){return VelcroPhysics.Collision.RayCast.RayCastHelper.RayCastCircle(Bridge.ref(this,"_position"),this.Radius,input,transform,output)},ComputeAABB:function(transform,childIndex,aabb){VelcroPhysics.Collision.AABBHelper.ComputeCircleAABB(Bridge.ref(this,"_position"),this._radius,transform,aabb)},ComputeProperties:function(){this.ComputeMass();this.ComputeInertia()},ComputeMass:function(){var area=VelcroPhysics.Settings.Pi*this._2radius;this.MassData.Area=area;this.MassData.Mass=this.Density*area},ComputeInertia:function(){this.MassData.Centroid=this.Position.$clone();this.MassData.Inertia=this.MassData.Mass*(.5*this._2radius+Microsoft.Xna.Framework.Vector2.Dot(this.Position.$clone(),this.Position.$clone()))},CompareTo:function(shape){return this.Radius===shape.Radius&&Microsoft.Xna.Framework.Vector2.op_Equality(this.Position.$clone(),shape.Position.$clone())},Clone:function(){var clone=new VelcroPhysics.Collision.Shapes.CircleShape.ctor;return clone.ShapeType=this.ShapeType,clone._radius=this.Radius,clone._2radius=this._2radius,clone._density=this._density,clone._position=this._position.$clone(),clone.MassData=this.MassData.$clone(),clone}}});Bridge.define("VelcroPhysics.Collision.Shapes.EdgeShape",{inherits:[VelcroPhysics.Collision.Shapes.Shape],fields:{_vertex1:null,_vertex2:null,HasVertex0:!1,HasVertex3:!1,Vertex0:null,Vertex3:null},props:{ChildCount:{get:function(){return 1}},Vertex1:{get:function(){return this._vertex1.$clone()},set:function(value){this._vertex1=value.$clone();this.ComputeProperties()}},Vertex2:{get:function(){return this._vertex2.$clone()},set:function(value){this._vertex2=value.$clone();this.ComputeProperties()}}},ctors:{init:function(){this._vertex1=new Microsoft.Xna.Framework.Vector2;this._vertex2=new Microsoft.Xna.Framework.Vector2;this.Vertex0=new Microsoft.Xna.Framework.Vector2;this.Vertex3=new Microsoft.Xna.Framework.Vector2},$ctor1:function(start,end){this.$initialize();VelcroPhysics.Collision.Shapes.Shape.ctor.call(this,VelcroPhysics.Collision.Shapes.ShapeType.Edge,VelcroPhysics.Settings.PolygonRadius);this.Set(start.$clone(),end.$clone());this.ComputeProperties()},ctor:function(){this.$initialize();VelcroPhysics.Collision.Shapes.Shape.ctor.call(this,VelcroPhysics.Collision.Shapes.ShapeType.Edge,VelcroPhysics.Settings.PolygonRadius)}},methods:{Set:function(start,end){this._vertex1=start.$clone();this._vertex2=end.$clone();this.HasVertex0=!1;this.HasVertex3=!1;this.ComputeProperties()},TestPoint:function(transform,point){return!1},RayCast:function(input,transform,childIndex,output){return VelcroPhysics.Collision.RayCast.RayCastHelper.RayCastEdge(Bridge.ref(this,"_vertex1"),Bridge.ref(this,"_vertex2"),input,transform,output)},ComputeAABB:function(transform,childIndex,aabb){VelcroPhysics.Collision.AABBHelper.ComputeEdgeAABB(Bridge.ref(this,"_vertex1"),Bridge.ref(this,"_vertex2"),transform,aabb)},ComputeProperties:function(){this.MassData.Centroid=Microsoft.Xna.Framework.Vector2.op_Multiply$2(.5,Microsoft.Xna.Framework.Vector2.op_Addition(this._vertex1.$clone(),this._vertex2.$clone()))},CompareTo:function(shape){return this.HasVertex0===shape.HasVertex0&&this.HasVertex3===shape.HasVertex3&&Microsoft.Xna.Framework.Vector2.op_Equality(this.Vertex0.$clone(),shape.Vertex0.$clone())&&Microsoft.Xna.Framework.Vector2.op_Equality(this.Vertex1.$clone(),shape.Vertex1.$clone())&&Microsoft.Xna.Framework.Vector2.op_Equality(this.Vertex2.$clone(),shape.Vertex2.$clone())&&Microsoft.Xna.Framework.Vector2.op_Equality(this.Vertex3.$clone(),shape.Vertex3.$clone())},Clone:function(){var clone=new VelcroPhysics.Collision.Shapes.EdgeShape.ctor;return clone.ShapeType=this.ShapeType,clone._radius=this._radius,clone._density=this._density,clone.HasVertex0=this.HasVertex0,clone.HasVertex3=this.HasVertex3,clone.Vertex0=this.Vertex0.$clone(),clone._vertex1=this._vertex1.$clone(),clone._vertex2=this._vertex2.$clone(),clone.Vertex3=this.Vertex3.$clone(),clone.MassData=this.MassData.$clone(),clone}}});Bridge.define("VelcroPhysics.Collision.Shapes.PolygonShape",{inherits:[VelcroPhysics.Collision.Shapes.Shape],fields:{_normals:null,_vertices:null},props:{Vertices:{get:function(){return this._vertices},set:function(value){var i,temp;for(System.Diagnostics.Debug.Assert(value.Count>=3&&value.Count<=VelcroPhysics.Settings.MaxPolygonVertices),VelcroPhysics.Settings.UseConvexHullPolygons?value.Count<=3?(this._vertices=new VelcroPhysics.Shared.Vertices.$ctor1(value),this._vertices.ForceCounterClockWise()):this._vertices=VelcroPhysics.Tools.ConvexHull.GiftWrap.GiftWrap.GetConvexHull(value):this._vertices=new VelcroPhysics.Shared.Vertices.$ctor1(value),this._normals=new VelcroPhysics.Shared.Vertices.$ctor2(this._vertices.Count),i=0;i<this._vertices.Count;i=i+1|0){var i1=i,i2=(i+1|0)<this._vertices.Count?i+1|0:0,edge=Microsoft.Xna.Framework.Vector2.op_Subtraction(this._vertices.getItem(i2).$clone(),this._vertices.getItem(i1).$clone());System.Diagnostics.Debug.Assert(edge.LengthSquared()>142108547e-22);temp=VelcroPhysics.Utilities.MathUtils.Cross(edge.$clone(),1);temp.Normalize();this._normals.add(temp.$clone())}this.ComputeProperties()}},Normals:{get:function(){return this._normals}},ChildCount:{get:function(){return 1}}},ctors:{$ctor2:function(vertices,density){this.$initialize();VelcroPhysics.Collision.Shapes.Shape.ctor.call(this,VelcroPhysics.Collision.Shapes.ShapeType.Polygon,VelcroPhysics.Settings.PolygonRadius,density);this.Vertices=vertices},$ctor1:function(density){this.$initialize();VelcroPhysics.Collision.Shapes.Shape.ctor.call(this,VelcroPhysics.Collision.Shapes.ShapeType.Polygon,VelcroPhysics.Settings.PolygonRadius,density)},ctor:function(){this.$initialize();VelcroPhysics.Collision.Shapes.Shape.ctor.call(this,VelcroPhysics.Collision.Shapes.ShapeType.Polygon,VelcroPhysics.Settings.PolygonRadius)}},methods:{ComputeProperties:function(){var i,k_inv3,i1;if(System.Diagnostics.Debug.Assert(this.Vertices.Count>=3),!(this._density<=0)){var center=Microsoft.Xna.Framework.Vector2.Zero.$clone(),area=0,I=0,s=Microsoft.Xna.Framework.Vector2.Zero.$clone();for(i=0;i<this.Vertices.Count;i=i+1|0)s=Microsoft.Xna.Framework.Vector2.op_Addition(s.$clone(),this.Vertices.getItem(i).$clone());for(s=Microsoft.Xna.Framework.Vector2.op_Multiply$1(s.$clone(),1/this.Vertices.Count),k_inv3=.333333343,i1=0;i1<this.Vertices.Count;i1=i1+1|0){var e1=Microsoft.Xna.Framework.Vector2.op_Subtraction(this.Vertices.getItem(i1).$clone(),s.$clone()),e2=(i1+1|0)<this.Vertices.Count?Microsoft.Xna.Framework.Vector2.op_Subtraction(this.Vertices.getItem(i1+1|0).$clone(),s.$clone()):Microsoft.Xna.Framework.Vector2.op_Subtraction(this.Vertices.getItem(0).$clone(),s.$clone()),D=VelcroPhysics.Utilities.MathUtils.Cross$3(e1.$clone(),e2.$clone()),triangleArea=.5*D;area+=triangleArea;center=Microsoft.Xna.Framework.Vector2.op_Addition(center.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(triangleArea*k_inv3,Microsoft.Xna.Framework.Vector2.op_Addition(e1.$clone(),e2.$clone())));var ex1=e1.X,ey1=e1.Y,ex2=e2.X,ey2=e2.Y,intx2=ex1*ex1+ex2*ex1+ex2*ex2,inty2=ey1*ey1+ey2*ey1+ey2*ey2;I+=.0833333358*D*(intx2+inty2)}System.Diagnostics.Debug.Assert(area>VelcroPhysics.Settings.Epsilon);this.MassData.Area=area;this.MassData.Mass=this._density*area;center=Microsoft.Xna.Framework.Vector2.op_Multiply$1(center.$clone(),1/area);this.MassData.Centroid=Microsoft.Xna.Framework.Vector2.op_Addition(center.$clone(),s.$clone());this.MassData.Inertia=this._density*I;this.MassData.Inertia+=this.MassData.Mass*(Microsoft.Xna.Framework.Vector2.Dot(this.MassData.Centroid.$clone(),this.MassData.Centroid.$clone())-Microsoft.Xna.Framework.Vector2.Dot(center.$clone(),center.$clone()))}},TestPoint:function(transform,point){return VelcroPhysics.Collision.TestPointHelper.TestPointPolygon(this._vertices,this._normals,point,transform)},RayCast:function(input,transform,childIndex,output){return VelcroPhysics.Collision.RayCast.RayCastHelper.RayCastPolygon(this._vertices,this._normals,input,transform,output)},ComputeAABB:function(transform,childIndex,aabb){VelcroPhysics.Collision.AABBHelper.ComputePolygonAABB(this._vertices,transform,aabb)},CompareTo:function(shape){if(this.Vertices.Count!==shape.Vertices.Count)return!1;for(var i=0;i<this.Vertices.Count;i=i+1|0)if(Microsoft.Xna.Framework.Vector2.op_Inequality(this.Vertices.getItem(i).$clone(),shape.Vertices.getItem(i).$clone()))return!1;return this.Radius===shape.Radius&&VelcroPhysics.Collision.Shapes.MassData.op_Equality(this.MassData.$clone(),shape.MassData.$clone())},Clone:function(){var clone=new VelcroPhysics.Collision.Shapes.PolygonShape.ctor;return clone.ShapeType=this.ShapeType,clone._radius=this._radius,clone._density=this._density,clone._vertices=new VelcroPhysics.Shared.Vertices.$ctor1(this._vertices),clone._normals=new VelcroPhysics.Shared.Vertices.$ctor1(this._normals),clone.MassData=this.MassData.$clone(),clone}}});Bridge.define("VelcroPhysics.Dynamics.Joints.AngleJoint",{inherits:[VelcroPhysics.Dynamics.Joints.Joint],fields:{_bias:0,_jointError:0,_massFactor:0,_targetAngle:0,BiasFactor:0,MaxImpulse:0,Softness:0},props:{WorldAnchorA:{get:function(){return this.BodyA.Position.$clone()},set:function(value){System.Diagnostics.Debug.Assert$1(!1,"You can't set the world anchor on this joint type.")}},WorldAnchorB:{get:function(){return this.BodyB.Position.$clone()},set:function(value){System.Diagnostics.Debug.Assert$1(!1,"You can't set the world anchor on this joint type.")}},TargetAngle:{get:function(){return this._targetAngle},set:function(value){value!==this._targetAngle&&(this._targetAngle=value,this.WakeBodies())}}},ctors:{ctor:function(){this.$initialize();VelcroPhysics.Dynamics.Joints.Joint.ctor.call(this);this.JointType=VelcroPhysics.Dynamics.Joints.JointType.Angle},$ctor1:function(bodyA,bodyB){this.$initialize();VelcroPhysics.Dynamics.Joints.Joint.$ctor2.call(this,bodyA,bodyB);this.JointType=VelcroPhysics.Dynamics.Joints.JointType.Angle;this.BiasFactor=.2;this.MaxImpulse=340282347e30}},methods:{GetReactionForce:function(invDt){return Microsoft.Xna.Framework.Vector2.Zero.$clone()},GetReactionTorque:function(invDt){return 0},InitVelocityConstraints:function(data){var indexA=this.BodyA.IslandIndex,indexB=this.BodyB.IslandIndex,aW=data.v.Positions[indexA].A,bW=data.v.Positions[indexB].A;this._jointError=bW-aW-this.TargetAngle;this._bias=-this.BiasFactor*data.v.Step.inv_dt*this._jointError;this._massFactor=(1-this.Softness)/(this.BodyA._invI+this.BodyB._invI)},SolveVelocityConstraints:function(data){var indexA=this.BodyA.IslandIndex,indexB=this.BodyB.IslandIndex,p=(this._bias-data.v.Velocities[indexB].W+data.v.Velocities[indexA].W)*this._massFactor;data.v.Velocities[indexA].W-=this.BodyA._invI*Bridge.Int.sign(p)*Math.min(Math.abs(p),this.MaxImpulse);data.v.Velocities[indexB].W+=this.BodyB._invI*Bridge.Int.sign(p)*Math.min(Math.abs(p),this.MaxImpulse)},SolvePositionConstraints:function(data){return!0}}});Bridge.define("VelcroPhysics.Dynamics.Joints.DistanceJoint",{inherits:[VelcroPhysics.Dynamics.Joints.Joint],fields:{_bias:0,_gamma:0,_impulse:0,_indexA:0,_indexB:0,_invIA:0,_invIB:0,_invMassA:0,_invMassB:0,_localCenterA:null,_localCenterB:null,_mass:0,_rA:null,_rB:null,_u:null,LocalAnchorA:null,LocalAnchorB:null,Length:0,Frequency:0,DampingRatio:0},props:{WorldAnchorA:{get:function(){return this.BodyA.GetWorldPoint(this.LocalAnchorA.$clone())},set:function(value){System.Diagnostics.Debug.Assert$1(!1,"You can't set the world anchor on this joint type.")}},WorldAnchorB:{get:function(){return this.BodyB.GetWorldPoint(this.LocalAnchorB.$clone())},set:function(value){System.Diagnostics.Debug.Assert$1(!1,"You can't set the world anchor on this joint type.")}}},ctors:{init:function(){this._localCenterA=new Microsoft.Xna.Framework.Vector2;this._localCenterB=new Microsoft.Xna.Framework.Vector2;this._rA=new Microsoft.Xna.Framework.Vector2;this._rB=new Microsoft.Xna.Framework.Vector2;this._u=new Microsoft.Xna.Framework.Vector2;this.LocalAnchorA=new Microsoft.Xna.Framework.Vector2;this.LocalAnchorB=new Microsoft.Xna.Framework.Vector2},ctor:function(){this.$initialize();VelcroPhysics.Dynamics.Joints.Joint.ctor.call(this);this.JointType=VelcroPhysics.Dynamics.Joints.JointType.Distance},$ctor1:function(bodyA,bodyB,anchorA,anchorB,useWorldCoordinates){useWorldCoordinates===void 0&&(useWorldCoordinates=!1);anchorA={v:anchorA};anchorB={v:anchorB};this.$initialize();VelcroPhysics.Dynamics.Joints.Joint.$ctor2.call(this,bodyA,bodyB);this.JointType=VelcroPhysics.Dynamics.Joints.JointType.Distance;useWorldCoordinates?(this.LocalAnchorA=bodyA.GetLocalPoint$1(anchorA),this.LocalAnchorB=bodyB.GetLocalPoint$1(anchorB),this.Length=Microsoft.Xna.Framework.Vector2.op_Subtraction(anchorB.v.$clone(),anchorA.v.$clone()).Length()):(this.LocalAnchorA=anchorA.v.$clone(),this.LocalAnchorB=anchorB.v.$clone(),this.Length=Microsoft.Xna.Framework.Vector2.op_Subtraction(this.BodyB.GetWorldPoint$1(anchorB),this.BodyA.GetWorldPoint$1(anchorA)).Length())}},methods:{GetReactionForce:function(invDt){var F=Microsoft.Xna.Framework.Vector2.op_Multiply$2(invDt*this._impulse,this._u.$clone());return F.$clone()},GetReactionTorque:function(invDt){return 0},InitVelocityConstraints:function(data){var length,P;this._indexA=this.BodyA.IslandIndex;this._indexB=this.BodyB.IslandIndex;this._localCenterA=this.BodyA._sweep.LocalCenter.$clone();this._localCenterB=this.BodyB._sweep.LocalCenter.$clone();this._invMassA=this.BodyA._invMass;this._invMassB=this.BodyB._invMass;this._invIA=this.BodyA._invI;this._invIB=this.BodyB._invI;var cA=data.v.Positions[this._indexA].C.$clone(),aA=data.v.Positions[this._indexA].A,vA=data.v.Velocities[this._indexA].V.$clone(),wA=data.v.Velocities[this._indexA].W,cB=data.v.Positions[this._indexB].C.$clone(),aB=data.v.Positions[this._indexB].A,vB=data.v.Velocities[this._indexB].V.$clone(),wB=data.v.Velocities[this._indexB].W,qA=new VelcroPhysics.Shared.Rot.$ctor1(aA),qB=new VelcroPhysics.Shared.Rot.$ctor1(aB);this._rA=VelcroPhysics.Utilities.MathUtils.Mul$2(qA.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(),this._localCenterA.$clone()));this._rB=VelcroPhysics.Utilities.MathUtils.Mul$2(qB.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(),this._localCenterB.$clone()));this._u=Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(cB.$clone(),this._rB.$clone()),cA.$clone()),this._rA.$clone());length=this._u.Length();this._u=length>VelcroPhysics.Settings.LinearSlop?Microsoft.Xna.Framework.Vector2.op_Multiply$1(this._u.$clone(),1/length):Microsoft.Xna.Framework.Vector2.Zero.$clone();var crAu=VelcroPhysics.Utilities.MathUtils.Cross$3(this._rA.$clone(),this._u.$clone()),crBu=VelcroPhysics.Utilities.MathUtils.Cross$3(this._rB.$clone(),this._u.$clone()),invMass=this._invMassA+this._invIA*crAu*crAu+this._invMassB+this._invIB*crBu*crBu;if(this._mass=invMass!==0?1/invMass:0,this.Frequency>0){var C=length-this.Length,omega=6.28318548*this.Frequency,d=2*this._mass*this.DampingRatio*omega,k=this._mass*omega*omega,h=data.v.Step.dt;this._gamma=h*(d+h*k);this._gamma=this._gamma!==0?1/this._gamma:0;this._bias=C*h*k*this._gamma;invMass+=this._gamma;this._mass=invMass!==0?1/invMass:0}else this._gamma=0,this._bias=0;VelcroPhysics.Settings.EnableWarmstarting?(this._impulse*=data.v.Step.dtRatio,P=Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._impulse,this._u.$clone()),vA=Microsoft.Xna.Framework.Vector2.op_Subtraction(vA.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._invMassA,P.$clone())),wA-=this._invIA*VelcroPhysics.Utilities.MathUtils.Cross$3(this._rA.$clone(),P.$clone()),vB=Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._invMassB,P.$clone())),wB+=this._invIB*VelcroPhysics.Utilities.MathUtils.Cross$3(this._rB.$clone(),P.$clone())):this._impulse=0;data.v.Velocities[this._indexA].V=vA.$clone();data.v.Velocities[this._indexA].W=wA;data.v.Velocities[this._indexB].V=vB.$clone();data.v.Velocities[this._indexB].W=wB},SolveVelocityConstraints:function(data){var vA=data.v.Velocities[this._indexA].V.$clone(),wA=data.v.Velocities[this._indexA].W,vB=data.v.Velocities[this._indexB].V.$clone(),wB=data.v.Velocities[this._indexB].W,vpA=Microsoft.Xna.Framework.Vector2.op_Addition(vA.$clone(),VelcroPhysics.Utilities.MathUtils.Cross$1(wA,this._rA.$clone())),vpB=Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(),VelcroPhysics.Utilities.MathUtils.Cross$1(wB,this._rB.$clone())),Cdot=Microsoft.Xna.Framework.Vector2.Dot(this._u.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(vpB.$clone(),vpA.$clone())),impulse=-this._mass*(Cdot+this._bias+this._gamma*this._impulse),P;this._impulse+=impulse;P=Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse,this._u.$clone());vA=Microsoft.Xna.Framework.Vector2.op_Subtraction(vA.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._invMassA,P.$clone()));wA-=this._invIA*VelcroPhysics.Utilities.MathUtils.Cross$3(this._rA.$clone(),P.$clone());vB=Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._invMassB,P.$clone()));wB+=this._invIB*VelcroPhysics.Utilities.MathUtils.Cross$3(this._rB.$clone(),P.$clone());data.v.Velocities[this._indexA].V=vA.$clone();data.v.Velocities[this._indexA].W=wA;data.v.Velocities[this._indexB].V=vB.$clone();data.v.Velocities[this._indexB].W=wB},SolvePositionConstraints:function(data){var C,impulse,P;if(this.Frequency>0)return!0;var cA=data.v.Positions[this._indexA].C.$clone(),aA=data.v.Positions[this._indexA].A,cB=data.v.Positions[this._indexB].C.$clone(),aB=data.v.Positions[this._indexB].A,qA=new VelcroPhysics.Shared.Rot.$ctor1(aA),qB=new VelcroPhysics.Shared.Rot.$ctor1(aB),rA=VelcroPhysics.Utilities.MathUtils.Mul$2(qA.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(),this._localCenterA.$clone())),rB=VelcroPhysics.Utilities.MathUtils.Mul$2(qB.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(),this._localCenterB.$clone())),u=Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(cB.$clone(),rB.$clone()),cA.$clone()),rA.$clone()),length=u.Length();return u.Normalize(),C=length-this.Length,C=VelcroPhysics.Utilities.MathUtils.Clamp$2(C,-.2,VelcroPhysics.Settings.MaxLinearCorrection),impulse=-this._mass*C,P=Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse,u.$clone()),cA=Microsoft.Xna.Framework.Vector2.op_Subtraction(cA.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._invMassA,P.$clone())),aA-=this._invIA*VelcroPhysics.Utilities.MathUtils.Cross$3(rA.$clone(),P.$clone()),cB=Microsoft.Xna.Framework.Vector2.op_Addition(cB.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._invMassB,P.$clone())),aB+=this._invIB*VelcroPhysics.Utilities.MathUtils.Cross$3(rB.$clone(),P.$clone()),data.v.Positions[this._indexA].C=cA.$clone(),data.v.Positions[this._indexA].A=aA,data.v.Positions[this._indexB].C=cB.$clone(),data.v.Positions[this._indexB].A=aB,Math.abs(C)<VelcroPhysics.Settings.LinearSlop}}});Bridge.define("VelcroPhysics.Dynamics.Joints.FixedMouseJoint",{inherits:[VelcroPhysics.Dynamics.Joints.Joint],fields:{_beta:0,_C:null,_dampingRatio:0,_frequency:0,_gamma:0,_impulse:null,_indexA:0,_invIA:0,_invMassA:0,_localCenterA:null,_mass:null,_maxForce:0,_rA:null,_worldAnchor:null,LocalAnchorA:null},props:{WorldAnchorA:{get:function(){return this.BodyA.GetWorldPoint(this.LocalAnchorA.$clone())},set:function(value){this.LocalAnchorA=this.BodyA.GetLocalPoint(value.$clone())}},WorldAnchorB:{get:function(){return this._worldAnchor.$clone()},set:function(value){this.WakeBodies();this._worldAnchor=value.$clone()}},MaxForce:{get:function(){return this._maxForce},set:function(value){System.Diagnostics.Debug.Assert(VelcroPhysics.Utilities.MathUtils.IsValid$1(value)&&value>=0);this._maxForce=value}},Frequency:{get:function(){return this._frequency},set:function(value){System.Diagnostics.Debug.Assert(VelcroPhysics.Utilities.MathUtils.IsValid$1(value)&&value>=0);this._frequency=value}},DampingRatio:{get:function(){return this._dampingRatio},set:function(value){System.Diagnostics.Debug.Assert(VelcroPhysics.Utilities.MathUtils.IsValid$1(value)&&value>=0);this._dampingRatio=value}}},ctors:{init:function(){this._C=new Microsoft.Xna.Framework.Vector2;this._impulse=new Microsoft.Xna.Framework.Vector2;this._localCenterA=new Microsoft.Xna.Framework.Vector2;this._mass=new VelcroPhysics.Shared.Mat22;this._rA=new Microsoft.Xna.Framework.Vector2;this._worldAnchor=new Microsoft.Xna.Framework.Vector2;this.LocalAnchorA=new Microsoft.Xna.Framework.Vector2},ctor:function(body,worldAnchor){this.$initialize();VelcroPhysics.Dynamics.Joints.Joint.$ctor1.call(this,body);this.JointType=VelcroPhysics.Dynamics.Joints.JointType.FixedMouse;this.Frequency=5;this.DampingRatio=.7;this.MaxForce=1e3*body.Mass;System.Diagnostics.Debug.Assert(VelcroPhysics.Utilities.MathUtils.IsValid(worldAnchor));this._worldAnchor=worldAnchor.$clone();this.LocalAnchorA=VelcroPhysics.Utilities.MathUtils.MulT$4(this.BodyA._xf.$clone(),worldAnchor.$clone())}},methods:{GetReactionForce:function(invDt){return Microsoft.Xna.Framework.Vector2.op_Multiply$2(invDt,this._impulse.$clone())},GetReactionTorque:function(invDt){return invDt*0},InitVelocityConstraints:function(data){var K;this._indexA=this.BodyA.IslandIndex;this._localCenterA=this.BodyA._sweep.LocalCenter.$clone();this._invMassA=this.BodyA._invMass;this._invIA=this.BodyA._invI;var cA=data.v.Positions[this._indexA].C.$clone(),aA=data.v.Positions[this._indexA].A,vA=data.v.Velocities[this._indexA].V.$clone(),wA=data.v.Velocities[this._indexA].W,qA=new VelcroPhysics.Shared.Rot.$ctor1(aA),mass=this.BodyA.Mass,omega=6.28318548*this.Frequency,d=2*mass*this.DampingRatio*omega,k=mass*omega*omega,h=data.v.Step.dt;System.Diagnostics.Debug.Assert(d+h*k>VelcroPhysics.Settings.Epsilon);this._gamma=h*(d+h*k);this._gamma!==0&&(this._gamma=1/this._gamma);this._beta=h*k*this._gamma;this._rA=VelcroPhysics.Utilities.MathUtils.Mul$2(qA.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(),this._localCenterA.$clone()));K=new VelcroPhysics.Shared.Mat22.ctor;K.ex.X=this._invMassA+this._invIA*this._rA.Y*this._rA.Y+this._gamma;K.ex.Y=-this._invIA*this._rA.X*this._rA.Y;K.ey.X=K.ex.Y;K.ey.Y=this._invMassA+this._invIA*this._rA.X*this._rA.X+this._gamma;this._mass=K.Inverse.$clone();this._C=Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(cA.$clone(),this._rA.$clone()),this._worldAnchor.$clone());this._C=Microsoft.Xna.Framework.Vector2.op_Multiply$1(this._C.$clone(),this._beta);wA*=.98;VelcroPhysics.Settings.EnableWarmstarting?(this._impulse=Microsoft.Xna.Framework.Vector2.op_Multiply$1(this._impulse.$clone(),data.v.Step.dtRatio),vA=Microsoft.Xna.Framework.Vector2.op_Addition(vA.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._invMassA,this._impulse.$clone())),wA+=this._invIA*VelcroPhysics.Utilities.MathUtils.Cross$3(this._rA.$clone(),this._impulse.$clone())):this._impulse=Microsoft.Xna.Framework.Vector2.Zero.$clone();data.v.Velocities[this._indexA].V=vA.$clone();data.v.Velocities[this._indexA].W=wA},SolveVelocityConstraints:function(data){var vA=data.v.Velocities[this._indexA].V.$clone(),wA=data.v.Velocities[this._indexA].W,Cdot=Microsoft.Xna.Framework.Vector2.op_Addition(vA.$clone(),VelcroPhysics.Utilities.MathUtils.Cross$1(wA,this._rA.$clone())),impulse=VelcroPhysics.Utilities.MathUtils.Mul(Bridge.ref(this,"_mass"),Microsoft.Xna.Framework.Vector2.op_UnaryNegation(Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Addition(Cdot.$clone(),this._C.$clone()),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._gamma,this._impulse.$clone())))),oldImpulse=this._impulse.$clone(),maxImpulse;this._impulse=Microsoft.Xna.Framework.Vector2.op_Addition(this._impulse.$clone(),impulse.$clone());maxImpulse=data.v.Step.dt*this.MaxForce;this._impulse.LengthSquared()>maxImpulse*maxImpulse&&(this._impulse=Microsoft.Xna.Framework.Vector2.op_Multiply$1(this._impulse.$clone(),maxImpulse/this._impulse.Length()));impulse=Microsoft.Xna.Framework.Vector2.op_Subtraction(this._impulse.$clone(),oldImpulse.$clone());vA=Microsoft.Xna.Framework.Vector2.op_Addition(vA.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._invMassA,impulse.$clone()));wA+=this._invIA*VelcroPhysics.Utilities.MathUtils.Cross$3(this._rA.$clone(),impulse.$clone());data.v.Velocities[this._indexA].V=vA.$clone();data.v.Velocities[this._indexA].W=wA},SolvePositionConstraints:function(data){return!0}}});Bridge.define("VelcroPhysics.Dynamics.Joints.FrictionJoint",{inherits:[VelcroPhysics.Dynamics.Joints.Joint],fields:{_angularImpulse:0,_angularMass:0,_indexA:0,_indexB:0,_invIA:0,_invIB:0,_invMassA:0,_invMassB:0,_linearImpulse:null,_linearMass:null,_localCenterA:null,_localCenterB:null,_rA:null,_rB:null,LocalAnchorA:null,LocalAnchorB:null,MaxForce:0,MaxTorque:0},props:{WorldAnchorA:{get:function(){return this.BodyA.GetWorldPoint(this.LocalAnchorA.$clone())},set:function(value){this.LocalAnchorA=this.BodyA.GetLocalPoint(value.$clone())}},WorldAnchorB:{get:function(){return this.BodyB.GetWorldPoint(this.LocalAnchorB.$clone())},set:function(value){this.LocalAnchorB=this.BodyB.GetLocalPoint(value.$clone())}}},ctors:{init:function(){this._linearImpulse=new Microsoft.Xna.Framework.Vector2;this._linearMass=new VelcroPhysics.Shared.Mat22;this._localCenterA=new Microsoft.Xna.Framework.Vector2;this._localCenterB=new Microsoft.Xna.Framework.Vector2;this._rA=new Microsoft.Xna.Framework.Vector2;this._rB=new Microsoft.Xna.Framework.Vector2;this.LocalAnchorA=new Microsoft.Xna.Framework.Vector2;this.LocalAnchorB=new Microsoft.Xna.Framework.Vector2},ctor:function(){this.$initialize();VelcroPhysics.Dynamics.Joints.Joint.ctor.call(this);this.JointType=VelcroPhysics.Dynamics.Joints.JointType.Friction},$ctor1:function(bodyA,bodyB,anchor,useWorldCoordinates){useWorldCoordinates===void 0&&(useWorldCoordinates=!1);this.$initialize();VelcroPhysics.Dynamics.Joints.Joint.$ctor2.call(this,bodyA,bodyB);this.JointType=VelcroPhysics.Dynamics.Joints.JointType.Friction;useWorldCoordinates?(this.LocalAnchorA=this.BodyA.GetLocalPoint(anchor.$clone()),this.LocalAnchorB=this.BodyB.GetLocalPoint(anchor.$clone())):(this.LocalAnchorA=anchor.$clone(),this.LocalAnchorB=anchor.$clone())}},methods:{GetReactionForce:function(invDt){return Microsoft.Xna.Framework.Vector2.op_Multiply$2(invDt,this._linearImpulse.$clone())},GetReactionTorque:function(invDt){return invDt*this._angularImpulse},InitVelocityConstraints:function(data){var P;this._indexA=this.BodyA.IslandIndex;this._indexB=this.BodyB.IslandIndex;this._localCenterA=this.BodyA._sweep.LocalCenter.$clone();this._localCenterB=this.BodyB._sweep.LocalCenter.$clone();this._invMassA=this.BodyA._invMass;this._invMassB=this.BodyB._invMass;this._invIA=this.BodyA._invI;this._invIB=this.BodyB._invI;var aA=data.v.Positions[this._indexA].A,vA=data.v.Velocities[this._indexA].V.$clone(),wA=data.v.Velocities[this._indexA].W,aB=data.v.Positions[this._indexB].A,vB=data.v.Velocities[this._indexB].V.$clone(),wB=data.v.Velocities[this._indexB].W,qA=new VelcroPhysics.Shared.Rot.$ctor1(aA),qB=new VelcroPhysics.Shared.Rot.$ctor1(aB);this._rA=VelcroPhysics.Utilities.MathUtils.Mul$2(qA.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(),this._localCenterA.$clone()));this._rB=VelcroPhysics.Utilities.MathUtils.Mul$2(qB.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(),this._localCenterB.$clone()));var mA=this._invMassA,mB=this._invMassB,iA=this._invIA,iB=this._invIB,K=new VelcroPhysics.Shared.Mat22.ctor;K.ex.X=mA+mB+iA*this._rA.Y*this._rA.Y+iB*this._rB.Y*this._rB.Y;K.ex.Y=-iA*this._rA.X*this._rA.Y-iB*this._rB.X*this._rB.Y;K.ey.X=K.ex.Y;K.ey.Y=mA+mB+iA*this._rA.X*this._rA.X+iB*this._rB.X*this._rB.X;this._linearMass=K.Inverse.$clone();this._angularMass=iA+iB;this._angularMass>0&&(this._angularMass=1/this._angularMass);VelcroPhysics.Settings.EnableWarmstarting?(this._linearImpulse=Microsoft.Xna.Framework.Vector2.op_Multiply$1(this._linearImpulse.$clone(),data.v.Step.dtRatio),this._angularImpulse*=data.v.Step.dtRatio,P=new Microsoft.Xna.Framework.Vector2.$ctor2(this._linearImpulse.X,this._linearImpulse.Y),vA=Microsoft.Xna.Framework.Vector2.op_Subtraction(vA.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mA,P.$clone())),wA-=iA*(VelcroPhysics.Utilities.MathUtils.Cross$3(this._rA.$clone(),P.$clone())+this._angularImpulse),vB=Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mB,P.$clone())),wB+=iB*(VelcroPhysics.Utilities.MathUtils.Cross$3(this._rB.$clone(),P.$clone())+this._angularImpulse)):(this._linearImpulse=Microsoft.Xna.Framework.Vector2.Zero.$clone(),this._angularImpulse=0);data.v.Velocities[this._indexA].V=vA.$clone();data.v.Velocities[this._indexA].W=wA;data.v.Velocities[this._indexB].V=vB.$clone();data.v.Velocities[this._indexB].W=wB},SolveVelocityConstraints:function(data){var vA=data.v.Velocities[this._indexA].V.$clone(),wA=data.v.Velocities[this._indexA].W,vB=data.v.Velocities[this._indexB].V.$clone(),wB=data.v.Velocities[this._indexB].W,mA=this._invMassA,mB=this._invMassB,iA=this._invIA,iB=this._invIB,h=data.v.Step.dt,Cdot=wB-wA,impulse=-this._angularMass*Cdot,oldImpulse=this._angularImpulse,maxImpulse=h*this.MaxTorque,maxImpulse1;this._angularImpulse=VelcroPhysics.Utilities.MathUtils.Clamp$2(this._angularImpulse+impulse,-maxImpulse,maxImpulse);impulse=this._angularImpulse-oldImpulse;wA-=iA*impulse;wB+=iB*impulse;var Cdot1=Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(),VelcroPhysics.Utilities.MathUtils.Cross$1(wB,this._rB.$clone())),vA.$clone()),VelcroPhysics.Utilities.MathUtils.Cross$1(wA,this._rA.$clone())),impulse1=Microsoft.Xna.Framework.Vector2.op_UnaryNegation(VelcroPhysics.Utilities.MathUtils.Mul(Bridge.ref(this,"_linearMass"),Cdot1.$clone())),oldImpulse1=this._linearImpulse.$clone();this._linearImpulse=Microsoft.Xna.Framework.Vector2.op_Addition(this._linearImpulse.$clone(),impulse1.$clone());maxImpulse1=h*this.MaxForce;this._linearImpulse.LengthSquared()>maxImpulse1*maxImpulse1&&(this._linearImpulse.Normalize(),this._linearImpulse=Microsoft.Xna.Framework.Vector2.op_Multiply$1(this._linearImpulse.$clone(),maxImpulse1));impulse1=Microsoft.Xna.Framework.Vector2.op_Subtraction(this._linearImpulse.$clone(),oldImpulse1.$clone());vA=Microsoft.Xna.Framework.Vector2.op_Subtraction(vA.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mA,impulse1.$clone()));wA-=iA*VelcroPhysics.Utilities.MathUtils.Cross$3(this._rA.$clone(),impulse1.$clone());vB=Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mB,impulse1.$clone()));wB+=iB*VelcroPhysics.Utilities.MathUtils.Cross$3(this._rB.$clone(),impulse1.$clone());data.v.Velocities[this._indexA].V=vA.$clone();data.v.Velocities[this._indexA].W=wA;data.v.Velocities[this._indexB].V=vB.$clone();data.v.Velocities[this._indexB].W=wB},SolvePositionConstraints:function(data){return!0}}});Bridge.define("VelcroPhysics.Dynamics.Joints.GearJoint",{inherits:[VelcroPhysics.Dynamics.Joints.Joint],fields:{_bodyA:null,_bodyB:null,_bodyC:null,_bodyD:null,_constant:0,_iA:0,_iB:0,_iC:0,_iD:0,_impulse:0,_indexA:0,_indexB:0,_indexC:0,_indexD:0,_JvAC:null,_JvBD:null,_JwA:0,_JwB:0,_JwC:0,_JwD:0,_lcA:null,_lcB:null,_lcC:null,_lcD:null,_localAnchorA:null,_localAnchorB:null,_localAnchorC:null,_localAnchorD:null,_localAxisC:null,_localAxisD:null,_mA:0,_mB:0,_mC:0,_mD:0,_mass:0,_ratio:0,_referenceAngleA:0,_referenceAngleB:0,_typeA:0,_typeB:0,JointA:null,JointB:null},props:{WorldAnchorA:{get:function(){return this._bodyA.GetWorldPoint(this._localAnchorA.$clone())},set:function(value){System.Diagnostics.Debug.Assert$1(!1,"You can't set the world anchor on this joint type.")}},WorldAnchorB:{get:function(){return this._bodyB.GetWorldPoint(this._localAnchorB.$clone())},set:function(value){System.Diagnostics.Debug.Assert$1(!1,"You can't set the world anchor on this joint type.")}},Ratio:{get:function(){return this._ratio},set:function(value){System.Diagnostics.Debug.Assert(VelcroPhysics.Utilities.MathUtils.IsValid$1(value));this._ratio=value}}},ctors:{init:function(){this._JvAC=new Microsoft.Xna.Framework.Vector2;this._JvBD=new Microsoft.Xna.Framework.Vector2;this._lcA=new Microsoft.Xna.Framework.Vector2;this._lcB=new Microsoft.Xna.Framework.Vector2;this._lcC=new Microsoft.Xna.Framework.Vector2;this._lcD=new Microsoft.Xna.Framework.Vector2;this._localAnchorA=new Microsoft.Xna.Framework.Vector2;this._localAnchorB=new Microsoft.Xna.Framework.Vector2;this._localAnchorC=new Microsoft.Xna.Framework.Vector2;this._localAnchorD=new Microsoft.Xna.Framework.Vector2;this._localAxisC=new Microsoft.Xna.Framework.Vector2;this._localAxisD=new Microsoft.Xna.Framework.Vector2},ctor:function(bodyA,bodyB,jointA,jointB,ratio){var coordinateA,coordinateB,revolute,prismatic,pC,pA,revolute1,prismatic1,pD,pB;ratio===void 0&&(ratio=1);this.$initialize();VelcroPhysics.Dynamics.Joints.Joint.ctor.call(this);this.JointType=VelcroPhysics.Dynamics.Joints.JointType.Gear;this.BodyA=bodyA;this.BodyB=bodyB;this.JointA=jointA;this.JointB=jointB;this.Ratio=ratio;this._typeA=jointA.JointType;this._typeB=jointB.JointType;System.Diagnostics.Debug.Assert(this._typeA===VelcroPhysics.Dynamics.Joints.JointType.Revolute||this._typeA===VelcroPhysics.Dynamics.Joints.JointType.Prismatic||this._typeA===VelcroPhysics.Dynamics.Joints.JointType.FixedRevolute||this._typeA===VelcroPhysics.Dynamics.Joints.JointType.FixedPrismatic);System.Diagnostics.Debug.Assert(this._typeB===VelcroPhysics.Dynamics.Joints.JointType.Revolute||this._typeB===VelcroPhysics.Dynamics.Joints.JointType.Prismatic||this._typeB===VelcroPhysics.Dynamics.Joints.JointType.FixedRevolute||this._typeB===VelcroPhysics.Dynamics.Joints.JointType.FixedPrismatic);this._bodyC=this.JointA.BodyA;this._bodyA=this.JointA.BodyB;var xfA=this._bodyA._xf.$clone(),aA=this._bodyA._sweep.A,xfC=this._bodyC._xf.$clone(),aC=this._bodyC._sweep.A;this._typeA===VelcroPhysics.Dynamics.Joints.JointType.Revolute?(revolute=Bridge.cast(jointA,VelcroPhysics.Dynamics.Joints.RevoluteJoint),this._localAnchorC=revolute.LocalAnchorA.$clone(),this._localAnchorA=revolute.LocalAnchorB.$clone(),this._referenceAngleA=revolute.ReferenceAngle,this._localAxisC=Microsoft.Xna.Framework.Vector2.Zero.$clone(),coordinateA=aA-aC-this._referenceAngleA):(prismatic=Bridge.cast(jointA,VelcroPhysics.Dynamics.Joints.PrismaticJoint),this._localAnchorC=prismatic.LocalAnchorA.$clone(),this._localAnchorA=prismatic.LocalAnchorB.$clone(),this._referenceAngleA=prismatic.ReferenceAngle,this._localAxisC=prismatic.LocalXAxis.$clone(),pC=this._localAnchorC.$clone(),pA=VelcroPhysics.Utilities.MathUtils.MulT$2(xfC.q.$clone(),Microsoft.Xna.Framework.Vector2.op_Addition(VelcroPhysics.Utilities.MathUtils.Mul$2(xfA.q.$clone(),this._localAnchorA.$clone()),Microsoft.Xna.Framework.Vector2.op_Subtraction(xfA.p.$clone(),xfC.p.$clone()))),coordinateA=Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(pA.$clone(),pC.$clone()),this._localAxisC.$clone()));this._bodyD=this.JointB.BodyA;this._bodyB=this.JointB.BodyB;var xfB=this._bodyB._xf.$clone(),aB=this._bodyB._sweep.A,xfD=this._bodyD._xf.$clone(),aD=this._bodyD._sweep.A;this._typeB===VelcroPhysics.Dynamics.Joints.JointType.Revolute?(revolute1=Bridge.cast(jointB,VelcroPhysics.Dynamics.Joints.RevoluteJoint),this._localAnchorD=revolute1.LocalAnchorA.$clone(),this._localAnchorB=revolute1.LocalAnchorB.$clone(),this._referenceAngleB=revolute1.ReferenceAngle,this._localAxisD=Microsoft.Xna.Framework.Vector2.Zero.$clone(),coordinateB=aB-aD-this._referenceAngleB):(prismatic1=Bridge.cast(jointB,VelcroPhysics.Dynamics.Joints.PrismaticJoint),this._localAnchorD=prismatic1.LocalAnchorA.$clone(),this._localAnchorB=prismatic1.LocalAnchorB.$clone(),this._referenceAngleB=prismatic1.ReferenceAngle,this._localAxisD=prismatic1.LocalXAxis.$clone(),pD=this._localAnchorD.$clone(),pB=VelcroPhysics.Utilities.MathUtils.MulT$2(xfD.q.$clone(),Microsoft.Xna.Framework.Vector2.op_Addition(VelcroPhysics.Utilities.MathUtils.Mul$2(xfB.q.$clone(),this._localAnchorB.$clone()),Microsoft.Xna.Framework.Vector2.op_Subtraction(xfB.p.$clone(),xfD.p.$clone()))),coordinateB=Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(pB.$clone(),pD.$clone()),this._localAxisD.$clone()));this._ratio=ratio;this._constant=coordinateA+this._ratio*coordinateB;this._impulse=0}},methods:{GetReactionForce:function(invDt){var P=Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._impulse,this._JvAC.$clone());return Microsoft.Xna.Framework.Vector2.op_Multiply$2(invDt,P.$clone())},GetReactionTorque:function(invDt){var L=this._impulse*this._JwA;return invDt*L},InitVelocityConstraints:function(data){this._indexA=this._bodyA.IslandIndex;this._indexB=this._bodyB.IslandIndex;this._indexC=this._bodyC.IslandIndex;this._indexD=this._bodyD.IslandIndex;this._lcA=this._bodyA._sweep.LocalCenter.$clone();this._lcB=this._bodyB._sweep.LocalCenter.$clone();this._lcC=this._bodyC._sweep.LocalCenter.$clone();this._lcD=this._bodyD._sweep.LocalCenter.$clone();this._mA=this._bodyA._invMass;this._mB=this._bodyB._invMass;this._mC=this._bodyC._invMass;this._mD=this._bodyD._invMass;this._iA=this._bodyA._invI;this._iB=this._bodyB._invI;this._iC=this._bodyC._invI;this._iD=this._bodyD._invI;var aA=data.v.Positions[this._indexA].A,vA=data.v.Velocities[this._indexA].V.$clone(),wA=data.v.Velocities[this._indexA].W,aB=data.v.Positions[this._indexB].A,vB=data.v.Velocities[this._indexB].V.$clone(),wB=data.v.Velocities[this._indexB].W,aC=data.v.Positions[this._indexC].A,vC=data.v.Velocities[this._indexC].V.$clone(),wC=data.v.Velocities[this._indexC].W,aD=data.v.Positions[this._indexD].A,vD=data.v.Velocities[this._indexD].V.$clone(),wD=data.v.Velocities[this._indexD].W,qA=new VelcroPhysics.Shared.Rot.$ctor1(aA),qB=new VelcroPhysics.Shared.Rot.$ctor1(aB),qC=new VelcroPhysics.Shared.Rot.$ctor1(aC),qD=new VelcroPhysics.Shared.Rot.$ctor1(aD);if(this._mass=0,this._typeA===VelcroPhysics.Dynamics.Joints.JointType.Revolute)this._JvAC=Microsoft.Xna.Framework.Vector2.Zero.$clone(),this._JwA=1,this._JwC=1,this._mass+=this._iA+this._iC;else{var u=VelcroPhysics.Utilities.MathUtils.Mul$2(qC.$clone(),this._localAxisC.$clone()),rC=VelcroPhysics.Utilities.MathUtils.Mul$2(qC.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(this._localAnchorC.$clone(),this._lcC.$clone())),rA=VelcroPhysics.Utilities.MathUtils.Mul$2(qA.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(this._localAnchorA.$clone(),this._lcA.$clone()));this._JvAC=u.$clone();this._JwC=VelcroPhysics.Utilities.MathUtils.Cross$3(rC.$clone(),u.$clone());this._JwA=VelcroPhysics.Utilities.MathUtils.Cross$3(rA.$clone(),u.$clone());this._mass+=this._mC+this._mA+this._iC*this._JwC*this._JwC+this._iA*this._JwA*this._JwA}if(this._typeB===VelcroPhysics.Dynamics.Joints.JointType.Revolute)this._JvBD=Microsoft.Xna.Framework.Vector2.Zero.$clone(),this._JwB=this._ratio,this._JwD=this._ratio,this._mass+=this._ratio*this._ratio*(this._iB+this._iD);else{var u1=VelcroPhysics.Utilities.MathUtils.Mul$2(qD.$clone(),this._localAxisD.$clone()),rD=VelcroPhysics.Utilities.MathUtils.Mul$2(qD.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(this._localAnchorD.$clone(),this._lcD.$clone())),rB=VelcroPhysics.Utilities.MathUtils.Mul$2(qB.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(this._localAnchorB.$clone(),this._lcB.$clone()));this._JvBD=Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._ratio,u1.$clone());this._JwD=this._ratio*VelcroPhysics.Utilities.MathUtils.Cross$3(rD.$clone(),u1.$clone());this._JwB=this._ratio*VelcroPhysics.Utilities.MathUtils.Cross$3(rB.$clone(),u1.$clone());this._mass+=this._ratio*this._ratio*(this._mD+this._mB)+this._iD*this._JwD*this._JwD+this._iB*this._JwB*this._JwB}this._mass=this._mass>0?1/this._mass:0;VelcroPhysics.Settings.EnableWarmstarting?(vA=Microsoft.Xna.Framework.Vector2.op_Addition(vA.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._mA*this._impulse,this._JvAC.$clone())),wA+=this._iA*this._impulse*this._JwA,vB=Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._mB*this._impulse,this._JvBD.$clone())),wB+=this._iB*this._impulse*this._JwB,vC=Microsoft.Xna.Framework.Vector2.op_Subtraction(vC.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._mC*this._impulse,this._JvAC.$clone())),wC-=this._iC*this._impulse*this._JwC,vD=Microsoft.Xna.Framework.Vector2.op_Subtraction(vD.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._mD*this._impulse,this._JvBD.$clone())),wD-=this._iD*this._impulse*this._JwD):this._impulse=0;data.v.Velocities[this._indexA].V=vA.$clone();data.v.Velocities[this._indexA].W=wA;data.v.Velocities[this._indexB].V=vB.$clone();data.v.Velocities[this._indexB].W=wB;data.v.Velocities[this._indexC].V=vC.$clone();data.v.Velocities[this._indexC].W=wC;data.v.Velocities[this._indexD].V=vD.$clone();data.v.Velocities[this._indexD].W=wD},SolveVelocityConstraints:function(data){var vA=data.v.Velocities[this._indexA].V.$clone(),wA=data.v.Velocities[this._indexA].W,vB=data.v.Velocities[this._indexB].V.$clone(),wB=data.v.Velocities[this._indexB].W,vC=data.v.Velocities[this._indexC].V.$clone(),wC=data.v.Velocities[this._indexC].W,vD=data.v.Velocities[this._indexD].V.$clone(),wD=data.v.Velocities[this._indexD].W,Cdot=Microsoft.Xna.Framework.Vector2.Dot(this._JvAC.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(vA.$clone(),vC.$clone()))+Microsoft.Xna.Framework.Vector2.Dot(this._JvBD.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(vB.$clone(),vD.$clone())),impulse;Cdot+=this._JwA*wA-this._JwC*wC+(this._JwB*wB-this._JwD*wD);impulse=-this._mass*Cdot;this._impulse+=impulse;vA=Microsoft.Xna.Framework.Vector2.op_Addition(vA.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._mA*impulse,this._JvAC.$clone()));wA+=this._iA*impulse*this._JwA;vB=Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._mB*impulse,this._JvBD.$clone()));wB+=this._iB*impulse*this._JwB;vC=Microsoft.Xna.Framework.Vector2.op_Subtraction(vC.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._mC*impulse,this._JvAC.$clone()));wC-=this._iC*impulse*this._JwC;vD=Microsoft.Xna.Framework.Vector2.op_Subtraction(vD.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._mD*impulse,this._JvBD.$clone()));wD-=this._iD*impulse*this._JwD;data.v.Velocities[this._indexA].V=vA.$clone();data.v.Velocities[this._indexA].W=wA;data.v.Velocities[this._indexB].V=vB.$clone();data.v.Velocities[this._indexB].W=wB;data.v.Velocities[this._indexC].V=vC.$clone();data.v.Velocities[this._indexC].W=wC;data.v.Velocities[this._indexD].V=vD.$clone();data.v.Velocities[this._indexD].W=wD},SolvePositionConstraints:function(data){var cA=data.v.Positions[this._indexA].C.$clone(),aA=data.v.Positions[this._indexA].A,cB=data.v.Positions[this._indexB].C.$clone(),aB=data.v.Positions[this._indexB].A,cC=data.v.Positions[this._indexC].C.$clone(),aC=data.v.Positions[this._indexC].A,cD=data.v.Positions[this._indexD].C.$clone(),aD=data.v.Positions[this._indexD].A,qA=new VelcroPhysics.Shared.Rot.$ctor1(aA),qB=new VelcroPhysics.Shared.Rot.$ctor1(aB),qC=new VelcroPhysics.Shared.Rot.$ctor1(aC),qD=new VelcroPhysics.Shared.Rot.$ctor1(aD),linearError=0,coordinateA,coordinateB,JvAC=new Microsoft.Xna.Framework.Vector2,JvBD=new Microsoft.Xna.Framework.Vector2,JwA,JwB,JwC,JwD,mass=0,pC,pA,pD,pB,C,impulse;if(this._typeA===VelcroPhysics.Dynamics.Joints.JointType.Revolute)JvAC=Microsoft.Xna.Framework.Vector2.Zero.$clone(),JwA=1,JwC=1,mass+=this._iA+this._iC,coordinateA=aA-aC-this._referenceAngleA;else{var u=VelcroPhysics.Utilities.MathUtils.Mul$2(qC.$clone(),this._localAxisC.$clone()),rC=VelcroPhysics.Utilities.MathUtils.Mul$2(qC.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(this._localAnchorC.$clone(),this._lcC.$clone())),rA=VelcroPhysics.Utilities.MathUtils.Mul$2(qA.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(this._localAnchorA.$clone(),this._lcA.$clone()));JvAC=u.$clone();JwC=VelcroPhysics.Utilities.MathUtils.Cross$3(rC.$clone(),u.$clone());JwA=VelcroPhysics.Utilities.MathUtils.Cross$3(rA.$clone(),u.$clone());mass+=this._mC+this._mA+this._iC*JwC*JwC+this._iA*JwA*JwA;pC=Microsoft.Xna.Framework.Vector2.op_Subtraction(this._localAnchorC.$clone(),this._lcC.$clone());pA=VelcroPhysics.Utilities.MathUtils.MulT$2(qC.$clone(),Microsoft.Xna.Framework.Vector2.op_Addition(rA.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(cA.$clone(),cC.$clone())));coordinateA=Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(pA.$clone(),pC.$clone()),this._localAxisC.$clone())}if(this._typeB===VelcroPhysics.Dynamics.Joints.JointType.Revolute)JvBD=Microsoft.Xna.Framework.Vector2.Zero.$clone(),JwB=this._ratio,JwD=this._ratio,mass+=this._ratio*this._ratio*(this._iB+this._iD),coordinateB=aB-aD-this._referenceAngleB;else{var u1=VelcroPhysics.Utilities.MathUtils.Mul$2(qD.$clone(),this._localAxisD.$clone()),rD=VelcroPhysics.Utilities.MathUtils.Mul$2(qD.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(this._localAnchorD.$clone(),this._lcD.$clone())),rB=VelcroPhysics.Utilities.MathUtils.Mul$2(qB.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(this._localAnchorB.$clone(),this._lcB.$clone()));JvBD=Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._ratio,u1.$clone());JwD=this._ratio*VelcroPhysics.Utilities.MathUtils.Cross$3(rD.$clone(),u1.$clone());JwB=this._ratio*VelcroPhysics.Utilities.MathUtils.Cross$3(rB.$clone(),u1.$clone());mass+=this._ratio*this._ratio*(this._mD+this._mB)+this._iD*JwD*JwD+this._iB*JwB*JwB;pD=Microsoft.Xna.Framework.Vector2.op_Subtraction(this._localAnchorD.$clone(),this._lcD.$clone());pB=VelcroPhysics.Utilities.MathUtils.MulT$2(qD.$clone(),Microsoft.Xna.Framework.Vector2.op_Addition(rB.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(cB.$clone(),cD.$clone())));coordinateB=Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(pB.$clone(),pD.$clone()),this._localAxisD.$clone())}return C=coordinateA+this._ratio*coordinateB-this._constant,impulse=0,mass>0&&(impulse=-C/mass),cA=Microsoft.Xna.Framework.Vector2.op_Addition(cA.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._mA*impulse,JvAC.$clone())),aA+=this._iA*impulse*JwA,cB=Microsoft.Xna.Framework.Vector2.op_Addition(cB.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._mB*impulse,JvBD.$clone())),aB+=this._iB*impulse*JwB,cC=Microsoft.Xna.Framework.Vector2.op_Subtraction(cC.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._mC*impulse,JvAC.$clone())),aC-=this._iC*impulse*JwC,cD=Microsoft.Xna.Framework.Vector2.op_Subtraction(cD.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._mD*impulse,JvBD.$clone())),aD-=this._iD*impulse*JwD,data.v.Positions[this._indexA].C=cA.$clone(),data.v.Positions[this._indexA].A=aA,data.v.Positions[this._indexB].C=cB.$clone(),data.v.Positions[this._indexB].A=aB,data.v.Positions[this._indexC].C=cC.$clone(),data.v.Positions[this._indexC].A=aC,data.v.Positions[this._indexD].C=cD.$clone(),data.v.Positions[this._indexD].A=aD,!0}}});Bridge.define("VelcroPhysics.Dynamics.Joints.MotorJoint",{inherits:[VelcroPhysics.Dynamics.Joints.Joint],fields:{_angularError:0,_angularImpulse:0,_angularMass:0,_angularOffset:0,_indexA:0,_indexB:0,_invIA:0,_invIB:0,_invMassA:0,_invMassB:0,_linearError:null,_linearImpulse:null,_linearMass:null,_linearOffset:null,_localCenterA:null,_localCenterB:null,_maxForce:0,_maxTorque:0,_rA:null,_rB:null,CorrectionFactor:0},props:{WorldAnchorA:{get:function(){return this.BodyA.Position.$clone()},set:function(value){System.Diagnostics.Debug.Assert$1(!1,"You can't set the world anchor on this joint type.")}},WorldAnchorB:{get:function(){return this.BodyB.Position.$clone()},set:function(value){System.Diagnostics.Debug.Assert$1(!1,"You can't set the world anchor on this joint type.")}},MaxForce:{get:function(){return this._maxForce},set:function(value){System.Diagnostics.Debug.Assert(VelcroPhysics.Utilities.MathUtils.IsValid$1(value)&&value>=0);this._maxForce=value}},MaxTorque:{get:function(){return this._maxTorque},set:function(value){System.Diagnostics.Debug.Assert(VelcroPhysics.Utilities.MathUtils.IsValid$1(value)&&value>=0);this._maxTorque=value}},LinearOffset:{get:function(){return this._linearOffset.$clone()},set:function(value){(this._linearOffset.X!==value.X||this._linearOffset.Y!==value.Y)&&(this.WakeBodies(),this._linearOffset=value.$clone())}},AngularOffset:{get:function(){return this._angularOffset},set:function(value){this._angularOffset!==value&&(this.WakeBodies(),this._angularOffset=value)}}},ctors:{init:function(){this._linearError=new Microsoft.Xna.Framework.Vector2;this._linearImpulse=new Microsoft.Xna.Framework.Vector2;this._linearMass=new VelcroPhysics.Shared.Mat22;this._linearOffset=new Microsoft.Xna.Framework.Vector2;this._localCenterA=new Microsoft.Xna.Framework.Vector2;this._localCenterB=new Microsoft.Xna.Framework.Vector2;this._rA=new Microsoft.Xna.Framework.Vector2;this._rB=new Microsoft.Xna.Framework.Vector2},ctor:function(){this.$initialize();VelcroPhysics.Dynamics.Joints.Joint.ctor.call(this);this.JointType=VelcroPhysics.Dynamics.Joints.JointType.Motor},$ctor1:function(bodyA,bodyB,useWorldCoordinates){useWorldCoordinates===void 0&&(useWorldCoordinates=!1);this.$initialize();VelcroPhysics.Dynamics.Joints.Joint.$ctor2.call(this,bodyA,bodyB);this.JointType=VelcroPhysics.Dynamics.Joints.JointType.Motor;var xB=this.BodyB.Position.$clone();this._linearOffset=useWorldCoordinates?this.BodyA.GetLocalPoint(xB.$clone()):xB.$clone();this._maxForce=1;this._maxTorque=1;this.CorrectionFactor=.3;this._angularOffset=this.BodyB.Rotation-this.BodyA.Rotation}},methods:{GetReactionForce:function(invDt){return Microsoft.Xna.Framework.Vector2.op_Multiply$2(invDt,this._linearImpulse.$clone())},GetReactionTorque:function(invDt){return invDt*this._angularImpulse},InitVelocityConstraints:function(data){var P;this._indexA=this.BodyA.IslandIndex;this._indexB=this.BodyB.IslandIndex;this._localCenterA=this.BodyA._sweep.LocalCenter.$clone();this._localCenterB=this.BodyB._sweep.LocalCenter.$clone();this._invMassA=this.BodyA._invMass;this._invMassB=this.BodyB._invMass;this._invIA=this.BodyA._invI;this._invIB=this.BodyB._invI;var cA=data.v.Positions[this._indexA].C.$clone(),aA=data.v.Positions[this._indexA].A,vA=data.v.Velocities[this._indexA].V.$clone(),wA=data.v.Velocities[this._indexA].W,cB=data.v.Positions[this._indexB].C.$clone(),aB=data.v.Positions[this._indexB].A,vB=data.v.Velocities[this._indexB].V.$clone(),wB=data.v.Velocities[this._indexB].W,qA=new VelcroPhysics.Shared.Rot.$ctor1(aA),qB=new VelcroPhysics.Shared.Rot.$ctor1(aB);this._rA=VelcroPhysics.Utilities.MathUtils.Mul$2(qA.$clone(),Microsoft.Xna.Framework.Vector2.op_UnaryNegation(this._localCenterA.$clone()));this._rB=VelcroPhysics.Utilities.MathUtils.Mul$2(qB.$clone(),Microsoft.Xna.Framework.Vector2.op_UnaryNegation(this._localCenterB.$clone()));var mA=this._invMassA,mB=this._invMassB,iA=this._invIA,iB=this._invIB,K=new VelcroPhysics.Shared.Mat22.ctor;K.ex.X=mA+mB+iA*this._rA.Y*this._rA.Y+iB*this._rB.Y*this._rB.Y;K.ex.Y=-iA*this._rA.X*this._rA.Y-iB*this._rB.X*this._rB.Y;K.ey.X=K.ex.Y;K.ey.Y=mA+mB+iA*this._rA.X*this._rA.X+iB*this._rB.X*this._rB.X;this._linearMass=K.Inverse.$clone();this._angularMass=iA+iB;this._angularMass>0&&(this._angularMass=1/this._angularMass);this._linearError=Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(cB.$clone(),this._rB.$clone()),cA.$clone()),this._rA.$clone()),VelcroPhysics.Utilities.MathUtils.Mul$2(qA.$clone(),this._linearOffset.$clone()));this._angularError=aB-aA-this._angularOffset;VelcroPhysics.Settings.EnableWarmstarting?(this._linearImpulse=Microsoft.Xna.Framework.Vector2.op_Multiply$1(this._linearImpulse.$clone(),data.v.Step.dtRatio),this._angularImpulse*=data.v.Step.dtRatio,P=new Microsoft.Xna.Framework.Vector2.$ctor2(this._linearImpulse.X,this._linearImpulse.Y),vA=Microsoft.Xna.Framework.Vector2.op_Subtraction(vA.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mA,P.$clone())),wA-=iA*(VelcroPhysics.Utilities.MathUtils.Cross$3(this._rA.$clone(),P.$clone())+this._angularImpulse),vB=Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mB,P.$clone())),wB+=iB*(VelcroPhysics.Utilities.MathUtils.Cross$3(this._rB.$clone(),P.$clone())+this._angularImpulse)):(this._linearImpulse=Microsoft.Xna.Framework.Vector2.Zero.$clone(),this._angularImpulse=0);data.v.Velocities[this._indexA].V=vA.$clone();data.v.Velocities[this._indexA].W=wA;data.v.Velocities[this._indexB].V=vB.$clone();data.v.Velocities[this._indexB].W=wB},SolveVelocityConstraints:function(data){var vA=data.v.Velocities[this._indexA].V.$clone(),wA=data.v.Velocities[this._indexA].W,vB=data.v.Velocities[this._indexB].V.$clone(),wB=data.v.Velocities[this._indexB].W,mA=this._invMassA,mB=this._invMassB,iA=this._invIA,iB=this._invIB,h=data.v.Step.dt,inv_h=data.v.Step.inv_dt,Cdot=wB-wA+inv_h*this.CorrectionFactor*this._angularError,impulse=-this._angularMass*Cdot,oldImpulse=this._angularImpulse,maxImpulse=h*this._maxTorque,maxImpulse1;this._angularImpulse=VelcroPhysics.Utilities.MathUtils.Clamp$2(this._angularImpulse+impulse,-maxImpulse,maxImpulse);impulse=this._angularImpulse-oldImpulse;wA-=iA*impulse;wB+=iB*impulse;var Cdot1={v:Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(),VelcroPhysics.Utilities.MathUtils.Cross$1(wB,this._rB.$clone())),vA.$clone()),VelcroPhysics.Utilities.MathUtils.Cross$1(wA,this._rA.$clone())),Microsoft.Xna.Framework.Vector2.op_Multiply$2(inv_h*this.CorrectionFactor,this._linearError.$clone()))},impulse1=Microsoft.Xna.Framework.Vector2.op_UnaryNegation(VelcroPhysics.Utilities.MathUtils.Mul$1(Bridge.ref(this,"_linearMass"),Cdot1)),oldImpulse1=this._linearImpulse.$clone();this._linearImpulse=Microsoft.Xna.Framework.Vector2.op_Addition(this._linearImpulse.$clone(),impulse1.$clone());maxImpulse1=h*this._maxForce;this._linearImpulse.LengthSquared()>maxImpulse1*maxImpulse1&&(this._linearImpulse.Normalize(),this._linearImpulse=Microsoft.Xna.Framework.Vector2.op_Multiply$1(this._linearImpulse.$clone(),maxImpulse1));impulse1=Microsoft.Xna.Framework.Vector2.op_Subtraction(this._linearImpulse.$clone(),oldImpulse1.$clone());vA=Microsoft.Xna.Framework.Vector2.op_Subtraction(vA.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mA,impulse1.$clone()));wA-=iA*VelcroPhysics.Utilities.MathUtils.Cross$3(this._rA.$clone(),impulse1.$clone());vB=Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mB,impulse1.$clone()));wB+=iB*VelcroPhysics.Utilities.MathUtils.Cross$3(this._rB.$clone(),impulse1.$clone());data.v.Velocities[this._indexA].V=vA.$clone();data.v.Velocities[this._indexA].W=wA;data.v.Velocities[this._indexB].V=vB.$clone();data.v.Velocities[this._indexB].W=wB},SolvePositionConstraints:function(data){return!0}}});Bridge.define("VelcroPhysics.Dynamics.Joints.PrismaticJoint",{inherits:[VelcroPhysics.Dynamics.Joints.Joint],fields:{_a1:0,_a2:0,_axis:null,_perp:null,_axis1:null,_enableLimit:!1,_enableMotor:!1,_impulse:null,_indexA:0,_indexB:0,_invIA:0,_invIB:0,_invMassA:0,_invMassB:0,_K:null,_limitState:0,_localCenterA:null,_localCenterB:null,_localYAxisA:null,_lowerTranslation:0,_maxMotorForce:0,_motorMass:0,_motorSpeed:0,_s1:0,_s2:0,_upperTranslation:0,LocalAnchorA:null,LocalAnchorB:null,MotorImpulse:0,LocalXAxis:null,ReferenceAngle:0},props:{WorldAnchorA:{get:function(){return this.BodyA.GetWorldPoint(this.LocalAnchorA.$clone())},set:function(value){this.LocalAnchorA=this.BodyA.GetLocalPoint(value.$clone())}},WorldAnchorB:{get:function(){return this.BodyB.GetWorldPoint(this.LocalAnchorB.$clone())},set:function(value){this.LocalAnchorB=this.BodyB.GetLocalPoint(value.$clone())}},JointTranslation:{get:function(){var d=Microsoft.Xna.Framework.Vector2.op_Subtraction(this.BodyB.GetWorldPoint(this.LocalAnchorB.$clone()),this.BodyA.GetWorldPoint(this.LocalAnchorA.$clone())),axis=this.BodyA.GetWorldVector(this.LocalXAxis.$clone());return Microsoft.Xna.Framework.Vector2.Dot(d.$clone(),axis.$clone())}},JointSpeed:{get:function(){var xf1={v:new VelcroPhysics.Shared.Transform},xf2={v:new VelcroPhysics.Shared.Transform};this.BodyA.GetTransform(xf1);this.BodyB.GetTransform(xf2);var r1=VelcroPhysics.Utilities.MathUtils.Mul$3(Bridge.ref(xf1.v,"q"),Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(),this.BodyA.LocalCenter.$clone())),r2=VelcroPhysics.Utilities.MathUtils.Mul$3(Bridge.ref(xf2.v,"q"),Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(),this.BodyB.LocalCenter.$clone())),p1=Microsoft.Xna.Framework.Vector2.op_Addition(this.BodyA._sweep.C.$clone(),r1.$clone()),p2=Microsoft.Xna.Framework.Vector2.op_Addition(this.BodyB._sweep.C.$clone(),r2.$clone()),d=Microsoft.Xna.Framework.Vector2.op_Subtraction(p2.$clone(),p1.$clone()),axis=this.BodyA.GetWorldVector(this.LocalXAxis.$clone()),v1=this.BodyA._linearVelocity.$clone(),v2=this.BodyB._linearVelocity.$clone(),w1=this.BodyA._angularVelocity,w2=this.BodyB._angularVelocity;return Microsoft.Xna.Framework.Vector2.Dot(d.$clone(),VelcroPhysics.Utilities.MathUtils.Cross$1(w1,axis.$clone()))+Microsoft.Xna.Framework.Vector2.Dot(axis.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(v2.$clone(),VelcroPhysics.Utilities.MathUtils.Cross$1(w2,r2.$clone())),v1.$clone()),VelcroPhysics.Utilities.MathUtils.Cross$1(w1,r1.$clone())))}},LimitEnabled:{get:function(){return this._enableLimit},set:function(value){(System.Diagnostics.Debug.Assert$1(this.BodyA.FixedRotation===!1||this.BodyB.FixedRotation===!1,"Warning: limits does currently not work with fixed rotation"),value!==this._enableLimit)&&(this.WakeBodies(),this._enableLimit=value,this._impulse.Z=0)}},LowerLimit:{get:function(){return this._lowerTranslation},set:function(value){value!==this._lowerTranslation&&(this.WakeBodies(),this._lowerTranslation=value,this._impulse.Z=0)}},UpperLimit:{get:function(){return this._upperTranslation},set:function(value){value!==this._upperTranslation&&(this.WakeBodies(),this._upperTranslation=value,this._impulse.Z=0)}},MotorEnabled:{get:function(){return this._enableMotor},set:function(value){value!==this._enableMotor&&(this.WakeBodies(),this._enableMotor=value)}},MotorSpeed:{get:function(){return this._motorSpeed},set:function(value){value!==this._motorSpeed&&(this.WakeBodies(),this._motorSpeed=value)}},MaxMotorForce:{get:function(){return this._maxMotorForce},set:function(value){value!==this._maxMotorForce&&(this.WakeBodies(),this._maxMotorForce=value)}},Axis:{get:function(){return this._axis1.$clone()},set:function(value){this._axis1=value.$clone();this.LocalXAxis=this.BodyA.GetLocalVector(this._axis1.$clone());this.LocalXAxis.Normalize();this._localYAxisA=VelcroPhysics.Utilities.MathUtils.Cross$1(1,this.LocalXAxis.$clone())}}},ctors:{init:function(){this._axis=new Microsoft.Xna.Framework.Vector2;this._perp=new Microsoft.Xna.Framework.Vector2;this._axis1=new Microsoft.Xna.Framework.Vector2;this._impulse=new Microsoft.Xna.Framework.Vector3;this._K=new VelcroPhysics.Shared.Mat33;this._localCenterA=new Microsoft.Xna.Framework.Vector2;this._localCenterB=new Microsoft.Xna.Framework.Vector2;this._localYAxisA=new Microsoft.Xna.Framework.Vector2;this.LocalAnchorA=new Microsoft.Xna.Framework.Vector2;this.LocalAnchorB=new Microsoft.Xna.Framework.Vector2;this.LocalXAxis=new Microsoft.Xna.Framework.Vector2},ctor:function(){this.$initialize();VelcroPhysics.Dynamics.Joints.Joint.ctor.call(this);this.JointType=VelcroPhysics.Dynamics.Joints.JointType.Prismatic},$ctor1:function(bodyA,bodyB,anchorA,anchorB,axis,useWorldCoordinates){useWorldCoordinates===void 0&&(useWorldCoordinates=!1);this.$initialize();VelcroPhysics.Dynamics.Joints.Joint.$ctor2.call(this,bodyA,bodyB);this.Initialize(anchorA.$clone(),anchorB.$clone(),axis.$clone(),useWorldCoordinates)},$ctor2:function(bodyA,bodyB,anchor,axis,useWorldCoordinates){useWorldCoordinates===void 0&&(useWorldCoordinates=!1);this.$initialize();VelcroPhysics.Dynamics.Joints.Joint.$ctor2.call(this,bodyA,bodyB);this.Initialize(anchor.$clone(),anchor.$clone(),axis.$clone(),useWorldCoordinates)}},methods:{Initialize:function(localAnchorA,localAnchorB,axis,useWorldCoordinates){this.JointType=VelcroPhysics.Dynamics.Joints.JointType.Prismatic;useWorldCoordinates?(this.LocalAnchorA=this.BodyA.GetLocalPoint(localAnchorA.$clone()),this.LocalAnchorB=this.BodyB.GetLocalPoint(localAnchorB.$clone())):(this.LocalAnchorA=localAnchorA.$clone(),this.LocalAnchorB=localAnchorB.$clone());this.Axis=axis.$clone();this.ReferenceAngle=this.BodyB.Rotation-this.BodyA.Rotation;this._limitState=VelcroPhysics.Dynamics.Joints.LimitState.Inactive},SetLimits:function(lower,upper){(upper!==this._upperTranslation||lower!==this._lowerTranslation)&&(this.WakeBodies(),this._upperTranslation=upper,this._lowerTranslation=lower,this._impulse.Z=0)},GetMotorForce:function(invDt){return invDt*this.MotorImpulse},GetReactionForce:function(invDt){return Microsoft.Xna.Framework.Vector2.op_Multiply$2(invDt,Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._impulse.X,this._perp.$clone()),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.MotorImpulse+this._impulse.Z,this._axis.$clone())))},GetReactionTorque:function(invDt){return invDt*this._impulse.Y},InitVelocityConstraints:function(data){var k23,k33,jointTranslation;this._indexA=this.BodyA.IslandIndex;this._indexB=this.BodyB.IslandIndex;this._localCenterA=this.BodyA._sweep.LocalCenter.$clone();this._localCenterB=this.BodyB._sweep.LocalCenter.$clone();this._invMassA=this.BodyA._invMass;this._invMassB=this.BodyB._invMass;this._invIA=this.BodyA._invI;this._invIB=this.BodyB._invI;var cA=data.v.Positions[this._indexA].C.$clone(),aA=data.v.Positions[this._indexA].A,vA=data.v.Velocities[this._indexA].V.$clone(),wA=data.v.Velocities[this._indexA].W,cB=data.v.Positions[this._indexB].C.$clone(),aB=data.v.Positions[this._indexB].A,vB=data.v.Velocities[this._indexB].V.$clone(),wB=data.v.Velocities[this._indexB].W,qA=new VelcroPhysics.Shared.Rot.$ctor1(aA),qB=new VelcroPhysics.Shared.Rot.$ctor1(aB),rA=VelcroPhysics.Utilities.MathUtils.Mul$2(qA.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(),this._localCenterA.$clone())),rB=VelcroPhysics.Utilities.MathUtils.Mul$2(qB.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(),this._localCenterB.$clone())),d=Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Subtraction(cB.$clone(),cA.$clone()),rB.$clone()),rA.$clone()),mA=this._invMassA,mB=this._invMassB,iA=this._invIA,iB=this._invIB;this._axis=VelcroPhysics.Utilities.MathUtils.Mul$2(qA.$clone(),this.LocalXAxis.$clone());this._a1=VelcroPhysics.Utilities.MathUtils.Cross$3(Microsoft.Xna.Framework.Vector2.op_Addition(d.$clone(),rA.$clone()),this._axis.$clone());this._a2=VelcroPhysics.Utilities.MathUtils.Cross$3(rB.$clone(),this._axis.$clone());this._motorMass=mA+mB+iA*this._a1*this._a1+iB*this._a2*this._a2;this._motorMass>0&&(this._motorMass=1/this._motorMass);this._perp=VelcroPhysics.Utilities.MathUtils.Mul$2(qA.$clone(),this._localYAxisA.$clone());this._s1=VelcroPhysics.Utilities.MathUtils.Cross$3(Microsoft.Xna.Framework.Vector2.op_Addition(d.$clone(),rA.$clone()),this._perp.$clone());this._s2=VelcroPhysics.Utilities.MathUtils.Cross$3(rB.$clone(),this._perp.$clone());var k11=mA+mB+iA*this._s1*this._s1+iB*this._s2*this._s2,k12=iA*this._s1+iB*this._s2,k13=iA*this._s1*this._a1+iB*this._s2*this._a2,k22=iA+iB;if(k22===0&&(k22=1),k23=iA*this._a1+iB*this._a2,k33=mA+mB+iA*this._a1*this._a1+iB*this._a2*this._a2,this._K.ex=new Microsoft.Xna.Framework.Vector3.$ctor3(k11,k12,k13),this._K.ey=new Microsoft.Xna.Framework.Vector3.$ctor3(k12,k22,k23),this._K.ez=new Microsoft.Xna.Framework.Vector3.$ctor3(k13,k23,k33),this._enableLimit?(jointTranslation=Microsoft.Xna.Framework.Vector2.Dot(this._axis.$clone(),d.$clone()),Math.abs(this._upperTranslation-this._lowerTranslation)<.01?this._limitState=VelcroPhysics.Dynamics.Joints.LimitState.Equal:jointTranslation<=this._lowerTranslation?this._limitState!==VelcroPhysics.Dynamics.Joints.LimitState.AtLower&&(this._limitState=VelcroPhysics.Dynamics.Joints.LimitState.AtLower,this._impulse.Z=0):jointTranslation>=this._upperTranslation?this._limitState!==VelcroPhysics.Dynamics.Joints.LimitState.AtUpper&&(this._limitState=VelcroPhysics.Dynamics.Joints.LimitState.AtUpper,this._impulse.Z=0):(this._limitState=VelcroPhysics.Dynamics.Joints.LimitState.Inactive,this._impulse.Z=0)):(this._limitState=VelcroPhysics.Dynamics.Joints.LimitState.Inactive,this._impulse.Z=0),this._enableMotor===!1&&(this.MotorImpulse=0),VelcroPhysics.Settings.EnableWarmstarting){this._impulse=Microsoft.Xna.Framework.Vector3.op_Multiply$1(this._impulse.$clone(),data.v.Step.dtRatio);this.MotorImpulse*=data.v.Step.dtRatio;var P=Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._impulse.X,this._perp.$clone()),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.MotorImpulse+this._impulse.Z,this._axis.$clone())),LA=this._impulse.X*this._s1+this._impulse.Y+(this.MotorImpulse+this._impulse.Z)*this._a1,LB=this._impulse.X*this._s2+this._impulse.Y+(this.MotorImpulse+this._impulse.Z)*this._a2;vA=Microsoft.Xna.Framework.Vector2.op_Subtraction(vA.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mA,P.$clone()));wA-=iA*LA;vB=Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mB,P.$clone()));wB+=iB*LB}else this._impulse=Microsoft.Xna.Framework.Vector3.Zero.$clone(),this.MotorImpulse=0;data.v.Velocities[this._indexA].V=vA.$clone();data.v.Velocities[this._indexA].W=wA;data.v.Velocities[this._indexB].V=vB.$clone();data.v.Velocities[this._indexB].W=wB},SolveVelocityConstraints:function(data){var vA=data.v.Velocities[this._indexA].V.$clone(),wA=data.v.Velocities[this._indexA].W,vB=data.v.Velocities[this._indexB].V.$clone(),wB=data.v.Velocities[this._indexB].W,mA=this._invMassA,mB=this._invMassB,iA=this._invIA,iB=this._invIB,Cdot1,Cdot2,b,f2r,df1;if(this._enableMotor&&this._limitState!==VelcroPhysics.Dynamics.Joints.LimitState.Equal){var Cdot=Microsoft.Xna.Framework.Vector2.Dot(this._axis.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(vB.$clone(),vA.$clone()))+this._a2*wB-this._a1*wA,impulse=this._motorMass*(this._motorSpeed-Cdot),oldImpulse=this.MotorImpulse,maxImpulse=data.v.Step.dt*this._maxMotorForce;this.MotorImpulse=VelcroPhysics.Utilities.MathUtils.Clamp$2(this.MotorImpulse+impulse,-maxImpulse,maxImpulse);impulse=this.MotorImpulse-oldImpulse;var P=Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse,this._axis.$clone()),LA=impulse*this._a1,LB=impulse*this._a2;vA=Microsoft.Xna.Framework.Vector2.op_Subtraction(vA.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mA,P.$clone()));wA-=iA*LA;vB=Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mB,P.$clone()));wB+=iB*LB}if(Cdot1=new Microsoft.Xna.Framework.Vector2.ctor,Cdot1.X=Microsoft.Xna.Framework.Vector2.Dot(this._perp.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(vB.$clone(),vA.$clone()))+this._s2*wB-this._s1*wA,Cdot1.Y=wB-wA,this._enableLimit&&this._limitState!==VelcroPhysics.Dynamics.Joints.LimitState.Inactive){Cdot2=Microsoft.Xna.Framework.Vector2.Dot(this._axis.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(vB.$clone(),vA.$clone()))+this._a2*wB-this._a1*wA;var Cdot3=new Microsoft.Xna.Framework.Vector3.$ctor3(Cdot1.X,Cdot1.Y,Cdot2),f1=this._impulse.$clone(),df=this._K.Solve33(Microsoft.Xna.Framework.Vector3.op_UnaryNegation(Cdot3.$clone()));this._impulse=Microsoft.Xna.Framework.Vector3.op_Addition(this._impulse.$clone(),df.$clone());this._limitState===VelcroPhysics.Dynamics.Joints.LimitState.AtLower?this._impulse.Z=Math.max(this._impulse.Z,0):this._limitState===VelcroPhysics.Dynamics.Joints.LimitState.AtUpper&&(this._impulse.Z=Math.min(this._impulse.Z,0));b=Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_UnaryNegation(Cdot1.$clone()),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._impulse.Z-f1.Z,new Microsoft.Xna.Framework.Vector2.$ctor2(this._K.ez.X,this._K.ez.Y)));f2r=Microsoft.Xna.Framework.Vector2.op_Addition(this._K.Solve22(b.$clone()),new Microsoft.Xna.Framework.Vector2.$ctor2(f1.X,f1.Y));this._impulse.X=f2r.X;this._impulse.Y=f2r.Y;df=Microsoft.Xna.Framework.Vector3.op_Subtraction(this._impulse.$clone(),f1.$clone());var P1=Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(df.X,this._perp.$clone()),Microsoft.Xna.Framework.Vector2.op_Multiply$2(df.Z,this._axis.$clone())),LA1=df.X*this._s1+df.Y+df.Z*this._a1,LB1=df.X*this._s2+df.Y+df.Z*this._a2;vA=Microsoft.Xna.Framework.Vector2.op_Subtraction(vA.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mA,P1.$clone()));wA-=iA*LA1;vB=Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mB,P1.$clone()));wB+=iB*LB1}else{df1=this._K.Solve22(Microsoft.Xna.Framework.Vector2.op_UnaryNegation(Cdot1.$clone()));this._impulse.X+=df1.X;this._impulse.Y+=df1.Y;var P2=Microsoft.Xna.Framework.Vector2.op_Multiply$2(df1.X,this._perp.$clone()),LA2=df1.X*this._s1+df1.Y,LB2=df1.X*this._s2+df1.Y;vA=Microsoft.Xna.Framework.Vector2.op_Subtraction(vA.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mA,P2.$clone()));wA-=iA*LA2;vB=Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mB,P2.$clone()));wB+=iB*LB2}data.v.Velocities[this._indexA].V=vA.$clone();data.v.Velocities[this._indexA].W=wA;data.v.Velocities[this._indexB].V=vB.$clone();data.v.Velocities[this._indexB].W=wB},SolvePositionConstraints:function(data){var cA=data.v.Positions[this._indexA].C.$clone(),aA=data.v.Positions[this._indexA].A,cB=data.v.Positions[this._indexB].C.$clone(),aB=data.v.Positions[this._indexB].A,qA=new VelcroPhysics.Shared.Rot.$ctor1(aA),qB=new VelcroPhysics.Shared.Rot.$ctor1(aB),mA=this._invMassA,mB=this._invMassB,iA=this._invIA,iB=this._invIB,rA=VelcroPhysics.Utilities.MathUtils.Mul$2(qA.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(),this._localCenterA.$clone())),rB=VelcroPhysics.Utilities.MathUtils.Mul$2(qB.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(),this._localCenterB.$clone())),d=Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(cB.$clone(),rB.$clone()),cA.$clone()),rA.$clone()),axis=VelcroPhysics.Utilities.MathUtils.Mul$2(qA.$clone(),this.LocalXAxis.$clone()),a1=VelcroPhysics.Utilities.MathUtils.Cross$3(Microsoft.Xna.Framework.Vector2.op_Addition(d.$clone(),rA.$clone()),axis.$clone()),a2=VelcroPhysics.Utilities.MathUtils.Cross$3(rB.$clone(),axis.$clone()),perp=VelcroPhysics.Utilities.MathUtils.Mul$2(qA.$clone(),this._localYAxisA.$clone()),s1=VelcroPhysics.Utilities.MathUtils.Cross$3(Microsoft.Xna.Framework.Vector2.op_Addition(d.$clone(),rA.$clone()),perp.$clone()),s2=VelcroPhysics.Utilities.MathUtils.Cross$3(rB.$clone(),perp.$clone()),impulse=new Microsoft.Xna.Framework.Vector3,C1=new Microsoft.Xna.Framework.Vector2.ctor,translation,C,K1,impulse1;C1.X=Microsoft.Xna.Framework.Vector2.Dot(perp.$clone(),d.$clone());C1.Y=aB-aA-this.ReferenceAngle;var linearError=Math.abs(C1.X),angularError=Math.abs(C1.Y),active=!1,C2=0;if(this._enableLimit&&(translation=Microsoft.Xna.Framework.Vector2.Dot(axis.$clone(),d.$clone()),Math.abs(this._upperTranslation-this._lowerTranslation)<.01?(C2=VelcroPhysics.Utilities.MathUtils.Clamp$2(translation,-.2,VelcroPhysics.Settings.MaxLinearCorrection),linearError=Math.max(linearError,Math.abs(translation)),active=!0):translation<=this._lowerTranslation?(C2=VelcroPhysics.Utilities.MathUtils.Clamp$2(translation-this._lowerTranslation+VelcroPhysics.Settings.LinearSlop,-.2,0),linearError=Math.max(linearError,this._lowerTranslation-translation),active=!0):translation>=this._upperTranslation&&(C2=VelcroPhysics.Utilities.MathUtils.Clamp$2(translation-this._upperTranslation-VelcroPhysics.Settings.LinearSlop,0,VelcroPhysics.Settings.MaxLinearCorrection),linearError=Math.max(linearError,translation-this._upperTranslation),active=!0)),active){var k11=mA+mB+iA*s1*s1+iB*s2*s2,k12=iA*s1+iB*s2,k13=iA*s1*a1+iB*s2*a2,k22=iA+iB;k22===0&&(k22=1);var k23=iA*a1+iB*a2,k33=mA+mB+iA*a1*a1+iB*a2*a2,K=new VelcroPhysics.Shared.Mat33.ctor;K.ex=new Microsoft.Xna.Framework.Vector3.$ctor3(k11,k12,k13);K.ey=new Microsoft.Xna.Framework.Vector3.$ctor3(k12,k22,k23);K.ez=new Microsoft.Xna.Framework.Vector3.$ctor3(k13,k23,k33);C=new Microsoft.Xna.Framework.Vector3.ctor;C.X=C1.X;C.Y=C1.Y;C.Z=C2;impulse=K.Solve33(Microsoft.Xna.Framework.Vector3.op_UnaryNegation(C.$clone()))}else{var k111=mA+mB+iA*s1*s1+iB*s2*s2,k121=iA*s1+iB*s2,k221=iA+iB;k221===0&&(k221=1);K1=new VelcroPhysics.Shared.Mat22.ctor;K1.ex=new Microsoft.Xna.Framework.Vector2.$ctor2(k111,k121);K1.ey=new Microsoft.Xna.Framework.Vector2.$ctor2(k121,k221);impulse1=K1.Solve(Microsoft.Xna.Framework.Vector2.op_UnaryNegation(C1.$clone()));impulse=new Microsoft.Xna.Framework.Vector3.ctor;impulse.X=impulse1.X;impulse.Y=impulse1.Y;impulse.Z=0}var P=Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse.X,perp.$clone()),Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse.Z,axis.$clone())),LA=impulse.X*s1+impulse.Y+impulse.Z*a1,LB=impulse.X*s2+impulse.Y+impulse.Z*a2;return cA=Microsoft.Xna.Framework.Vector2.op_Subtraction(cA.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mA,P.$clone())),aA-=iA*LA,cB=Microsoft.Xna.Framework.Vector2.op_Addition(cB.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mB,P.$clone())),aB+=iB*LB,data.v.Positions[this._indexA].C=cA.$clone(),data.v.Positions[this._indexA].A=aA,data.v.Positions[this._indexB].C=cB.$clone(),data.v.Positions[this._indexB].A=aB,linearError<=VelcroPhysics.Settings.LinearSlop&&angularError<=VelcroPhysics.Settings.AngularSlop}}});Bridge.define("VelcroPhysics.Dynamics.Joints.PulleyJoint",{inherits:[VelcroPhysics.Dynamics.Joints.Joint],fields:{_impulse:0,_indexA:0,_indexB:0,_invIA:0,_invIB:0,_invMassA:0,_invMassB:0,_localCenterA:null,_localCenterB:null,_mass:0,_rA:null,_rB:null,_uA:null,_uB:null,LocalAnchorA:null,LocalAnchorB:null,WorldAnchorA:null,WorldAnchorB:null,LengthA:0,LengthB:0,Ratio:0,Constant:0},props:{CurrentLengthA:{get:function(){var p=this.BodyA.GetWorldPoint(this.LocalAnchorA.$clone()),s=this.WorldAnchorA.$clone(),d=Microsoft.Xna.Framework.Vector2.op_Subtraction(p.$clone(),s.$clone());return d.Length()}},CurrentLengthB:{get:function(){var p=this.BodyB.GetWorldPoint(this.LocalAnchorB.$clone()),s=this.WorldAnchorB.$clone(),d=Microsoft.Xna.Framework.Vector2.op_Subtraction(p.$clone(),s.$clone());return d.Length()}}},ctors:{init:function(){this._localCenterA=new Microsoft.Xna.Framework.Vector2;this._localCenterB=new Microsoft.Xna.Framework.Vector2;this._rA=new Microsoft.Xna.Framework.Vector2;this._rB=new Microsoft.Xna.Framework.Vector2;this._uA=new Microsoft.Xna.Framework.Vector2;this._uB=new Microsoft.Xna.Framework.Vector2;this.LocalAnchorA=new Microsoft.Xna.Framework.Vector2;this.LocalAnchorB=new Microsoft.Xna.Framework.Vector2;this.WorldAnchorA=new Microsoft.Xna.Framework.Vector2;this.WorldAnchorB=new Microsoft.Xna.Framework.Vector2},ctor:function(){this.$initialize();VelcroPhysics.Dynamics.Joints.Joint.ctor.call(this);this.JointType=VelcroPhysics.Dynamics.Joints.JointType.Pulley},$ctor1:function(bodyA,bodyB,anchorA,anchorB,worldAnchorA,worldAnchorB,ratio,useWorldCoordinates){var dA,dB,dA1,dB1;useWorldCoordinates===void 0&&(useWorldCoordinates=!1);this.$initialize();VelcroPhysics.Dynamics.Joints.Joint.$ctor2.call(this,bodyA,bodyB);this.JointType=VelcroPhysics.Dynamics.Joints.JointType.Pulley;this.WorldAnchorA=worldAnchorA.$clone();this.WorldAnchorB=worldAnchorB.$clone();useWorldCoordinates?(this.LocalAnchorA=this.BodyA.GetLocalPoint(anchorA.$clone()),this.LocalAnchorB=this.BodyB.GetLocalPoint(anchorB.$clone()),dA=Microsoft.Xna.Framework.Vector2.op_Subtraction(anchorA.$clone(),worldAnchorA.$clone()),this.LengthA=dA.Length(),dB=Microsoft.Xna.Framework.Vector2.op_Subtraction(anchorB.$clone(),worldAnchorB.$clone()),this.LengthB=dB.Length()):(this.LocalAnchorA=anchorA.$clone(),this.LocalAnchorB=anchorB.$clone(),dA1=Microsoft.Xna.Framework.Vector2.op_Subtraction(anchorA.$clone(),this.BodyA.GetLocalPoint(worldAnchorA.$clone())),this.LengthA=dA1.Length(),dB1=Microsoft.Xna.Framework.Vector2.op_Subtraction(anchorB.$clone(),this.BodyB.GetLocalPoint(worldAnchorB.$clone())),this.LengthB=dB1.Length());System.Diagnostics.Debug.Assert(ratio!==0);System.Diagnostics.Debug.Assert(ratio>VelcroPhysics.Settings.Epsilon);this.Ratio=ratio;this.Constant=this.LengthA+ratio*this.LengthB;this._impulse=0}},methods:{GetReactionForce:function(invDt){var P=Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._impulse,this._uB.$clone());return Microsoft.Xna.Framework.Vector2.op_Multiply$2(invDt,P.$clone())},GetReactionTorque:function(invDt){return 0},InitVelocityConstraints:function(data){var lengthA,lengthB,PA,PB;this._indexA=this.BodyA.IslandIndex;this._indexB=this.BodyB.IslandIndex;this._localCenterA=this.BodyA._sweep.LocalCenter.$clone();this._localCenterB=this.BodyB._sweep.LocalCenter.$clone();this._invMassA=this.BodyA._invMass;this._invMassB=this.BodyB._invMass;this._invIA=this.BodyA._invI;this._invIB=this.BodyB._invI;var cA=data.v.Positions[this._indexA].C.$clone(),aA=data.v.Positions[this._indexA].A,vA=data.v.Velocities[this._indexA].V.$clone(),wA=data.v.Velocities[this._indexA].W,cB=data.v.Positions[this._indexB].C.$clone(),aB=data.v.Positions[this._indexB].A,vB=data.v.Velocities[this._indexB].V.$clone(),wB=data.v.Velocities[this._indexB].W,qA=new VelcroPhysics.Shared.Rot.$ctor1(aA),qB=new VelcroPhysics.Shared.Rot.$ctor1(aB);this._rA=VelcroPhysics.Utilities.MathUtils.Mul$2(qA.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(),this._localCenterA.$clone()));this._rB=VelcroPhysics.Utilities.MathUtils.Mul$2(qB.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(),this._localCenterB.$clone()));this._uA=Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(cA.$clone(),this._rA.$clone()),this.WorldAnchorA.$clone());this._uB=Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(cB.$clone(),this._rB.$clone()),this.WorldAnchorB.$clone());lengthA=this._uA.Length();lengthB=this._uB.Length();this._uA=lengthA>.049999997?Microsoft.Xna.Framework.Vector2.op_Multiply$1(this._uA.$clone(),1/lengthA):Microsoft.Xna.Framework.Vector2.Zero.$clone();this._uB=lengthB>.049999997?Microsoft.Xna.Framework.Vector2.op_Multiply$1(this._uB.$clone(),1/lengthB):Microsoft.Xna.Framework.Vector2.Zero.$clone();var ruA=VelcroPhysics.Utilities.MathUtils.Cross$3(this._rA.$clone(),this._uA.$clone()),ruB=VelcroPhysics.Utilities.MathUtils.Cross$3(this._rB.$clone(),this._uB.$clone()),mA=this._invMassA+this._invIA*ruA*ruA,mB=this._invMassB+this._invIB*ruB*ruB;this._mass=mA+this.Ratio*this.Ratio*mB;this._mass>0&&(this._mass=1/this._mass);VelcroPhysics.Settings.EnableWarmstarting?(this._impulse*=data.v.Step.dtRatio,PA=Microsoft.Xna.Framework.Vector2.op_Multiply$2(-this._impulse,this._uA.$clone()),PB=Microsoft.Xna.Framework.Vector2.op_Multiply$2(-this.Ratio*this._impulse,this._uB.$clone()),vA=Microsoft.Xna.Framework.Vector2.op_Addition(vA.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._invMassA,PA.$clone())),wA+=this._invIA*VelcroPhysics.Utilities.MathUtils.Cross$3(this._rA.$clone(),PA.$clone()),vB=Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._invMassB,PB.$clone())),wB+=this._invIB*VelcroPhysics.Utilities.MathUtils.Cross$3(this._rB.$clone(),PB.$clone())):this._impulse=0;data.v.Velocities[this._indexA].V=vA.$clone();data.v.Velocities[this._indexA].W=wA;data.v.Velocities[this._indexB].V=vB.$clone();data.v.Velocities[this._indexB].W=wB},SolveVelocityConstraints:function(data){var vA=data.v.Velocities[this._indexA].V.$clone(),wA=data.v.Velocities[this._indexA].W,vB=data.v.Velocities[this._indexB].V.$clone(),wB=data.v.Velocities[this._indexB].W,vpA=Microsoft.Xna.Framework.Vector2.op_Addition(vA.$clone(),VelcroPhysics.Utilities.MathUtils.Cross$1(wA,this._rA.$clone())),vpB=Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(),VelcroPhysics.Utilities.MathUtils.Cross$1(wB,this._rB.$clone())),Cdot=-Microsoft.Xna.Framework.Vector2.Dot(this._uA.$clone(),vpA.$clone())-this.Ratio*Microsoft.Xna.Framework.Vector2.Dot(this._uB.$clone(),vpB.$clone()),impulse=-this._mass*Cdot,PA,PB;this._impulse+=impulse;PA=Microsoft.Xna.Framework.Vector2.op_Multiply$2(-impulse,this._uA.$clone());PB=Microsoft.Xna.Framework.Vector2.op_Multiply$2(-this.Ratio*impulse,this._uB.$clone());vA=Microsoft.Xna.Framework.Vector2.op_Addition(vA.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._invMassA,PA.$clone()));wA+=this._invIA*VelcroPhysics.Utilities.MathUtils.Cross$3(this._rA.$clone(),PA.$clone());vB=Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._invMassB,PB.$clone()));wB+=this._invIB*VelcroPhysics.Utilities.MathUtils.Cross$3(this._rB.$clone(),PB.$clone());data.v.Velocities[this._indexA].V=vA.$clone();data.v.Velocities[this._indexA].W=wA;data.v.Velocities[this._indexB].V=vB.$clone();data.v.Velocities[this._indexB].W=wB},SolvePositionConstraints:function(data){var cA=data.v.Positions[this._indexA].C.$clone(),aA=data.v.Positions[this._indexA].A,cB=data.v.Positions[this._indexB].C.$clone(),aB=data.v.Positions[this._indexB].A,qA=new VelcroPhysics.Shared.Rot.$ctor1(aA),qB=new VelcroPhysics.Shared.Rot.$ctor1(aB),rA=VelcroPhysics.Utilities.MathUtils.Mul$2(qA.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(),this._localCenterA.$clone())),rB=VelcroPhysics.Utilities.MathUtils.Mul$2(qB.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(),this._localCenterB.$clone())),uA=Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(cA.$clone(),rA.$clone()),this.WorldAnchorA.$clone()),uB=Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(cB.$clone(),rB.$clone()),this.WorldAnchorB.$clone()),lengthA=uA.Length(),lengthB=uB.Length();uA=lengthA>.049999997?Microsoft.Xna.Framework.Vector2.op_Multiply$1(uA.$clone(),1/lengthA):Microsoft.Xna.Framework.Vector2.Zero.$clone();uB=lengthB>.049999997?Microsoft.Xna.Framework.Vector2.op_Multiply$1(uB.$clone(),1/lengthB):Microsoft.Xna.Framework.Vector2.Zero.$clone();var ruA=VelcroPhysics.Utilities.MathUtils.Cross$3(rA.$clone(),uA.$clone()),ruB=VelcroPhysics.Utilities.MathUtils.Cross$3(rB.$clone(),uB.$clone()),mA=this._invMassA+this._invIA*ruA*ruA,mB=this._invMassB+this._invIB*ruB*ruB,mass=mA+this.Ratio*this.Ratio*mB;mass>0&&(mass=1/mass);var C=this.Constant-lengthA-this.Ratio*lengthB,linearError=Math.abs(C),impulse=-mass*C,PA=Microsoft.Xna.Framework.Vector2.op_Multiply$2(-impulse,uA.$clone()),PB=Microsoft.Xna.Framework.Vector2.op_Multiply$2(-this.Ratio*impulse,uB.$clone());return cA=Microsoft.Xna.Framework.Vector2.op_Addition(cA.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._invMassA,PA.$clone())),aA+=this._invIA*VelcroPhysics.Utilities.MathUtils.Cross$3(rA.$clone(),PA.$clone()),cB=Microsoft.Xna.Framework.Vector2.op_Addition(cB.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._invMassB,PB.$clone())),aB+=this._invIB*VelcroPhysics.Utilities.MathUtils.Cross$3(rB.$clone(),PB.$clone()),data.v.Positions[this._indexA].C=cA.$clone(),data.v.Positions[this._indexA].A=aA,data.v.Positions[this._indexB].C=cB.$clone(),data.v.Positions[this._indexB].A=aB,linearError<VelcroPhysics.Settings.LinearSlop}}});Bridge.define("VelcroPhysics.Dynamics.Joints.RevoluteJoint",{inherits:[VelcroPhysics.Dynamics.Joints.Joint],fields:{_enableLimit:!1,_enableMotor:!1,_impulse:null,_indexA:0,_indexB:0,_invIA:0,_invIB:0,_invMassA:0,_invMassB:0,_limitState:0,_localCenterA:null,_localCenterB:null,_lowerAngle:0,_mass:null,_maxMotorTorque:0,_motorImpulse:0,_motorMass:0,_motorSpeed:0,_rA:null,_rB:null,_referenceAngle:0,_upperAngle:0,LocalAnchorA:null,LocalAnchorB:null},props:{WorldAnchorA:{get:function(){return this.BodyA.GetWorldPoint(this.LocalAnchorA.$clone())},set:function(value){this.LocalAnchorA=this.BodyA.GetLocalPoint(value.$clone())}},WorldAnchorB:{get:function(){return this.BodyB.GetWorldPoint(this.LocalAnchorB.$clone())},set:function(value){this.LocalAnchorB=this.BodyB.GetLocalPoint(value.$clone())}},ReferenceAngle:{get:function(){return this._referenceAngle},set:function(value){this.WakeBodies();this._referenceAngle=value}},JointAngle:{get:function(){return this.BodyB._sweep.A-this.BodyA._sweep.A-this.ReferenceAngle}},JointSpeed:{get:function(){return this.BodyB._angularVelocity-this.BodyA._angularVelocity}},LimitEnabled:{get:function(){return this._enableLimit},set:function(value){this._enableLimit!==value&&(this.WakeBodies(),this._enableLimit=value,this._impulse.Z=0)}},LowerLimit:{get:function(){return this._lowerAngle},set:function(value){this._lowerAngle!==value&&(this.WakeBodies(),this._lowerAngle=value,this._impulse.Z=0)}},UpperLimit:{get:function(){return this._upperAngle},set:function(value){this._upperAngle!==value&&(this.WakeBodies(),this._upperAngle=value,this._impulse.Z=0)}},MotorEnabled:{get:function(){return this._enableMotor},set:function(value){value!==this._enableMotor&&(this.WakeBodies(),this._enableMotor=value)}},MotorSpeed:{get:function(){return this._motorSpeed},set:function(value){value!==this._motorSpeed&&(this.WakeBodies(),this._motorSpeed=value)}},MaxMotorTorque:{get:function(){return this._maxMotorTorque},set:function(value){value!==this._maxMotorTorque&&(this.WakeBodies(),this._maxMotorTorque=value)}},MotorImpulse:{get:function(){return this._motorImpulse},set:function(value){value!==this._motorImpulse&&(this.WakeBodies(),this._motorImpulse=value)}}},ctors:{init:function(){this._impulse=new Microsoft.Xna.Framework.Vector3;this._localCenterA=new Microsoft.Xna.Framework.Vector2;this._localCenterB=new Microsoft.Xna.Framework.Vector2;this._mass=new VelcroPhysics.Shared.Mat33;this._rA=new Microsoft.Xna.Framework.Vector2;this._rB=new Microsoft.Xna.Framework.Vector2;this.LocalAnchorA=new Microsoft.Xna.Framework.Vector2;this.LocalAnchorB=new Microsoft.Xna.Framework.Vector2},ctor:function(){this.$initialize();VelcroPhysics.Dynamics.Joints.Joint.ctor.call(this);this.JointType=VelcroPhysics.Dynamics.Joints.JointType.Revolute},$ctor1:function(bodyA,bodyB,anchorA,anchorB,useWorldCoordinates){useWorldCoordinates===void 0&&(useWorldCoordinates=!1);this.$initialize();VelcroPhysics.Dynamics.Joints.Joint.$ctor2.call(this,bodyA,bodyB);this.JointType=VelcroPhysics.Dynamics.Joints.JointType.Revolute;useWorldCoordinates?(this.LocalAnchorA=this.BodyA.GetLocalPoint(anchorA.$clone()),this.LocalAnchorB=this.BodyB.GetLocalPoint(anchorB.$clone())):(this.LocalAnchorA=anchorA.$clone(),this.LocalAnchorB=anchorB.$clone());this.ReferenceAngle=this.BodyB.Rotation-this.BodyA.Rotation;this._impulse=Microsoft.Xna.Framework.Vector3.Zero.$clone();this._limitState=VelcroPhysics.Dynamics.Joints.LimitState.Inactive},$ctor2:function(bodyA,bodyB,anchor,useWorldCoordinates){useWorldCoordinates===void 0&&(useWorldCoordinates=!1);VelcroPhysics.Dynamics.Joints.RevoluteJoint.$ctor1.call(this,bodyA,bodyB,anchor,anchor,useWorldCoordinates)}},methods:{SetLimits:function(lower,upper){(lower!==this._lowerAngle||upper!==this._upperAngle)&&(this.WakeBodies(),this._upperAngle=upper,this._lowerAngle=lower,this._impulse.Z=0)},GetMotorTorque:function(invDt){return invDt*this._motorImpulse},GetReactionForce:function(invDt){var p=new Microsoft.Xna.Framework.Vector2.$ctor2(this._impulse.X,this._impulse.Y);return Microsoft.Xna.Framework.Vector2.op_Multiply$2(invDt,p.$clone())},GetReactionTorque:function(invDt){return invDt*this._impulse.Z},InitVelocityConstraints:function(data){var jointAngle,P;this._indexA=this.BodyA.IslandIndex;this._indexB=this.BodyB.IslandIndex;this._localCenterA=this.BodyA._sweep.LocalCenter.$clone();this._localCenterB=this.BodyB._sweep.LocalCenter.$clone();this._invMassA=this.BodyA._invMass;this._invMassB=this.BodyB._invMass;this._invIA=this.BodyA._invI;this._invIB=this.BodyB._invI;var aA=data.v.Positions[this._indexA].A,vA=data.v.Velocities[this._indexA].V.$clone(),wA=data.v.Velocities[this._indexA].W,aB=data.v.Positions[this._indexB].A,vB=data.v.Velocities[this._indexB].V.$clone(),wB=data.v.Velocities[this._indexB].W,qA=new VelcroPhysics.Shared.Rot.$ctor1(aA),qB=new VelcroPhysics.Shared.Rot.$ctor1(aB);this._rA=VelcroPhysics.Utilities.MathUtils.Mul$2(qA.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(),this._localCenterA.$clone()));this._rB=VelcroPhysics.Utilities.MathUtils.Mul$2(qB.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(),this._localCenterB.$clone()));var mA=this._invMassA,mB=this._invMassB,iA=this._invIA,iB=this._invIB,fixedRotation=iA+iB===0;this._mass.ex.X=mA+mB+this._rA.Y*this._rA.Y*iA+this._rB.Y*this._rB.Y*iB;this._mass.ey.X=-this._rA.Y*this._rA.X*iA-this._rB.Y*this._rB.X*iB;this._mass.ez.X=-this._rA.Y*iA-this._rB.Y*iB;this._mass.ex.Y=this._mass.ey.X;this._mass.ey.Y=mA+mB+this._rA.X*this._rA.X*iA+this._rB.X*this._rB.X*iB;this._mass.ez.Y=this._rA.X*iA+this._rB.X*iB;this._mass.ex.Z=this._mass.ez.X;this._mass.ey.Z=this._mass.ez.Y;this._mass.ez.Z=iA+iB;this._motorMass=iA+iB;this._motorMass>0&&(this._motorMass=1/this._motorMass);(this._enableMotor===!1||fixedRotation)&&(this._motorImpulse=0);this._enableLimit&&fixedRotation===!1?(jointAngle=aB-aA-this.ReferenceAngle,Math.abs(this._upperAngle-this._lowerAngle)<.06981318?this._limitState=VelcroPhysics.Dynamics.Joints.LimitState.Equal:jointAngle<=this._lowerAngle?(this._limitState!==VelcroPhysics.Dynamics.Joints.LimitState.AtLower&&(this._impulse.Z=0),this._limitState=VelcroPhysics.Dynamics.Joints.LimitState.AtLower):jointAngle>=this._upperAngle?(this._limitState!==VelcroPhysics.Dynamics.Joints.LimitState.AtUpper&&(this._impulse.Z=0),this._limitState=VelcroPhysics.Dynamics.Joints.LimitState.AtUpper):(this._limitState=VelcroPhysics.Dynamics.Joints.LimitState.Inactive,this._impulse.Z=0)):this._limitState=VelcroPhysics.Dynamics.Joints.LimitState.Inactive;VelcroPhysics.Settings.EnableWarmstarting?(this._impulse=Microsoft.Xna.Framework.Vector3.op_Multiply$1(this._impulse.$clone(),data.v.Step.dtRatio),this._motorImpulse*=data.v.Step.dtRatio,P=new Microsoft.Xna.Framework.Vector2.$ctor2(this._impulse.X,this._impulse.Y),vA=Microsoft.Xna.Framework.Vector2.op_Subtraction(vA.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mA,P.$clone())),wA-=iA*(VelcroPhysics.Utilities.MathUtils.Cross$3(this._rA.$clone(),P.$clone())+this.MotorImpulse+this._impulse.Z),vB=Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mB,P.$clone())),wB+=iB*(VelcroPhysics.Utilities.MathUtils.Cross$3(this._rB.$clone(),P.$clone())+this.MotorImpulse+this._impulse.Z)):(this._impulse=Microsoft.Xna.Framework.Vector3.Zero.$clone(),this._motorImpulse=0);data.v.Velocities[this._indexA].V=vA.$clone();data.v.Velocities[this._indexA].W=wA;data.v.Velocities[this._indexB].V=vB.$clone();data.v.Velocities[this._indexB].W=wB},SolveVelocityConstraints:function(data){var vA=data.v.Velocities[this._indexA].V.$clone(),wA=data.v.Velocities[this._indexA].W,vB=data.v.Velocities[this._indexB].V.$clone(),wB=data.v.Velocities[this._indexB].W,mA=this._invMassA,mB=this._invMassB,iA=this._invIA,iB=this._invIB,fixedRotation=iA+iB===0,newImpulse,rhs,reduced,newImpulse1,rhs1,reduced1,P,Cdot4,impulse2;if(this._enableMotor&&this._limitState!==VelcroPhysics.Dynamics.Joints.LimitState.Equal&&fixedRotation===!1){var Cdot=wB-wA-this._motorSpeed,impulse=this._motorMass*-Cdot,oldImpulse=this._motorImpulse,maxImpulse=data.v.Step.dt*this._maxMotorTorque;this._motorImpulse=VelcroPhysics.Utilities.MathUtils.Clamp$2(this._motorImpulse+impulse,-maxImpulse,maxImpulse);impulse=this._motorImpulse-oldImpulse;wA-=iA*impulse;wB+=iB*impulse}if(this._enableLimit&&this._limitState!==VelcroPhysics.Dynamics.Joints.LimitState.Inactive&&fixedRotation===!1){var Cdot1=Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(),VelcroPhysics.Utilities.MathUtils.Cross$1(wB,this._rB.$clone())),vA.$clone()),VelcroPhysics.Utilities.MathUtils.Cross$1(wA,this._rA.$clone())),Cdot2=wB-wA,Cdot3=new Microsoft.Xna.Framework.Vector3.$ctor3(Cdot1.X,Cdot1.Y,Cdot2),impulse1=Microsoft.Xna.Framework.Vector3.op_UnaryNegation(this._mass.Solve33(Cdot3.$clone()));this._limitState===VelcroPhysics.Dynamics.Joints.LimitState.Equal?this._impulse=Microsoft.Xna.Framework.Vector3.op_Addition(this._impulse.$clone(),impulse1.$clone()):this._limitState===VelcroPhysics.Dynamics.Joints.LimitState.AtLower?(newImpulse=this._impulse.Z+impulse1.Z,newImpulse<0?(rhs=Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_UnaryNegation(Cdot1.$clone()),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._impulse.Z,new Microsoft.Xna.Framework.Vector2.$ctor2(this._mass.ez.X,this._mass.ez.Y))),reduced=this._mass.Solve22(rhs.$clone()),impulse1.X=reduced.X,impulse1.Y=reduced.Y,impulse1.Z=-this._impulse.Z,this._impulse.X+=reduced.X,this._impulse.Y+=reduced.Y,this._impulse.Z=0):this._impulse=Microsoft.Xna.Framework.Vector3.op_Addition(this._impulse.$clone(),impulse1.$clone())):this._limitState===VelcroPhysics.Dynamics.Joints.LimitState.AtUpper&&(newImpulse1=this._impulse.Z+impulse1.Z,newImpulse1>0?(rhs1=Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_UnaryNegation(Cdot1.$clone()),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._impulse.Z,new Microsoft.Xna.Framework.Vector2.$ctor2(this._mass.ez.X,this._mass.ez.Y))),reduced1=this._mass.Solve22(rhs1.$clone()),impulse1.X=reduced1.X,impulse1.Y=reduced1.Y,impulse1.Z=-this._impulse.Z,this._impulse.X+=reduced1.X,this._impulse.Y+=reduced1.Y,this._impulse.Z=0):this._impulse=Microsoft.Xna.Framework.Vector3.op_Addition(this._impulse.$clone(),impulse1.$clone()));P=new Microsoft.Xna.Framework.Vector2.$ctor2(impulse1.X,impulse1.Y);vA=Microsoft.Xna.Framework.Vector2.op_Subtraction(vA.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mA,P.$clone()));wA-=iA*(VelcroPhysics.Utilities.MathUtils.Cross$3(this._rA.$clone(),P.$clone())+impulse1.Z);vB=Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mB,P.$clone()));wB+=iB*(VelcroPhysics.Utilities.MathUtils.Cross$3(this._rB.$clone(),P.$clone())+impulse1.Z)}else Cdot4=Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(),VelcroPhysics.Utilities.MathUtils.Cross$1(wB,this._rB.$clone())),vA.$clone()),VelcroPhysics.Utilities.MathUtils.Cross$1(wA,this._rA.$clone())),impulse2=this._mass.Solve22(Microsoft.Xna.Framework.Vector2.op_UnaryNegation(Cdot4.$clone())),this._impulse.X+=impulse2.X,this._impulse.Y+=impulse2.Y,vA=Microsoft.Xna.Framework.Vector2.op_Subtraction(vA.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mA,impulse2.$clone())),wA-=iA*VelcroPhysics.Utilities.MathUtils.Cross$3(this._rA.$clone(),impulse2.$clone()),vB=Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mB,impulse2.$clone())),wB+=iB*VelcroPhysics.Utilities.MathUtils.Cross$3(this._rB.$clone(),impulse2.$clone());data.v.Velocities[this._indexA].V=vA.$clone();data.v.Velocities[this._indexA].W=wA;data.v.Velocities[this._indexB].V=vB.$clone();data.v.Velocities[this._indexB].W=wB},SolvePositionConstraints:function(data){var cA=data.v.Positions[this._indexA].C.$clone(),aA=data.v.Positions[this._indexA].A,cB=data.v.Positions[this._indexB].C.$clone(),aB=data.v.Positions[this._indexB].A,qA=new VelcroPhysics.Shared.Rot.$ctor1(aA),qB=new VelcroPhysics.Shared.Rot.$ctor1(aB),angularError=0,positionError,fixedRotation=this._invIA+this._invIB===0,angle,limitImpulse,C,C1,C2,impulse;this._enableLimit&&this._limitState!==VelcroPhysics.Dynamics.Joints.LimitState.Inactive&&fixedRotation===!1&&(angle=aB-aA-this.ReferenceAngle,limitImpulse=0,this._limitState===VelcroPhysics.Dynamics.Joints.LimitState.Equal?(C=VelcroPhysics.Utilities.MathUtils.Clamp$2(angle-this._lowerAngle,-.139626354,VelcroPhysics.Settings.MaxAngularCorrection),limitImpulse=-this._motorMass*C,angularError=Math.abs(C)):this._limitState===VelcroPhysics.Dynamics.Joints.LimitState.AtLower?(C1=angle-this._lowerAngle,angularError=-C1,C1=VelcroPhysics.Utilities.MathUtils.Clamp$2(C1+VelcroPhysics.Settings.AngularSlop,-.139626354,0),limitImpulse=-this._motorMass*C1):this._limitState===VelcroPhysics.Dynamics.Joints.LimitState.AtUpper&&(C2=angle-this._upperAngle,angularError=C2,C2=VelcroPhysics.Utilities.MathUtils.Clamp$2(C2-VelcroPhysics.Settings.AngularSlop,0,VelcroPhysics.Settings.MaxAngularCorrection),limitImpulse=-this._motorMass*C2),aA-=this._invIA*limitImpulse,aB+=this._invIB*limitImpulse);qA.Set(aA);qB.Set(aB);var rA=VelcroPhysics.Utilities.MathUtils.Mul$2(qA.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(),this._localCenterA.$clone())),rB=VelcroPhysics.Utilities.MathUtils.Mul$2(qB.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(),this._localCenterB.$clone())),C3=Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(cB.$clone(),rB.$clone()),cA.$clone()),rA.$clone());positionError=C3.Length();var mA=this._invMassA,mB=this._invMassB,iA=this._invIA,iB=this._invIB,K=new VelcroPhysics.Shared.Mat22.ctor;return K.ex.X=mA+mB+iA*rA.Y*rA.Y+iB*rB.Y*rB.Y,K.ex.Y=-iA*rA.X*rA.Y-iB*rB.X*rB.Y,K.ey.X=K.ex.Y,K.ey.Y=mA+mB+iA*rA.X*rA.X+iB*rB.X*rB.X,impulse=Microsoft.Xna.Framework.Vector2.op_UnaryNegation(K.Solve(C3.$clone())),cA=Microsoft.Xna.Framework.Vector2.op_Subtraction(cA.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mA,impulse.$clone())),aA-=iA*VelcroPhysics.Utilities.MathUtils.Cross$3(rA.$clone(),impulse.$clone()),cB=Microsoft.Xna.Framework.Vector2.op_Addition(cB.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mB,impulse.$clone())),aB+=iB*VelcroPhysics.Utilities.MathUtils.Cross$3(rB.$clone(),impulse.$clone()),data.v.Positions[this._indexA].C=cA.$clone(),data.v.Positions[this._indexA].A=aA,data.v.Positions[this._indexB].C=cB.$clone(),data.v.Positions[this._indexB].A=aB,positionError<=VelcroPhysics.Settings.LinearSlop&&angularError<=VelcroPhysics.Settings.AngularSlop}}});Bridge.define("VelcroPhysics.Dynamics.Joints.RopeJoint",{inherits:[VelcroPhysics.Dynamics.Joints.Joint],fields:{_impulse:0,_indexA:0,_indexB:0,_invIA:0,_invIB:0,_invMassA:0,_invMassB:0,_length:0,_localCenterA:null,_localCenterB:null,_mass:0,_rA:null,_rB:null,_u:null,LocalAnchorA:null,LocalAnchorB:null,MaxLength:0,State:0},props:{WorldAnchorA:{get:function(){return this.BodyA.GetWorldPoint(this.LocalAnchorA.$clone())},set:function(value){this.LocalAnchorA=this.BodyA.GetLocalPoint(value.$clone())}},WorldAnchorB:{get:function(){return this.BodyB.GetWorldPoint(this.LocalAnchorB.$clone())},set:function(value){this.LocalAnchorB=this.BodyB.GetLocalPoint(value.$clone())}}},ctors:{init:function(){this._localCenterA=new Microsoft.Xna.Framework.Vector2;this._localCenterB=new Microsoft.Xna.Framework.Vector2;this._rA=new Microsoft.Xna.Framework.Vector2;this._rB=new Microsoft.Xna.Framework.Vector2;this._u=new Microsoft.Xna.Framework.Vector2;this.LocalAnchorA=new Microsoft.Xna.Framework.Vector2;this.LocalAnchorB=new Microsoft.Xna.Framework.Vector2},ctor:function(){this.$initialize();VelcroPhysics.Dynamics.Joints.Joint.ctor.call(this);this.JointType=VelcroPhysics.Dynamics.Joints.JointType.Rope},$ctor1:function(bodyA,bodyB,anchorA,anchorB,useWorldCoordinates){useWorldCoordinates===void 0&&(useWorldCoordinates=!1);this.$initialize();VelcroPhysics.Dynamics.Joints.Joint.$ctor2.call(this,bodyA,bodyB);this.JointType=VelcroPhysics.Dynamics.Joints.JointType.Rope;useWorldCoordinates?(this.LocalAnchorA=bodyA.GetLocalPoint(anchorA.$clone()),this.LocalAnchorB=bodyB.GetLocalPoint(anchorB.$clone())):(this.LocalAnchorA=anchorA.$clone(),this.LocalAnchorB=anchorB.$clone());var d=Microsoft.Xna.Framework.Vector2.op_Subtraction(this.WorldAnchorB.$clone(),this.WorldAnchorA.$clone());this.MaxLength=d.Length()}},methods:{GetReactionForce:function(invDt){return Microsoft.Xna.Framework.Vector2.op_Multiply$2(invDt*this._impulse,this._u.$clone())},GetReactionTorque:function(invDt){return 0},InitVelocityConstraints:function(data){var C,P;this._indexA=this.BodyA.IslandIndex;this._indexB=this.BodyB.IslandIndex;this._localCenterA=this.BodyA._sweep.LocalCenter.$clone();this._localCenterB=this.BodyB._sweep.LocalCenter.$clone();this._invMassA=this.BodyA._invMass;this._invMassB=this.BodyB._invMass;this._invIA=this.BodyA._invI;this._invIB=this.BodyB._invI;var cA=data.v.Positions[this._indexA].C.$clone(),aA=data.v.Positions[this._indexA].A,vA=data.v.Velocities[this._indexA].V.$clone(),wA=data.v.Velocities[this._indexA].W,cB=data.v.Positions[this._indexB].C.$clone(),aB=data.v.Positions[this._indexB].A,vB=data.v.Velocities[this._indexB].V.$clone(),wB=data.v.Velocities[this._indexB].W,qA=new VelcroPhysics.Shared.Rot.$ctor1(aA),qB=new VelcroPhysics.Shared.Rot.$ctor1(aB);if(this._rA=VelcroPhysics.Utilities.MathUtils.Mul$2(qA.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(),this._localCenterA.$clone())),this._rB=VelcroPhysics.Utilities.MathUtils.Mul$2(qB.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(),this._localCenterB.$clone())),this._u=Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(cB.$clone(),this._rB.$clone()),cA.$clone()),this._rA.$clone()),this._length=this._u.Length(),C=this._length-this.MaxLength,this.State=C>0?VelcroPhysics.Dynamics.Joints.LimitState.AtUpper:VelcroPhysics.Dynamics.Joints.LimitState.Inactive,this._length>VelcroPhysics.Settings.LinearSlop)this._u=Microsoft.Xna.Framework.Vector2.op_Multiply$1(this._u.$clone(),1/this._length);else{this._u=Microsoft.Xna.Framework.Vector2.Zero.$clone();this._mass=0;this._impulse=0;return}var crA=VelcroPhysics.Utilities.MathUtils.Cross$3(this._rA.$clone(),this._u.$clone()),crB=VelcroPhysics.Utilities.MathUtils.Cross$3(this._rB.$clone(),this._u.$clone()),invMass=this._invMassA+this._invIA*crA*crA+this._invMassB+this._invIB*crB*crB;this._mass=invMass!==0?1/invMass:0;VelcroPhysics.Settings.EnableWarmstarting?(this._impulse*=data.v.Step.dtRatio,P=Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._impulse,this._u.$clone()),vA=Microsoft.Xna.Framework.Vector2.op_Subtraction(vA.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._invMassA,P.$clone())),wA-=this._invIA*VelcroPhysics.Utilities.MathUtils.Cross$3(this._rA.$clone(),P.$clone()),vB=Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._invMassB,P.$clone())),wB+=this._invIB*VelcroPhysics.Utilities.MathUtils.Cross$3(this._rB.$clone(),P.$clone())):this._impulse=0;data.v.Velocities[this._indexA].V=vA.$clone();data.v.Velocities[this._indexA].W=wA;data.v.Velocities[this._indexB].V=vB.$clone();data.v.Velocities[this._indexB].W=wB},SolveVelocityConstraints:function(data){var vA=data.v.Velocities[this._indexA].V.$clone(),wA=data.v.Velocities[this._indexA].W,vB=data.v.Velocities[this._indexB].V.$clone(),wB=data.v.Velocities[this._indexB].W,vpA=Microsoft.Xna.Framework.Vector2.op_Addition(vA.$clone(),VelcroPhysics.Utilities.MathUtils.Cross$1(wA,this._rA.$clone())),vpB=Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(),VelcroPhysics.Utilities.MathUtils.Cross$1(wB,this._rB.$clone())),C=this._length-this.MaxLength,Cdot=Microsoft.Xna.Framework.Vector2.Dot(this._u.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(vpB.$clone(),vpA.$clone())),impulse,oldImpulse,P;C<0&&(Cdot+=data.v.Step.inv_dt*C);impulse=-this._mass*Cdot;oldImpulse=this._impulse;this._impulse=Math.min(0,this._impulse+impulse);impulse=this._impulse-oldImpulse;P=Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse,this._u.$clone());vA=Microsoft.Xna.Framework.Vector2.op_Subtraction(vA.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._invMassA,P.$clone()));wA-=this._invIA*VelcroPhysics.Utilities.MathUtils.Cross$3(this._rA.$clone(),P.$clone());vB=Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._invMassB,P.$clone()));wB+=this._invIB*VelcroPhysics.Utilities.MathUtils.Cross$3(this._rB.$clone(),P.$clone());data.v.Velocities[this._indexA].V=vA.$clone();data.v.Velocities[this._indexA].W=wA;data.v.Velocities[this._indexB].V=vB.$clone();data.v.Velocities[this._indexB].W=wB},SolvePositionConstraints:function(data){var cA=data.v.Positions[this._indexA].C.$clone(),aA=data.v.Positions[this._indexA].A,cB=data.v.Positions[this._indexB].C.$clone(),aB=data.v.Positions[this._indexB].A,qA=new VelcroPhysics.Shared.Rot.$ctor1(aA),qB=new VelcroPhysics.Shared.Rot.$ctor1(aB),rA=VelcroPhysics.Utilities.MathUtils.Mul$2(qA.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(),this._localCenterA.$clone())),rB=VelcroPhysics.Utilities.MathUtils.Mul$2(qB.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(),this._localCenterB.$clone())),u=Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(cB.$clone(),rB.$clone()),cA.$clone()),rA.$clone()),length=u.Length(),C,impulse,P;return u.Normalize(),C=length-this.MaxLength,C=VelcroPhysics.Utilities.MathUtils.Clamp$2(C,0,VelcroPhysics.Settings.MaxLinearCorrection),impulse=-this._mass*C,P=Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse,u.$clone()),cA=Microsoft.Xna.Framework.Vector2.op_Subtraction(cA.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._invMassA,P.$clone())),aA-=this._invIA*VelcroPhysics.Utilities.MathUtils.Cross$3(rA.$clone(),P.$clone()),cB=Microsoft.Xna.Framework.Vector2.op_Addition(cB.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._invMassB,P.$clone())),aB+=this._invIB*VelcroPhysics.Utilities.MathUtils.Cross$3(rB.$clone(),P.$clone()),data.v.Positions[this._indexA].C=cA.$clone(),data.v.Positions[this._indexA].A=aA,data.v.Positions[this._indexB].C=cB.$clone(),data.v.Positions[this._indexB].A=aB,length-this.MaxLength<VelcroPhysics.Settings.LinearSlop}}});Bridge.define("VelcroPhysics.Dynamics.Joints.WeldJoint",{inherits:[VelcroPhysics.Dynamics.Joints.Joint],fields:{_bias:0,_gamma:0,_impulse:null,_indexA:0,_indexB:0,_invIA:0,_invIB:0,_invMassA:0,_invMassB:0,_localCenterA:null,_localCenterB:null,_mass:null,_rA:null,_rB:null,LocalAnchorA:null,LocalAnchorB:null,ReferenceAngle:0,FrequencyHz:0,DampingRatio:0},props:{WorldAnchorA:{get:function(){return this.BodyA.GetWorldPoint(this.LocalAnchorA.$clone())},set:function(value){this.LocalAnchorA=this.BodyA.GetLocalPoint(value.$clone())}},WorldAnchorB:{get:function(){return this.BodyB.GetWorldPoint(this.LocalAnchorB.$clone())},set:function(value){this.LocalAnchorB=this.BodyB.GetLocalPoint(value.$clone())}}},ctors:{init:function(){this._impulse=new Microsoft.Xna.Framework.Vector3;this._localCenterA=new Microsoft.Xna.Framework.Vector2;this._localCenterB=new Microsoft.Xna.Framework.Vector2;this._mass=new VelcroPhysics.Shared.Mat33;this._rA=new Microsoft.Xna.Framework.Vector2;this._rB=new Microsoft.Xna.Framework.Vector2;this.LocalAnchorA=new Microsoft.Xna.Framework.Vector2;this.LocalAnchorB=new Microsoft.Xna.Framework.Vector2},ctor:function(){this.$initialize();VelcroPhysics.Dynamics.Joints.Joint.ctor.call(this);this.JointType=VelcroPhysics.Dynamics.Joints.JointType.Weld},$ctor1:function(bodyA,bodyB,anchorA,anchorB,useWorldCoordinates){useWorldCoordinates===void 0&&(useWorldCoordinates=!1);this.$initialize();VelcroPhysics.Dynamics.Joints.Joint.$ctor2.call(this,bodyA,bodyB);this.JointType=VelcroPhysics.Dynamics.Joints.JointType.Weld;useWorldCoordinates?(this.LocalAnchorA=bodyA.GetLocalPoint(anchorA.$clone()),this.LocalAnchorB=bodyB.GetLocalPoint(anchorB.$clone())):(this.LocalAnchorA=anchorA.$clone(),this.LocalAnchorB=anchorB.$clone());this.ReferenceAngle=this.BodyB.Rotation-this.BodyA.Rotation}},methods:{GetReactionForce:function(invDt){return Microsoft.Xna.Framework.Vector2.op_Multiply$2(invDt,new Microsoft.Xna.Framework.Vector2.$ctor2(this._impulse.X,this._impulse.Y))},GetReactionTorque:function(invDt){return invDt*this._impulse.Z},InitVelocityConstraints:function(data){var P;this._indexA=this.BodyA.IslandIndex;this._indexB=this.BodyB.IslandIndex;this._localCenterA=this.BodyA._sweep.LocalCenter.$clone();this._localCenterB=this.BodyB._sweep.LocalCenter.$clone();this._invMassA=this.BodyA._invMass;this._invMassB=this.BodyB._invMass;this._invIA=this.BodyA._invI;this._invIB=this.BodyB._invI;var aA=data.v.Positions[this._indexA].A,vA=data.v.Velocities[this._indexA].V.$clone(),wA=data.v.Velocities[this._indexA].W,aB=data.v.Positions[this._indexB].A,vB=data.v.Velocities[this._indexB].V.$clone(),wB=data.v.Velocities[this._indexB].W,qA=new VelcroPhysics.Shared.Rot.$ctor1(aA),qB=new VelcroPhysics.Shared.Rot.$ctor1(aB);this._rA=VelcroPhysics.Utilities.MathUtils.Mul$2(qA.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(),this._localCenterA.$clone()));this._rB=VelcroPhysics.Utilities.MathUtils.Mul$2(qB.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(),this._localCenterB.$clone()));var mA=this._invMassA,mB=this._invMassB,iA=this._invIA,iB=this._invIB,K=new VelcroPhysics.Shared.Mat33.ctor;if(K.ex.X=mA+mB+this._rA.Y*this._rA.Y*iA+this._rB.Y*this._rB.Y*iB,K.ey.X=-this._rA.Y*this._rA.X*iA-this._rB.Y*this._rB.X*iB,K.ez.X=-this._rA.Y*iA-this._rB.Y*iB,K.ex.Y=K.ey.X,K.ey.Y=mA+mB+this._rA.X*this._rA.X*iA+this._rB.X*this._rB.X*iB,K.ez.Y=this._rA.X*iA+this._rB.X*iB,K.ex.Z=K.ez.X,K.ey.Z=K.ez.Y,K.ez.Z=iA+iB,this.FrequencyHz>0){K.GetInverse22(Bridge.ref(this,"_mass"));var invM=iA+iB,m=invM>0?1/invM:0,C=aB-aA-this.ReferenceAngle,omega=6.28318548*this.FrequencyHz,d=2*m*this.DampingRatio*omega,k=m*omega*omega,h=data.v.Step.dt;this._gamma=h*(d+h*k);this._gamma=this._gamma!==0?1/this._gamma:0;this._bias=C*h*k*this._gamma;invM+=this._gamma;this._mass.ez.Z=invM!==0?1/invM:0}else K.ez.Z===0?(K.GetInverse22(Bridge.ref(this,"_mass")),this._gamma=0,this._bias=0):(K.GetSymInverse33(Bridge.ref(this,"_mass")),this._gamma=0,this._bias=0);VelcroPhysics.Settings.EnableWarmstarting?(this._impulse=Microsoft.Xna.Framework.Vector3.op_Multiply$1(this._impulse.$clone(),data.v.Step.dtRatio),P=new Microsoft.Xna.Framework.Vector2.$ctor2(this._impulse.X,this._impulse.Y),vA=Microsoft.Xna.Framework.Vector2.op_Subtraction(vA.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mA,P.$clone())),wA-=iA*(VelcroPhysics.Utilities.MathUtils.Cross$3(this._rA.$clone(),P.$clone())+this._impulse.Z),vB=Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mB,P.$clone())),wB+=iB*(VelcroPhysics.Utilities.MathUtils.Cross$3(this._rB.$clone(),P.$clone())+this._impulse.Z)):this._impulse=Microsoft.Xna.Framework.Vector3.Zero.$clone();data.v.Velocities[this._indexA].V=vA.$clone();data.v.Velocities[this._indexA].W=wA;data.v.Velocities[this._indexB].V=vB.$clone();data.v.Velocities[this._indexB].W=wB},SolveVelocityConstraints:function(data){var vA=data.v.Velocities[this._indexA].V.$clone(),wA=data.v.Velocities[this._indexA].W,vB=data.v.Velocities[this._indexB].V.$clone(),wB=data.v.Velocities[this._indexB].W,mA=this._invMassA,mB=this._invMassB,iA=this._invIA,iB=this._invIB,Cdot2,impulse2,Cdot1,impulse1,P,P1;if(this.FrequencyHz>0)Cdot2=wB-wA,impulse2=-this._mass.ez.Z*(Cdot2+this._bias+this._gamma*this._impulse.Z),this._impulse.Z+=impulse2,wA-=iA*impulse2,wB+=iB*impulse2,Cdot1=Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(),VelcroPhysics.Utilities.MathUtils.Cross$1(wB,this._rB.$clone())),vA.$clone()),VelcroPhysics.Utilities.MathUtils.Cross$1(wA,this._rA.$clone())),impulse1=Microsoft.Xna.Framework.Vector2.op_UnaryNegation(VelcroPhysics.Utilities.MathUtils.Mul22(this._mass.$clone(),Cdot1.$clone())),this._impulse.X+=impulse1.X,this._impulse.Y+=impulse1.Y,P=impulse1.$clone(),vA=Microsoft.Xna.Framework.Vector2.op_Subtraction(vA.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mA,P.$clone())),wA-=iA*VelcroPhysics.Utilities.MathUtils.Cross$3(this._rA.$clone(),P.$clone()),vB=Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mB,P.$clone())),wB+=iB*VelcroPhysics.Utilities.MathUtils.Cross$3(this._rB.$clone(),P.$clone());else{var Cdot11=Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(),VelcroPhysics.Utilities.MathUtils.Cross$1(wB,this._rB.$clone())),vA.$clone()),VelcroPhysics.Utilities.MathUtils.Cross$1(wA,this._rA.$clone())),Cdot21=wB-wA,Cdot=new Microsoft.Xna.Framework.Vector3.$ctor3(Cdot11.X,Cdot11.Y,Cdot21),impulse=Microsoft.Xna.Framework.Vector3.op_UnaryNegation(VelcroPhysics.Utilities.MathUtils.Mul$6(this._mass.$clone(),Cdot.$clone()));this._impulse=Microsoft.Xna.Framework.Vector3.op_Addition(this._impulse.$clone(),impulse.$clone());P1=new Microsoft.Xna.Framework.Vector2.$ctor2(impulse.X,impulse.Y);vA=Microsoft.Xna.Framework.Vector2.op_Subtraction(vA.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mA,P1.$clone()));wA-=iA*(VelcroPhysics.Utilities.MathUtils.Cross$3(this._rA.$clone(),P1.$clone())+impulse.Z);vB=Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mB,P1.$clone()));wB+=iB*(VelcroPhysics.Utilities.MathUtils.Cross$3(this._rB.$clone(),P1.$clone())+impulse.Z)}data.v.Velocities[this._indexA].V=vA.$clone();data.v.Velocities[this._indexA].W=wA;data.v.Velocities[this._indexB].V=vB.$clone();data.v.Velocities[this._indexB].W=wB},SolvePositionConstraints:function(data){var cA=data.v.Positions[this._indexA].C.$clone(),aA=data.v.Positions[this._indexA].A,cB=data.v.Positions[this._indexB].C.$clone(),aB=data.v.Positions[this._indexB].A,qA=new VelcroPhysics.Shared.Rot.$ctor1(aA),qB=new VelcroPhysics.Shared.Rot.$ctor1(aB),mA=this._invMassA,mB=this._invMassB,iA=this._invIA,iB=this._invIB,rA=VelcroPhysics.Utilities.MathUtils.Mul$2(qA.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(),this._localCenterA.$clone())),rB=VelcroPhysics.Utilities.MathUtils.Mul$2(qB.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(),this._localCenterB.$clone())),positionError,angularError,K=new VelcroPhysics.Shared.Mat33.ctor,C1,P,C11,C2,C,impulse,impulse2,P1;return K.ex.X=mA+mB+rA.Y*rA.Y*iA+rB.Y*rB.Y*iB,K.ey.X=-rA.Y*rA.X*iA-rB.Y*rB.X*iB,K.ez.X=-rA.Y*iA-rB.Y*iB,K.ex.Y=K.ey.X,K.ey.Y=mA+mB+rA.X*rA.X*iA+rB.X*rB.X*iB,K.ez.Y=rA.X*iA+rB.X*iB,K.ex.Z=K.ez.X,K.ey.Z=K.ez.Y,K.ez.Z=iA+iB,this.FrequencyHz>0?(C1=Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(cB.$clone(),rB.$clone()),cA.$clone()),rA.$clone()),positionError=C1.Length(),angularError=0,P=Microsoft.Xna.Framework.Vector2.op_UnaryNegation(K.Solve22(C1.$clone())),cA=Microsoft.Xna.Framework.Vector2.op_Subtraction(cA.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mA,P.$clone())),aA-=iA*VelcroPhysics.Utilities.MathUtils.Cross$3(rA.$clone(),P.$clone()),cB=Microsoft.Xna.Framework.Vector2.op_Addition(cB.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mB,P.$clone())),aB+=iB*VelcroPhysics.Utilities.MathUtils.Cross$3(rB.$clone(),P.$clone())):(C11=Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(cB.$clone(),rB.$clone()),cA.$clone()),rA.$clone()),C2=aB-aA-this.ReferenceAngle,positionError=C11.Length(),angularError=Math.abs(C2),C=new Microsoft.Xna.Framework.Vector3.$ctor3(C11.X,C11.Y,C2),impulse=new Microsoft.Xna.Framework.Vector3,K.ez.Z>0?impulse=Microsoft.Xna.Framework.Vector3.op_UnaryNegation(K.Solve33(C.$clone())):(impulse2=Microsoft.Xna.Framework.Vector2.op_UnaryNegation(K.Solve22(C11.$clone())),impulse=new Microsoft.Xna.Framework.Vector3.$ctor3(impulse2.X,impulse2.Y,0)),P1=new Microsoft.Xna.Framework.Vector2.$ctor2(impulse.X,impulse.Y),cA=Microsoft.Xna.Framework.Vector2.op_Subtraction(cA.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mA,P1.$clone())),aA-=iA*(VelcroPhysics.Utilities.MathUtils.Cross$3(rA.$clone(),P1.$clone())+impulse.Z),cB=Microsoft.Xna.Framework.Vector2.op_Addition(cB.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mB,P1.$clone())),aB+=iB*(VelcroPhysics.Utilities.MathUtils.Cross$3(rB.$clone(),P1.$clone())+impulse.Z)),data.v.Positions[this._indexA].C=cA.$clone(),data.v.Positions[this._indexA].A=aA,data.v.Positions[this._indexB].C=cB.$clone(),data.v.Positions[this._indexB].A=aB,positionError<=VelcroPhysics.Settings.LinearSlop&&angularError<=VelcroPhysics.Settings.AngularSlop}}});Bridge.define("VelcroPhysics.Dynamics.Joints.WheelJoint",{inherits:[VelcroPhysics.Dynamics.Joints.Joint],fields:{_ax:null,_ay:null,_axis:null,_bias:0,_enableMotor:!1,_gamma:0,_impulse:0,_indexA:0,_indexB:0,_invIA:0,_invIB:0,_invMassA:0,_invMassB:0,_localCenterA:null,_localCenterB:null,_localYAxis:null,_mass:0,_maxMotorTorque:0,_motorImpulse:0,_motorMass:0,_motorSpeed:0,_sAx:0,_sBx:0,_sAy:0,_sBy:0,_springImpulse:0,_springMass:0,LocalAnchorA:null,LocalAnchorB:null,LocalXAxis:null,Frequency:0,DampingRatio:0},props:{WorldAnchorA:{get:function(){return this.BodyA.GetWorldPoint(this.LocalAnchorA.$clone())},set:function(value){this.LocalAnchorA=this.BodyA.GetLocalPoint(value.$clone())}},WorldAnchorB:{get:function(){return this.BodyB.GetWorldPoint(this.LocalAnchorB.$clone())},set:function(value){this.LocalAnchorB=this.BodyB.GetLocalPoint(value.$clone())}},Axis:{get:function(){return this._axis.$clone()},set:function(value){this._axis=value.$clone();this.LocalXAxis=this.BodyA.GetLocalVector(this._axis.$clone());this._localYAxis=VelcroPhysics.Utilities.MathUtils.Cross$1(1,this.LocalXAxis.$clone())}},MotorSpeed:{get:function(){return this._motorSpeed},set:function(value){value!==this._motorSpeed&&(this.WakeBodies(),this._motorSpeed=value)}},MaxMotorTorque:{get:function(){return this._maxMotorTorque},set:function(value){value!==this._maxMotorTorque&&(this.WakeBodies(),this._maxMotorTorque=value)}},JointTranslation:{get:function(){var bA=this.BodyA,bB=this.BodyB,pA=bA.GetWorldPoint(this.LocalAnchorA.$clone()),pB=bB.GetWorldPoint(this.LocalAnchorB.$clone()),d=Microsoft.Xna.Framework.Vector2.op_Subtraction(pB.$clone(),pA.$clone()),axis=bA.GetWorldVector(this.LocalXAxis.$clone());return Microsoft.Xna.Framework.Vector2.Dot(d.$clone(),axis.$clone())}},JointLinearSpeed:{get:function(){var bA=this.BodyA,bB=this.BodyB,xfA={v:new VelcroPhysics.Shared.Transform},xfB;bA.GetTransform(xfA);xfB={v:new VelcroPhysics.Shared.Transform};bB.GetTransform(xfB);var rA=VelcroPhysics.Utilities.MathUtils.Mul$2(xfA.v.q.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(),bA._sweep.LocalCenter.$clone())),rB=VelcroPhysics.Utilities.MathUtils.Mul$2(xfB.v.q.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(),bB._sweep.LocalCenter.$clone())),p1=Microsoft.Xna.Framework.Vector2.op_Addition(bA._sweep.C.$clone(),rA.$clone()),p2=Microsoft.Xna.Framework.Vector2.op_Addition(bB._sweep.C.$clone(),rB.$clone()),d=Microsoft.Xna.Framework.Vector2.op_Subtraction(p2.$clone(),p1.$clone()),axis=VelcroPhysics.Utilities.MathUtils.Mul$2(xfA.v.q.$clone(),this.LocalXAxis.$clone()),vA=bA.LinearVelocity.$clone(),vB=bB.LinearVelocity.$clone(),wA=bA.AngularVelocity,wB=bB.AngularVelocity;return Microsoft.Xna.Framework.Vector2.Dot(d.$clone(),VelcroPhysics.Utilities.MathUtils.Cross$1(wA,axis.$clone()))+Microsoft.Xna.Framework.Vector2.Dot(axis.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(),VelcroPhysics.Utilities.MathUtils.Cross$1(wB,rB.$clone())),vA.$clone()),VelcroPhysics.Utilities.MathUtils.Cross$1(wA,rA.$clone())))}},JointAngle:{get:function(){var bA=this.BodyA,bB=this.BodyB;return bB._sweep.A-bA._sweep.A}},JointAngularSpeed:{get:function(){var wA=this.BodyA.AngularVelocity,wB=this.BodyB.AngularVelocity;return wB-wA}},MotorEnabled:{get:function(){return this._enableMotor},set:function(value){value!==this._enableMotor&&(this.WakeBodies(),this._enableMotor=value)}}},ctors:{init:function(){this._ax=new Microsoft.Xna.Framework.Vector2;this._ay=new Microsoft.Xna.Framework.Vector2;this._axis=new Microsoft.Xna.Framework.Vector2;this._localCenterA=new Microsoft.Xna.Framework.Vector2;this._localCenterB=new Microsoft.Xna.Framework.Vector2;this._localYAxis=new Microsoft.Xna.Framework.Vector2;this.LocalAnchorA=new Microsoft.Xna.Framework.Vector2;this.LocalAnchorB=new Microsoft.Xna.Framework.Vector2;this.LocalXAxis=new Microsoft.Xna.Framework.Vector2},ctor:function(){this.$initialize();VelcroPhysics.Dynamics.Joints.Joint.ctor.call(this);this.JointType=VelcroPhysics.Dynamics.Joints.JointType.Wheel},$ctor1:function(bodyA,bodyB,anchor,axis,useWorldCoordinates){useWorldCoordinates===void 0&&(useWorldCoordinates=!1);this.$initialize();VelcroPhysics.Dynamics.Joints.Joint.$ctor2.call(this,bodyA,bodyB);this.JointType=VelcroPhysics.Dynamics.Joints.JointType.Wheel;useWorldCoordinates?(this.LocalAnchorA=bodyA.GetLocalPoint(anchor.$clone()),this.LocalAnchorB=bodyB.GetLocalPoint(anchor.$clone())):(this.LocalAnchorA=bodyA.GetLocalPoint(bodyB.GetWorldPoint(anchor.$clone())),this.LocalAnchorB=anchor.$clone());this.Axis=axis.$clone()}},methods:{GetMotorTorque:function(invDt){return invDt*this._motorImpulse},GetReactionForce:function(invDt){return Microsoft.Xna.Framework.Vector2.op_Multiply$2(invDt,Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._impulse,this._ay.$clone()),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._springImpulse,this._ax.$clone())))},GetReactionTorque:function(invDt){return invDt*this._motorImpulse},InitVelocityConstraints:function(data){var invMass;this._indexA=this.BodyA.IslandIndex;this._indexB=this.BodyB.IslandIndex;this._localCenterA=this.BodyA._sweep.LocalCenter.$clone();this._localCenterB=this.BodyB._sweep.LocalCenter.$clone();this._invMassA=this.BodyA._invMass;this._invMassB=this.BodyB._invMass;this._invIA=this.BodyA._invI;this._invIB=this.BodyB._invI;var mA=this._invMassA,mB=this._invMassB,iA=this._invIA,iB=this._invIB,cA=data.v.Positions[this._indexA].C.$clone(),aA=data.v.Positions[this._indexA].A,vA=data.v.Velocities[this._indexA].V.$clone(),wA=data.v.Velocities[this._indexA].W,cB=data.v.Positions[this._indexB].C.$clone(),aB=data.v.Positions[this._indexB].A,vB=data.v.Velocities[this._indexB].V.$clone(),wB=data.v.Velocities[this._indexB].W,qA=new VelcroPhysics.Shared.Rot.$ctor1(aA),qB=new VelcroPhysics.Shared.Rot.$ctor1(aB),rA=VelcroPhysics.Utilities.MathUtils.Mul$2(qA.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(),this._localCenterA.$clone())),rB=VelcroPhysics.Utilities.MathUtils.Mul$2(qB.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(),this._localCenterB.$clone())),d1=Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(cB.$clone(),rB.$clone()),cA.$clone()),rA.$clone());if(this._ay=VelcroPhysics.Utilities.MathUtils.Mul$2(qA.$clone(),this._localYAxis.$clone()),this._sAy=VelcroPhysics.Utilities.MathUtils.Cross$3(Microsoft.Xna.Framework.Vector2.op_Addition(d1.$clone(),rA.$clone()),this._ay.$clone()),this._sBy=VelcroPhysics.Utilities.MathUtils.Cross$3(rB.$clone(),this._ay.$clone()),this._mass=mA+mB+iA*this._sAy*this._sAy+iB*this._sBy*this._sBy,this._mass>0&&(this._mass=1/this._mass),this._springMass=0,this._bias=0,this._gamma=0,this.Frequency>0){if(this._ax=VelcroPhysics.Utilities.MathUtils.Mul$2(qA.$clone(),this.LocalXAxis.$clone()),this._sAx=VelcroPhysics.Utilities.MathUtils.Cross$3(Microsoft.Xna.Framework.Vector2.op_Addition(d1.$clone(),rA.$clone()),this._ax.$clone()),this._sBx=VelcroPhysics.Utilities.MathUtils.Cross$3(rB.$clone(),this._ax.$clone()),invMass=mA+mB+iA*this._sAx*this._sAx+iB*this._sBx*this._sBx,invMass>0){this._springMass=1/invMass;var C=Microsoft.Xna.Framework.Vector2.Dot(d1.$clone(),this._ax.$clone()),omega=6.28318548*this.Frequency,d=2*this._springMass*this.DampingRatio*omega,k=this._springMass*omega*omega,h=data.v.Step.dt;this._gamma=h*(d+h*k);this._gamma>0&&(this._gamma=1/this._gamma);this._bias=C*h*k*this._gamma;this._springMass=invMass+this._gamma;this._springMass>0&&(this._springMass=1/this._springMass)}}else this._springImpulse=0;if(this._enableMotor?(this._motorMass=iA+iB,this._motorMass>0&&(this._motorMass=1/this._motorMass)):(this._motorMass=0,this._motorImpulse=0),VelcroPhysics.Settings.EnableWarmstarting){this._impulse*=data.v.Step.dtRatio;this._springImpulse*=data.v.Step.dtRatio;this._motorImpulse*=data.v.Step.dtRatio;var P=Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._impulse,this._ay.$clone()),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._springImpulse,this._ax.$clone())),LA=this._impulse*this._sAy+this._springImpulse*this._sAx+this._motorImpulse,LB=this._impulse*this._sBy+this._springImpulse*this._sBx+this._motorImpulse;vA=Microsoft.Xna.Framework.Vector2.op_Subtraction(vA.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._invMassA,P.$clone()));wA-=this._invIA*LA;vB=Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._invMassB,P.$clone()));wB+=this._invIB*LB}else this._impulse=0,this._springImpulse=0,this._motorImpulse=0;data.v.Velocities[this._indexA].V=vA.$clone();data.v.Velocities[this._indexA].W=wA;data.v.Velocities[this._indexB].V=vB.$clone();data.v.Velocities[this._indexB].W=wB},SolveVelocityConstraints:function(data){var mA=this._invMassA,mB=this._invMassB,iA=this._invIA,iB=this._invIB,vA=data.v.Velocities[this._indexA].V.$clone(),wA=data.v.Velocities[this._indexA].W,vB=data.v.Velocities[this._indexB].V.$clone(),wB=data.v.Velocities[this._indexB].W,Cdot=Microsoft.Xna.Framework.Vector2.Dot(this._ax.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(vB.$clone(),vA.$clone()))+this._sBx*wB-this._sAx*wA,impulse=-this._springMass*(Cdot+this._bias+this._gamma*this._springImpulse),Cdot2,impulse2;this._springImpulse+=impulse;var P=Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse,this._ax.$clone()),LA=impulse*this._sAx,LB=impulse*this._sBx;vA=Microsoft.Xna.Framework.Vector2.op_Subtraction(vA.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mA,P.$clone()));wA-=iA*LA;vB=Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mB,P.$clone()));wB+=iB*LB;var Cdot1=wB-wA-this._motorSpeed,impulse1=-this._motorMass*Cdot1,oldImpulse=this._motorImpulse,maxImpulse=data.v.Step.dt*this._maxMotorTorque;this._motorImpulse=VelcroPhysics.Utilities.MathUtils.Clamp$2(this._motorImpulse+impulse1,-maxImpulse,maxImpulse);impulse1=this._motorImpulse-oldImpulse;wA-=iA*impulse1;wB+=iB*impulse1;Cdot2=Microsoft.Xna.Framework.Vector2.Dot(this._ay.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(vB.$clone(),vA.$clone()))+this._sBy*wB-this._sAy*wA;impulse2=-this._mass*Cdot2;this._impulse+=impulse2;var P1=Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse2,this._ay.$clone()),LA1=impulse2*this._sAy,LB1=impulse2*this._sBy;vA=Microsoft.Xna.Framework.Vector2.op_Subtraction(vA.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mA,P1.$clone()));wA-=iA*LA1;vB=Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(mB,P1.$clone()));wB+=iB*LB1;data.v.Velocities[this._indexA].V=vA.$clone();data.v.Velocities[this._indexA].W=wA;data.v.Velocities[this._indexB].V=vB.$clone();data.v.Velocities[this._indexB].W=wB},SolvePositionConstraints:function(data){var cA=data.v.Positions[this._indexA].C.$clone(),aA=data.v.Positions[this._indexA].A,cB=data.v.Positions[this._indexB].C.$clone(),aB=data.v.Positions[this._indexB].A,qA=new VelcroPhysics.Shared.Rot.$ctor1(aA),qB=new VelcroPhysics.Shared.Rot.$ctor1(aB),rA=VelcroPhysics.Utilities.MathUtils.Mul$2(qA.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(),this._localCenterA.$clone())),rB=VelcroPhysics.Utilities.MathUtils.Mul$2(qB.$clone(),Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(),this._localCenterB.$clone())),d=Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Subtraction(cB.$clone(),cA.$clone()),rB.$clone()),rA.$clone()),ay=VelcroPhysics.Utilities.MathUtils.Mul$2(qA.$clone(),this._localYAxis.$clone()),sAy=VelcroPhysics.Utilities.MathUtils.Cross$3(Microsoft.Xna.Framework.Vector2.op_Addition(d.$clone(),rA.$clone()),ay.$clone()),sBy=VelcroPhysics.Utilities.MathUtils.Cross$3(rB.$clone(),ay.$clone()),C=Microsoft.Xna.Framework.Vector2.Dot(d.$clone(),ay.$clone()),k=this._invMassA+this._invMassB+this._invIA*this._sAy*this._sAy+this._invIB*this._sBy*this._sBy,impulse=k!==0?-C/k:0;var P=Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse,ay.$clone()),LA=impulse*sAy,LB=impulse*sBy;return cA=Microsoft.Xna.Framework.Vector2.op_Subtraction(cA.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._invMassA,P.$clone())),aA-=this._invIA*LA,cB=Microsoft.Xna.Framework.Vector2.op_Addition(cB.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._invMassB,P.$clone())),aB+=this._invIB*LB,data.v.Positions[this._indexA].C=cA.$clone(),data.v.Positions[this._indexA].A=aA,data.v.Positions[this._indexB].C=cB.$clone(),data.v.Positions[this._indexB].A=aB,Math.abs(C)<=VelcroPhysics.Settings.LinearSlop}}});Bridge.define("VelcroPhysics.Extensions.Controllers.ControllerBase.Controller",{inherits:[VelcroPhysics.Extensions.PhysicsLogics.PhysicsLogicBase.FilterData],fields:{_type:0,Enabled:!1,World:null},ctors:{ctor:function(controllerType){this.$initialize();VelcroPhysics.Extensions.PhysicsLogics.PhysicsLogicBase.FilterData.ctor.call(this);this._type=controllerType}},methods:{IsActiveOn:function(body){return body.ControllerFilter.IsControllerIgnored(this._type)?!1:VelcroPhysics.Extensions.PhysicsLogics.PhysicsLogicBase.FilterData.prototype.IsActiveOn.call(this,body)}}});Bridge.define("VelcroPhysics.Extensions.PhysicsLogics.PhysicsLogicBase.PhysicsLogic",{inherits:[VelcroPhysics.Extensions.PhysicsLogics.PhysicsLogicBase.FilterData],fields:{_type:0,World:null},ctors:{ctor:function(world,type){this.$initialize();VelcroPhysics.Extensions.PhysicsLogics.PhysicsLogicBase.FilterData.ctor.call(this);this._type=type;this.World=world}},methods:{IsActiveOn:function(body){return body.PhysicsLogicFilter.IsPhysicsLogicIgnored(this._type)?!1:VelcroPhysics.Extensions.PhysicsLogics.PhysicsLogicBase.FilterData.prototype.IsActiveOn.call(this,body)}}});Bridge.define("VelcroPhysics.Shared.BenchmarkRun",{inherits:function(){return[VelcroPhysics.Shared.Optimization.IPoolable$1(VelcroPhysics.Shared.BenchmarkRun)]},fields:{_area:null,_stopwatch:null,_resultsRecorded:!1,Pool:null},alias:["Dispose","System$IDisposable$Dispose","Reset","VelcroPhysics$Shared$Optimization$IPoolable$1$VelcroPhysics$Shared$BenchmarkRun$Reset","Pool","VelcroPhysics$Shared$Optimization$IPoolable$1$VelcroPhysics$Shared$BenchmarkRun$Pool"],ctors:{init:function(){this._stopwatch=new System.Diagnostics.Stopwatch}},methods:{SetData:function(area){this._area=area;this._stopwatch.start()},Dispose:function(){this.RecordResults();this.Pool.ReturnToPool(this)},RecordResults:function(){this._resultsRecorded||(this._stopwatch.stop(),VelcroPhysics.Shared.Benchmark.RecordResults(this._area,this._stopwatch.ticks()),this._resultsRecorded=!0)},Reset:function(){this._stopwatch.reset()}}});Bridge.define("VelcroPhysics.Shared.Pool$1",function(T){return{fields:{_queue:null,_objectCreator:null},props:{LeftInPool:{get:function(){return this._queue.Count}}},ctors:{ctor:function(objectCreator,capacity,preCreateInstances){var i,obj;if(capacity===void 0&&(capacity=16),preCreateInstances===void 0&&(preCreateInstances=!0),this.$initialize(),this._objectCreator=objectCreator,this._queue=new(System.Collections.Generic.Queue$1(T).$ctor2)(capacity),preCreateInstances)for(i=0;i<capacity;i=i+1|0)obj=objectCreator(),obj["VelcroPhysics$Shared$Optimization$IPoolable$1$"+Bridge.getTypeAlias(T)+"$Pool"]=this,this._queue.Enqueue(obj)}},methods:{GetFromPool:function(){return this._queue.Count===0?this._objectCreator():this._queue.Dequeue()},GetManyFromPool:function(count){return new(Bridge.GeneratorEnumerable$1(T))(Bridge.fn.bind(this,function(count){var $step=0,$jumpFromFinally,$returnValue,i,$async_e,$enumerator=new(Bridge.GeneratorEnumerator$1(T))(Bridge.fn.bind(this,function(){try{for(;;)switch($step){case 0:System.Diagnostics.Debug.Assert(count!==0);i=0;$step=1;continue;case 1:if(i<count){$step=2;continue}$step=5;continue;case 2:return $enumerator.current=this.GetFromPool(),$step=3,!0;case 3:$step=4;continue;case 4:i=i+1|0;$step=1;continue;case 5:default:return!1}}catch($async_e1){$async_e=System.Exception.create($async_e1);throw $async_e;}}));return $enumerator},arguments))},ReturnToPool:function(obj){obj["VelcroPhysics$Shared$Optimization$IPoolable$1$"+Bridge.getTypeAlias(T)+"$Reset"]();this._queue.Enqueue(obj)},ReturnToPool$1:function(objs){var $t,obj;$t=Bridge.getEnumerator(objs,T);try{while($t.moveNext())obj=$t.Current,obj["VelcroPhysics$Shared$Optimization$IPoolable$1$"+Bridge.getTypeAlias(T)+"$Reset"](),this._queue.Enqueue(obj)}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}}}}});Bridge.define("VelcroPhysics.Templates.BodyTemplate",{inherits:[VelcroPhysics.Templates.IDefaults],fields:{Awake:!1,Active:!1,AllowCCD:!1,AllowRotation:!1,AllowSleep:!1,Angle:0,AngularDamping:0,AngularVelocity:0,GravityScale:0,LinearDamping:0,LinearVelocity:null,Position:null,Type:0,UserData:null},alias:["SetDefaults","VelcroPhysics$Templates$IDefaults$SetDefaults"],ctors:{init:function(){this.LinearVelocity=new Microsoft.Xna.Framework.Vector2;this.Position=new Microsoft.Xna.Framework.Vector2},ctor:function(){this.$initialize();this.SetDefaults()}},methods:{SetDefaults:function(){this.AllowSleep=!0;this.Awake=!0;this.Type=VelcroPhysics.Dynamics.BodyType.Static;this.Active=!0;this.GravityScale=1}}});Bridge.define("VelcroPhysics.Templates.FixtureTemplate",{inherits:[VelcroPhysics.Templates.IDefaults],fields:{Density:0,Filter:null,Friction:0,IsSensor:!1,Restitution:0,Shape:null,UserData:null},alias:["SetDefaults","VelcroPhysics$Templates$IDefaults$SetDefaults"],ctors:{ctor:function(){this.$initialize();this.SetDefaults()}},methods:{SetDefaults:function(){this.Friction=.2}}});Bridge.define("VelcroPhysics.Templates.Joints.JointTemplate",{inherits:[VelcroPhysics.Templates.IDefaults],fields:{BodyA:null,BodyB:null,CollideConnected:!1,Type:0,UserData:null},alias:["SetDefaults","VelcroPhysics$Templates$IDefaults$SetDefaults"],ctors:{ctor:function(type){this.$initialize();this.Type=type}},methods:{SetDefaults:function(){}}});Bridge.define("VelcroPhysics.Templates.Shapes.ChainShapeTemplate",{inherits:[VelcroPhysics.Templates.Shapes.ShapeTemplate],fields:{NextVertex:null,PrevVertex:null,Vertices:null},ctors:{init:function(){this.NextVertex=new Microsoft.Xna.Framework.Vector2;this.PrevVertex=new Microsoft.Xna.Framework.Vector2},ctor:function(){this.$initialize();VelcroPhysics.Templates.Shapes.ShapeTemplate.ctor.call(this,VelcroPhysics.Collision.Shapes.ShapeType.Chain)}}});Bridge.define("VelcroPhysics.Templates.Shapes.CircleShapeTemplate",{inherits:[VelcroPhysics.Templates.Shapes.ShapeTemplate],fields:{Position:null},ctors:{init:function(){this.Position=new Microsoft.Xna.Framework.Vector2},ctor:function(){this.$initialize();VelcroPhysics.Templates.Shapes.ShapeTemplate.ctor.call(this,VelcroPhysics.Collision.Shapes.ShapeType.Circle)}}});Bridge.define("VelcroPhysics.Templates.Shapes.EdgeShapeTemplate",{inherits:[VelcroPhysics.Templates.Shapes.ShapeTemplate],fields:{HasVertex0:!1,HasVertex3:!1,Vertex0:null,Vertex1:null,Vertex2:null,Vertex3:null},ctors:{init:function(){this.Vertex0=new Microsoft.Xna.Framework.Vector2;this.Vertex1=new Microsoft.Xna.Framework.Vector2;this.Vertex2=new Microsoft.Xna.Framework.Vector2;this.Vertex3=new Microsoft.Xna.Framework.Vector2},ctor:function(){this.$initialize();VelcroPhysics.Templates.Shapes.ShapeTemplate.ctor.call(this,VelcroPhysics.Collision.Shapes.ShapeType.Edge)}}});Bridge.define("VelcroPhysics.Templates.Shapes.PolygonShapeTemplate",{inherits:[VelcroPhysics.Templates.Shapes.ShapeTemplate],fields:{Vertices:null},ctors:{ctor:function(){this.$initialize();VelcroPhysics.Templates.Shapes.ShapeTemplate.ctor.call(this,VelcroPhysics.Collision.Shapes.ShapeType.Polygon)}}});Bridge.define("VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweepConstraint",{inherits:[VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationConstraint],ctors:{ctor:function(p1,p2){this.$initialize();VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationConstraint.ctor.call(this);this.P=p1;this.Q=p2;p1.Y>p2.Y?(this.Q=p1,this.P=p2):p1.Y===p2.Y&&(p1.X>p2.X?(this.Q=p1,this.P=p2):p1.X===p2.X);this.Q.AddEdge(this)}}});Bridge.define("VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweepContext",{inherits:[VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationContext],statics:{fields:{ALPHA:0},ctors:{init:function(){this.ALPHA=.3}}},fields:{_comparator:null,aFront:null,Basin:null,EdgeEvent:null,Head:null,Tail:null},ctors:{init:function(){this._comparator=new VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweepPointComparator;this.Basin=new VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweepContext.DTSweepBasin;this.EdgeEvent=new VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweepContext.DTSweepEdgeEvent},ctor:function(){this.$initialize();VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationContext.ctor.call(this);this.Clear()}},methods:{RemoveFromList:function(triangle){this.Triangles.remove(triangle)},MeshClean:function(triangle){this.MeshCleanReq(triangle)},MeshCleanReq:function(triangle){if(triangle!=null&&!triangle.IsInterior){triangle.IsInterior=!0;this.Triangulatable.VelcroPhysics$Tools$Triangulation$Delaunay$Triangulatable$AddTriangle(triangle);for(var i=0;i<3;i=i+1|0)triangle.EdgeIsConstrained.getItem(i)||this.MeshCleanReq(triangle.Neighbors.getItem(i))}},Clear:function(){VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationContext.prototype.Clear.call(this);this.Triangles.clear()},AddNode:function(node){this.aFront.AddNode(node)},RemoveNode:function(node){this.aFront.RemoveNode(node)},LocateNode:function(point){return this.aFront.LocateNode(point)},CreateAdvancingFront:function(){var head,tail,middle,iTriangle=new VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle(this.Points.getItem(0),this.Tail,this.Head);this.Triangles.add(iTriangle);head=new VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode(iTriangle.Points.getItem(1));head.Triangle=iTriangle;middle=new VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode(iTriangle.Points.getItem(0));middle.Triangle=iTriangle;tail=new VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFrontNode(iTriangle.Points.getItem(2));this.aFront=new VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.AdvancingFront(head,tail);this.aFront.AddNode(middle);this.aFront.Head.Next=middle;middle.Next=this.aFront.Tail;middle.Prev=this.aFront.Head;this.aFront.Tail.Prev=middle},MapTriangleToNodes:function(t){for(var n,i=0;i<3;i=i+1|0)t.Neighbors.getItem(i)==null&&(n=this.aFront.LocatePoint(t.PointCW(t.Points.getItem(i))),n!=null&&(n.Triangle=t))},PrepareTriangulation:function(t){var $t,xmax,xmin,ymax,ymin,p;VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationContext.prototype.PrepareTriangulation.call(this,t);xmax=xmin=this.Points.getItem(0).X;ymax=ymin=this.Points.getItem(0).Y;$t=Bridge.getEnumerator(this.Points);try{while($t.moveNext())p=$t.Current,p.X>xmax&&(xmax=p.X),p.X<xmin&&(xmin=p.X),p.Y>ymax&&(ymax=p.Y),p.Y<ymin&&(ymin=p.Y)}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}var deltaX=VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweepContext.ALPHA*(xmax-xmin),deltaY=VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweepContext.ALPHA*(ymax-ymin),p1=new VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationPoint(xmax+deltaX,ymin-deltaY),p2=new VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationPoint(xmin-deltaX,ymin-deltaY);this.Head=p1;this.Tail=p2;this.Points.Sort$1(this._comparator)},FinalizeTriangulation:function(){this.Triangulatable.VelcroPhysics$Tools$Triangulation$Delaunay$Triangulatable$AddTriangles(this.Triangles);this.Triangles.clear()},NewConstraint:function(a,b){return new VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweepConstraint(a,b)}}});Bridge.define("VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.Sweep.DTSweepPointComparator",{inherits:[System.Collections.Generic.IComparer$1(VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationPoint)],alias:["compare",["System$Collections$Generic$IComparer$1$VelcroPhysics$Tools$Triangulation$Delaunay$TriangulationPoint$compare","System$Collections$Generic$IComparer$1$compare"]],methods:{compare:function(p1,p2){return p1.Y<p2.Y?-1:p1.Y>p2.Y?1:p1.X<p2.X?-1:p1.X>p2.X?1:0}}});Bridge.define("VelcroPhysics.Tools.Triangulation.Delaunay.Polygon.Polygon",{inherits:[VelcroPhysics.Tools.Triangulation.Delaunay.Triangulatable],fields:{_holes:null,_last:null,_points:null,_steinerPoints:null,_triangles:null},props:{Holes:{get:function(){return this._holes}},TriangulationMode:{get:function(){return VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationMode.Polygon}},Points:{get:function(){return this._points}},Triangles:{get:function(){return this._triangles}}},alias:["TriangulationMode","VelcroPhysics$Tools$Triangulation$Delaunay$Triangulatable$TriangulationMode","Points","VelcroPhysics$Tools$Triangulation$Delaunay$Triangulatable$Points","Triangles","VelcroPhysics$Tools$Triangulation$Delaunay$Triangulatable$Triangles","AddTriangle","VelcroPhysics$Tools$Triangulation$Delaunay$Triangulatable$AddTriangle","AddTriangles","VelcroPhysics$Tools$Triangulation$Delaunay$Triangulatable$AddTriangles","ClearTriangles","VelcroPhysics$Tools$Triangulation$Delaunay$Triangulatable$ClearTriangles","PrepareTriangulation","VelcroPhysics$Tools$Triangulation$Delaunay$Triangulatable$PrepareTriangulation"],ctors:{init:function(){this._points=new(System.Collections.Generic.List$1(VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationPoint).ctor)},$ctor2:function(points){if(this.$initialize(),System.Array.getCount(points,VelcroPhysics.Tools.Triangulation.Delaunay.Polygon.PolygonPoint)<3)throw new System.ArgumentException.$ctor3("List has fewer than 3 points","points");Bridge.equals(System.Array.getItem(points,0,VelcroPhysics.Tools.Triangulation.Delaunay.Polygon.PolygonPoint),System.Array.getItem(points,System.Array.getCount(points,VelcroPhysics.Tools.Triangulation.Delaunay.Polygon.PolygonPoint)-1|0,VelcroPhysics.Tools.Triangulation.Delaunay.Polygon.PolygonPoint))&&System.Array.removeAt(points,System.Array.getCount(points,VelcroPhysics.Tools.Triangulation.Delaunay.Polygon.PolygonPoint)-1|0,VelcroPhysics.Tools.Triangulation.Delaunay.Polygon.PolygonPoint);this._points.AddRange(System.Linq.Enumerable.from(points).select(function(x){return Bridge.cast(x,VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationPoint)}))},$ctor1:function(points){VelcroPhysics.Tools.Triangulation.Delaunay.Polygon.Polygon.$ctor2.call(this,Bridge.as(points,System.Collections.Generic.IList$1(VelcroPhysics.Tools.Triangulation.Delaunay.Polygon.PolygonPoint))||System.Linq.Enumerable.from(points).ToArray())},ctor:function(){this.$initialize()}},methods:{AddSteinerPoint:function(point){this._steinerPoints==null&&(this._steinerPoints=new(System.Collections.Generic.List$1(VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationPoint).ctor));this._steinerPoints.add(point)},AddSteinerPoints:function(points){this._steinerPoints==null&&(this._steinerPoints=new(System.Collections.Generic.List$1(VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationPoint).ctor));this._steinerPoints.AddRange(points)},ClearSteinerPoints:function(){this._steinerPoints!=null&&this._steinerPoints.clear()},AddHole:function(poly){this._holes==null&&(this._holes=new(System.Collections.Generic.List$1(VelcroPhysics.Tools.Triangulation.Delaunay.Polygon.Polygon).ctor));this._holes.add(poly)},InsertPointAfter:function(point,newPoint){var index=this._points.indexOf(point);if(index===-1)throw new System.ArgumentException.$ctor3("Tried to insert a point into a Polygon after a point not belonging to the Polygon","point");newPoint.Next=point.Next;newPoint.Previous=point;point.Next.Previous=newPoint;point.Next=newPoint;this._points.insert(index+1|0,newPoint)},AddPoints:function(list){var $t,first,p;$t=Bridge.getEnumerator(list,VelcroPhysics.Tools.Triangulation.Delaunay.Polygon.PolygonPoint);try{while($t.moveNext())p=$t.Current,p.Previous=this._last,this._last!=null&&(p.Next=this._last.Next,this._last.Next=p),this._last=p,this._points.add(p)}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}first=Bridge.cast(this._points.getItem(0),VelcroPhysics.Tools.Triangulation.Delaunay.Polygon.PolygonPoint);this._last.Next=first;first.Previous=this._last},AddPoint:function(p){p.Previous=this._last;p.Next=this._last.Next;this._last.Next=p;this._points.add(p)},RemovePoint:function(p){var next,prev;next=p.Next;prev=p.Previous;prev.Next=next;next.Previous=prev;this._points.remove(p)},AddTriangle:function(t){this._triangles.add(t)},AddTriangles:function(list){this._triangles.AddRange(list)},ClearTriangles:function(){this._triangles!=null&&this._triangles.clear()},PrepareTriangulation:function(tcx){var $t,i,p,i1;for(this._triangles==null?this._triangles=new(System.Collections.Generic.List$1(VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle).$ctor2)(this._points.Count):this._triangles.clear(),i=0;i<(this._points.Count-1|0);i=i+1|0)tcx.NewConstraint(this._points.getItem(i),this._points.getItem(i+1|0));if(tcx.NewConstraint(this._points.getItem(0),this._points.getItem(this._points.Count-1|0)),tcx.Points.AddRange(this._points),this._holes!=null){$t=Bridge.getEnumerator(this._holes);try{while($t.moveNext()){for(p=$t.Current,i1=0;i1<(p._points.Count-1|0);i1=i1+1|0)tcx.NewConstraint(p._points.getItem(i1),p._points.getItem(i1+1|0));tcx.NewConstraint(p._points.getItem(0),p._points.getItem(p._points.Count-1|0));tcx.Points.AddRange(p._points)}}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}}this._steinerPoints!=null&&tcx.Points.AddRange(this._steinerPoints)}}});Bridge.define("VelcroPhysics.Tools.Triangulation.Delaunay.Polygon.PolygonPoint",{inherits:[VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationPoint],fields:{Next:null,Previous:null},ctors:{ctor:function(x,y){this.$initialize();VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationPoint.ctor.call(this,x,y)}}});Bridge.define("VelcroPhysics.Tools.Triangulation.Delaunay.Sets.PointSet",{inherits:[VelcroPhysics.Tools.Triangulation.Delaunay.Triangulatable],fields:{Points:null,Triangles:null},props:{TriangulationMode:{get:function(){return VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationMode.Unconstrained}}},alias:["Points","VelcroPhysics$Tools$Triangulation$Delaunay$Triangulatable$Points","Triangles","VelcroPhysics$Tools$Triangulation$Delaunay$Triangulatable$Triangles","TriangulationMode","VelcroPhysics$Tools$Triangulation$Delaunay$Triangulatable$TriangulationMode","AddTriangle","VelcroPhysics$Tools$Triangulation$Delaunay$Triangulatable$AddTriangle","AddTriangles","VelcroPhysics$Tools$Triangulation$Delaunay$Triangulatable$AddTriangles","ClearTriangles","VelcroPhysics$Tools$Triangulation$Delaunay$Triangulatable$ClearTriangles","PrepareTriangulation","VelcroPhysics$Tools$Triangulation$Delaunay$Triangulatable$PrepareTriangulation"],ctors:{ctor:function(points){this.$initialize();this.Points=new(System.Collections.Generic.List$1(VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationPoint).$ctor1)(points)}},methods:{AddTriangle:function(t){System.Array.add(this.Triangles,t,VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle)},AddTriangles:function(list){var $t,tri;$t=Bridge.getEnumerator(list,VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle);try{while($t.moveNext())tri=$t.Current,System.Array.add(this.Triangles,tri,VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle)}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}},ClearTriangles:function(){System.Array.clear(this.Triangles,VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle)},PrepareTriangulation:function(tcx){this.Triangles==null?this.Triangles=new(System.Collections.Generic.List$1(VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle).$ctor2)(System.Array.getCount(this.Points,VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationPoint)):System.Array.clear(this.Triangles,VelcroPhysics.Tools.Triangulation.Delaunay.Delaunay.DelaunayTriangle);tcx.Points.AddRange(this.Points)}}});Bridge.define("VelcroPhysics.Tools.Triangulation.Earclip.Triangle",{inherits:[VelcroPhysics.Shared.Vertices],ctors:{ctor:function(x1,y1,x2,y2,x3,y3){this.$initialize();VelcroPhysics.Shared.Vertices.ctor.call(this);var cross=(x2-x1)*(y3-y1)-(x3-x1)*(y2-y1);cross>0?(this.add(new Microsoft.Xna.Framework.Vector2.$ctor2(x1,y1)),this.add(new Microsoft.Xna.Framework.Vector2.$ctor2(x2,y2)),this.add(new Microsoft.Xna.Framework.Vector2.$ctor2(x3,y3))):(this.add(new Microsoft.Xna.Framework.Vector2.$ctor2(x1,y1)),this.add(new Microsoft.Xna.Framework.Vector2.$ctor2(x3,y3)),this.add(new Microsoft.Xna.Framework.Vector2.$ctor2(x2,y2)))}},methods:{IsInside:function(x,y){var a=this.getItem(0).$clone(),b=this.getItem(1).$clone(),c=this.getItem(2).$clone();if(x<a.X&&x<b.X&&x<c.X||x>a.X&&x>b.X&&x>c.X||y<a.Y&&y<b.Y&&y<c.Y||y>a.Y&&y>b.Y&&y>c.Y)return!1;var vx2=x-a.X,vy2=y-a.Y,vx1=b.X-a.X,vy1=b.Y-a.Y,vx0=c.X-a.X,vy0=c.Y-a.Y,dot00=vx0*vx0+vy0*vy0,dot01=vx0*vx1+vy0*vy1,dot02=vx0*vx2+vy0*vy2,dot11=vx1*vx1+vy1*vy1,dot12=vx1*vx2+vy1*vy2,invDenom=1/(dot00*dot11-dot01*dot01),u=(dot11*dot02-dot01*dot12)*invDenom,v=(dot00*dot12-dot01*dot02)*invDenom;return u>0&&v>0&&u+v<1}}});Bridge.define("VelcroPhysics.Tools.Triangulation.Seidel.Sink",{inherits:[VelcroPhysics.Tools.Triangulation.Seidel.Node],statics:{methods:{Isink:function(trapezoid){return trapezoid.Sink==null?new VelcroPhysics.Tools.Triangulation.Seidel.Sink(trapezoid):trapezoid.Sink}}},fields:{Trapezoid:null},ctors:{ctor:function(trapezoid){this.$initialize();VelcroPhysics.Tools.Triangulation.Seidel.Node.ctor.call(this,null,null);this.Trapezoid=trapezoid;trapezoid.Sink=this}},methods:{Locate:function(edge){return this}}});Bridge.define("VelcroPhysics.Tools.Triangulation.Seidel.XNode",{inherits:[VelcroPhysics.Tools.Triangulation.Seidel.Node],fields:{_point:null},ctors:{ctor:function(point,lChild,rChild){this.$initialize();VelcroPhysics.Tools.Triangulation.Seidel.Node.ctor.call(this,lChild,rChild);this._point=point}},methods:{Locate:function(edge){return edge.P.X>=this._point.X?this.RightChild.Locate(edge):this.LeftChild.Locate(edge)}}});Bridge.define("VelcroPhysics.Tools.Triangulation.Seidel.YNode",{inherits:[VelcroPhysics.Tools.Triangulation.Seidel.Node],fields:{_edge:null},ctors:{ctor:function(edge,lChild,rChild){this.$initialize();VelcroPhysics.Tools.Triangulation.Seidel.Node.ctor.call(this,lChild,rChild);this._edge=edge}},methods:{Locate:function(edge){return this._edge.IsAbove(edge.P)?this.RightChild.Locate(edge):this._edge.IsBelow(edge.P)?this.LeftChild.Locate(edge):edge.Slope<this._edge.Slope?this.RightChild.Locate(edge):this.LeftChild.Locate(edge)}}});Bridge.define("VelcroPhysics.Extensions.Controllers.Buoyancy.BuoyancyController",{inherits:[VelcroPhysics.Extensions.Controllers.ControllerBase.Controller],fields:{_container:null,_gravity:null,_normal:null,_offset:0,_uniqueBodies:null,AngularDragCoefficient:0,Density:0,LinearDragCoefficient:0,Velocity:null},props:{Container:{get:function(){return this._container.$clone()},set:function(value){this._container=value.$clone();this._offset=this._container.UpperBound.Y}}},ctors:{init:function(){this._container=new VelcroPhysics.Shared.AABB;this._gravity=new Microsoft.Xna.Framework.Vector2;this._normal=new Microsoft.Xna.Framework.Vector2;this.Velocity=new Microsoft.Xna.Framework.Vector2;this._uniqueBodies=new(System.Collections.Generic.Dictionary$2(System.Int32,VelcroPhysics.Dynamics.Body))},ctor:function(container,density,linearDragCoefficient,rotationalDragCoefficient,gravity){this.$initialize();VelcroPhysics.Extensions.Controllers.ControllerBase.Controller.ctor.call(this,VelcroPhysics.Extensions.Controllers.ControllerBase.ControllerType.BuoyancyController);this.Container=container.$clone();this._normal=new Microsoft.Xna.Framework.Vector2.$ctor2(0,1);this.Density=density;this.LinearDragCoefficient=linearDragCoefficient;this.AngularDragCoefficient=rotationalDragCoefficient;this._gravity=gravity.$clone()}},methods:{Update:function(dt){var $t,j,fixture,buoyancyForce,dragForce;this._uniqueBodies.clear();this.World.QueryAABB$1(Bridge.fn.bind(this,function(fixture){return fixture.Body.IsStatic||!fixture.Body.Awake?!0:(this._uniqueBodies.containsKey(fixture.Body.BodyId)||this._uniqueBodies.add(fixture.Body.BodyId,fixture.Body),!0)}),Bridge.ref(this,"_container"));$t=Bridge.getEnumerator(this._uniqueBodies);try{while($t.moveNext()){var kv=$t.Current,body=kv.value,areac=Microsoft.Xna.Framework.Vector2.Zero.$clone(),massc=Microsoft.Xna.Framework.Vector2.Zero.$clone(),area=0,mass=0;for(j=0;j<body.FixtureList.Count;j=j+1|0)if(fixture=body.FixtureList.getItem(j),fixture.Shape.ShapeType===VelcroPhysics.Collision.Shapes.ShapeType.Polygon||fixture.Shape.ShapeType===VelcroPhysics.Collision.Shapes.ShapeType.Circle){var shape=fixture.Shape,sc={v:new Microsoft.Xna.Framework.Vector2},sarea=this.ComputeSubmergedArea(shape,Bridge.ref(this,"_normal"),this._offset,Bridge.ref(body,"_xf"),sc);area+=sarea;areac.X+=sarea*sc.v.X;areac.Y+=sarea*sc.v.Y;mass+=sarea*shape.Density;massc.X+=sarea*sc.v.X*shape.Density;massc.Y+=sarea*sc.v.Y*shape.Density}(areac.X/=area,areac.Y/=area,massc.X/=mass,massc.Y/=mass,area<VelcroPhysics.Settings.Epsilon)||(buoyancyForce=Microsoft.Xna.Framework.Vector2.op_Multiply$2(-this.Density*area,this._gravity.$clone()),body.ApplyForce$1(buoyancyForce.$clone(),massc.$clone()),dragForce=Microsoft.Xna.Framework.Vector2.op_Subtraction(body.GetLinearVelocityFromWorldPoint(areac.$clone()),this.Velocity.$clone()),dragForce=Microsoft.Xna.Framework.Vector2.op_Multiply$1(dragForce.$clone(),-this.LinearDragCoefficient*area),body.ApplyForce$1(dragForce.$clone(),areac.$clone()),body.ApplyTorque(-body.Inertia/body.Mass*area*body.AngularVelocity*this.AngularDragCoefficient))}}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}},ComputeSubmergedArea:function(shape,normal,offset,xf,sc){var circleShape,p,l,isSubmerged,p3;switch(shape.ShapeType){case VelcroPhysics.Collision.Shapes.ShapeType.Circle:if(circleShape=Bridge.cast(shape,VelcroPhysics.Collision.Shapes.CircleShape),sc.v=Microsoft.Xna.Framework.Vector2.Zero.$clone(),p=VelcroPhysics.Utilities.MathUtils.Mul$4(xf,circleShape.Position.$clone()),l=-(Microsoft.Xna.Framework.Vector2.Dot(normal.v.$clone(),p.$clone())-offset),l<-circleShape.Radius+VelcroPhysics.Settings.Epsilon)return 0;if(l>circleShape.Radius)return sc.v=p.$clone(),VelcroPhysics.Settings.Pi*circleShape._2radius;var l2=l*l,area=circleShape._2radius*(Math.asin(l/circleShape.Radius)+1.57079637+l*Math.sqrt(circleShape._2radius-l2)),com=-.6666667*Math.pow(circleShape._2radius-l2,1.5)/area;return sc.v.X=p.X+normal.v.X*com,sc.v.Y=p.Y+normal.v.Y*com,area;case VelcroPhysics.Collision.Shapes.ShapeType.Edge:return sc.v=Microsoft.Xna.Framework.Vector2.Zero.$clone(),0;case VelcroPhysics.Collision.Shapes.ShapeType.Polygon:sc.v=Microsoft.Xna.Framework.Vector2.Zero.$clone();for(var polygonShape=Bridge.cast(shape,VelcroPhysics.Collision.Shapes.PolygonShape),normalL=VelcroPhysics.Utilities.MathUtils.MulT$2(xf.v.q.$clone(),normal.v.$clone()),offsetL=offset-Microsoft.Xna.Framework.Vector2.Dot(normal.v.$clone(),xf.v.p.$clone()),depths=System.Array.init(new Float32Array(VelcroPhysics.Settings.MaxPolygonVertices),System.Single),diveCount=0,intoIndex=-1,outoIndex=-1,lastSubmerged=!1,i=0;i<polygonShape.Vertices.Count;i=i+1|0)depths[i]=Microsoft.Xna.Framework.Vector2.Dot(normalL.$clone(),polygonShape.Vertices.getItem(i).$clone())-offsetL,isSubmerged=depths[i]<-11920929e-14,i>0&&(isSubmerged?lastSubmerged||(intoIndex=i-1|0,diveCount=diveCount+1|0):lastSubmerged&&(outoIndex=i-1|0,diveCount=diveCount+1|0)),lastSubmerged=isSubmerged;switch(diveCount){case 0:return lastSubmerged?(sc.v=VelcroPhysics.Utilities.MathUtils.Mul$4(xf,polygonShape.MassData.Centroid.$clone()),polygonShape.MassData.Mass/this.Density):0;case 1:intoIndex===-1?intoIndex=polygonShape.Vertices.Count-1|0:outoIndex=polygonShape.Vertices.Count-1|0;break}var intoIndex2=(intoIndex+1|0)%polygonShape.Vertices.Count,outoIndex2=(outoIndex+1|0)%polygonShape.Vertices.Count,intoLambda=(0-depths[intoIndex])/(depths[intoIndex2]-depths[intoIndex]),outoLambda=(0-depths[outoIndex])/(depths[outoIndex2]-depths[outoIndex]),intoVec=new Microsoft.Xna.Framework.Vector2.$ctor2(polygonShape.Vertices.getItem(intoIndex).$clone().X*(1-intoLambda)+polygonShape.Vertices.getItem(intoIndex2).$clone().X*intoLambda,polygonShape.Vertices.getItem(intoIndex).$clone().Y*(1-intoLambda)+polygonShape.Vertices.getItem(intoIndex2).$clone().Y*intoLambda),outoVec=new Microsoft.Xna.Framework.Vector2.$ctor2(polygonShape.Vertices.getItem(outoIndex).$clone().X*(1-outoLambda)+polygonShape.Vertices.getItem(outoIndex2).$clone().X*outoLambda,polygonShape.Vertices.getItem(outoIndex).$clone().Y*(1-outoLambda)+polygonShape.Vertices.getItem(outoIndex2).$clone().Y*outoLambda),area1=0,center=new Microsoft.Xna.Framework.Vector2.$ctor2(0,0),p2=polygonShape.Vertices.getItem(intoIndex2).$clone(),k_inv3=.333333343;for(i=intoIndex2;i!==outoIndex2;){i=(i+1|0)%polygonShape.Vertices.Count;p3=new Microsoft.Xna.Framework.Vector2;p3=i===outoIndex2?outoVec.$clone():polygonShape.Vertices.getItem(i).$clone();var e1=Microsoft.Xna.Framework.Vector2.op_Subtraction(p2.$clone(),intoVec.$clone()),e2=Microsoft.Xna.Framework.Vector2.op_Subtraction(p3.$clone(),intoVec.$clone()),D=VelcroPhysics.Utilities.MathUtils.Cross$3(e1.$clone(),e2.$clone()),triangleArea=.5*D;area1+=triangleArea;center=Microsoft.Xna.Framework.Vector2.op_Addition(center.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(triangleArea*k_inv3,Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Addition(intoVec.$clone(),p2.$clone()),p3.$clone())));p2=p3.$clone()}return center=Microsoft.Xna.Framework.Vector2.op_Multiply$1(center.$clone(),1/area1),sc.v=VelcroPhysics.Utilities.MathUtils.Mul$4(xf,center.$clone()),area1;case VelcroPhysics.Collision.Shapes.ShapeType.Chain:return sc.v=Microsoft.Xna.Framework.Vector2.Zero.$clone(),0;case VelcroPhysics.Collision.Shapes.ShapeType.Unknown:case VelcroPhysics.Collision.Shapes.ShapeType.TypeCount:throw new System.NotSupportedException.ctor;default:throw new System.ArgumentOutOfRangeException.ctor;}}}});Bridge.define("VelcroPhysics.Extensions.Controllers.Gravity.GravityController",{inherits:[VelcroPhysics.Extensions.Controllers.ControllerBase.Controller],fields:{MinRadius:0,MaxRadius:0,Strength:0,GravityType:0,Bodies:null,Points:null},ctors:{ctor:function(strength){this.$initialize();VelcroPhysics.Extensions.Controllers.ControllerBase.Controller.ctor.call(this,VelcroPhysics.Extensions.Controllers.ControllerBase.ControllerType.GravityController);this.Strength=strength;this.MaxRadius=340282347e30;this.GravityType=VelcroPhysics.Extensions.Controllers.Gravity.GravityType.DistanceSquared;this.Points=new(System.Collections.Generic.List$1(Microsoft.Xna.Framework.Vector2).ctor);this.Bodies=new(System.Collections.Generic.List$1(VelcroPhysics.Dynamics.Body).ctor)},$ctor1:function(strength,maxRadius,minRadius){this.$initialize();VelcroPhysics.Extensions.Controllers.ControllerBase.Controller.ctor.call(this,VelcroPhysics.Extensions.Controllers.ControllerBase.ControllerType.GravityController);this.MinRadius=minRadius;this.MaxRadius=maxRadius;this.Strength=strength;this.GravityType=VelcroPhysics.Extensions.Controllers.Gravity.GravityType.DistanceSquared;this.Points=new(System.Collections.Generic.List$1(Microsoft.Xna.Framework.Vector2).ctor);this.Bodies=new(System.Collections.Generic.List$1(VelcroPhysics.Dynamics.Body).ctor)}},methods:{Update:function(dt){var $t,$t1,$t2,f={v:Microsoft.Xna.Framework.Vector2.Zero.$clone()},worldBody,controllerBody,d,r2;$t=Bridge.getEnumerator(this.World.BodyList);try{while($t.moveNext())if(worldBody=$t.Current,this.IsActiveOn(worldBody)){$t1=Bridge.getEnumerator(this.Bodies);try{while($t1.moveNext())if((controllerBody=$t1.Current,!Bridge.referenceEquals(worldBody,controllerBody)&&(!worldBody.IsStatic||!controllerBody.IsStatic)&&controllerBody.Enabled)&&(d=Microsoft.Xna.Framework.Vector2.op_Subtraction(controllerBody.Position.$clone(),worldBody.Position.$clone()),r2=d.LengthSquared(),!(r2<=VelcroPhysics.Settings.Epsilon)&&!(r2>this.MaxRadius*this.MaxRadius)&&!(r2<this.MinRadius*this.MinRadius))){switch(this.GravityType){case VelcroPhysics.Extensions.Controllers.Gravity.GravityType.DistanceSquared:f.v=Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.Strength/r2*worldBody.Mass*controllerBody.Mass,d.$clone());break;case VelcroPhysics.Extensions.Controllers.Gravity.GravityType.Linear:f.v=Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.Strength/Math.sqrt(r2)*worldBody.Mass*controllerBody.Mass,d.$clone());break}worldBody.ApplyForce$2(f)}}finally{Bridge.is($t1,System.IDisposable)&&$t1.System$IDisposable$Dispose()}$t2=Bridge.getEnumerator(this.Points);try{while($t2.moveNext()){var point=$t2.Current.$clone(),d1=Microsoft.Xna.Framework.Vector2.op_Subtraction(point.$clone(),worldBody.Position.$clone()),r21=d1.LengthSquared();if(!(r21<=VelcroPhysics.Settings.Epsilon)&&!(r21>this.MaxRadius*this.MaxRadius)&&!(r21<this.MinRadius*this.MinRadius)){switch(this.GravityType){case VelcroPhysics.Extensions.Controllers.Gravity.GravityType.DistanceSquared:f.v=Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.Strength/r21*worldBody.Mass,d1.$clone());break;case VelcroPhysics.Extensions.Controllers.Gravity.GravityType.Linear:f.v=Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.Strength/Math.sqrt(r21)*worldBody.Mass,d1.$clone());break}worldBody.ApplyForce$2(f)}}}finally{Bridge.is($t2,System.IDisposable)&&$t2.System$IDisposable$Dispose()}}}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}},AddBody:function(body){this.Bodies.add(body)},AddPoint:function(point){this.Points.add(point.$clone())}}});Bridge.define("VelcroPhysics.Extensions.Controllers.Velocity.VelocityLimitController",{inherits:[VelcroPhysics.Extensions.Controllers.ControllerBase.Controller],fields:{_bodies:null,_maxAngularSqared:0,_maxAngularVelocity:0,_maxLinearSqared:0,_maxLinearVelocity:0,LimitAngularVelocity:!1,LimitLinearVelocity:!1},props:{MaxAngularVelocity:{get:function(){return this._maxAngularVelocity},set:function(value){this._maxAngularVelocity=value;this._maxAngularSqared=this._maxAngularVelocity*this._maxAngularVelocity}},MaxLinearVelocity:{get:function(){return this._maxLinearVelocity},set:function(value){this._maxLinearVelocity=value;this._maxLinearSqared=this._maxLinearVelocity*this._maxLinearVelocity}}},ctors:{init:function(){this._bodies=new(System.Collections.Generic.List$1(VelcroPhysics.Dynamics.Body).ctor);this.LimitAngularVelocity=!0;this.LimitLinearVelocity=!0},ctor:function(){this.$initialize();VelcroPhysics.Extensions.Controllers.ControllerBase.Controller.ctor.call(this,VelcroPhysics.Extensions.Controllers.ControllerBase.ControllerType.VelocityLimitController);this.MaxLinearVelocity=VelcroPhysics.Settings.MaxTranslation;this.MaxAngularVelocity=VelcroPhysics.Settings.MaxRotation},$ctor1:function(maxLinearVelocity,maxAngularVelocity){this.$initialize();VelcroPhysics.Extensions.Controllers.ControllerBase.Controller.ctor.call(this,VelcroPhysics.Extensions.Controllers.ControllerBase.ControllerType.VelocityLimitController);(maxLinearVelocity===0||maxLinearVelocity===340282347e30)&&(this.LimitLinearVelocity=!1);(maxAngularVelocity===0||maxAngularVelocity===340282347e30)&&(this.LimitAngularVelocity=!1);this.MaxLinearVelocity=maxLinearVelocity;this.MaxAngularVelocity=maxAngularVelocity}},methods:{Update:function(dt){var $t,body,sq,ratio,rotation,ratio1;$t=Bridge.getEnumerator(this._bodies);try{while($t.moveNext())if(body=$t.Current,this.IsActiveOn(body)){if(this.LimitLinearVelocity){var translationX=dt*body._linearVelocity.X,translationY=dt*body._linearVelocity.Y,result=translationX*translationX+translationY*translationY;result>dt*this._maxLinearSqared&&(sq=Math.sqrt(result),ratio=this._maxLinearVelocity/sq,body._linearVelocity.X*=ratio,body._linearVelocity.Y*=ratio)}this.LimitAngularVelocity&&(rotation=dt*body._angularVelocity,rotation*rotation>this._maxAngularSqared&&(ratio1=this._maxAngularVelocity/Math.abs(rotation),body._angularVelocity*=ratio1))}}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}},AddBody:function(body){this._bodies.add(body)},RemoveBody:function(body){this._bodies.remove(body)}}});Bridge.define("VelcroPhysics.Extensions.Controllers.Wind.AbstractForceController",{inherits:[VelcroPhysics.Extensions.Controllers.ControllerBase.Controller],fields:{DecayCurve:null,ForceType:0,Randomize:null,StrengthCurve:null,Strength:0,Position:null,MaximumSpeed:0,MaximumForce:0,TimingMode:0,ImpulseTime:0,ImpulseLength:0,Triggered:!1,Variation:0,DecayMode:0,DecayStart:0,DecayEnd:0},ctors:{init:function(){this.Position=new Microsoft.Xna.Framework.Vector2},ctor:function(){this.$initialize();VelcroPhysics.Extensions.Controllers.ControllerBase.Controller.ctor.call(this,VelcroPhysics.Extensions.Controllers.ControllerBase.ControllerType.AbstractForceController);this.Enabled=!0;this.Strength=1;this.Position=new Microsoft.Xna.Framework.Vector2.$ctor2(0,0);this.MaximumSpeed=100;this.TimingMode=VelcroPhysics.Extensions.Controllers.Wind.AbstractForceController.TimingModes.Switched;this.ImpulseTime=0;this.ImpulseLength=1;this.Triggered=!1;this.StrengthCurve=new Microsoft.Xna.Framework.Curve;this.Variation=0;this.Randomize=new System.Random.$ctor1(1234);this.DecayMode=VelcroPhysics.Extensions.Controllers.Wind.AbstractForceController.DecayModes.None;this.DecayCurve=new Microsoft.Xna.Framework.Curve;this.DecayStart=0;this.DecayEnd=0;this.StrengthCurve.Keys.add(new Microsoft.Xna.Framework.CurveKey.$ctor1(0,5));this.StrengthCurve.Keys.add(new Microsoft.Xna.Framework.CurveKey.$ctor1(.1,5));this.StrengthCurve.Keys.add(new Microsoft.Xna.Framework.CurveKey.$ctor1(.2,-4));this.StrengthCurve.Keys.add(new Microsoft.Xna.Framework.CurveKey.$ctor1(1,0))},$ctor1:function(mode){this.$initialize();VelcroPhysics.Extensions.Controllers.ControllerBase.Controller.ctor.call(this,VelcroPhysics.Extensions.Controllers.ControllerBase.ControllerType.AbstractForceController);this.TimingMode=mode;switch(mode){case VelcroPhysics.Extensions.Controllers.Wind.AbstractForceController.TimingModes.Switched:this.Enabled=!0;break;case VelcroPhysics.Extensions.Controllers.Wind.AbstractForceController.TimingModes.Triggered:this.Enabled=!1;break;case VelcroPhysics.Extensions.Controllers.Wind.AbstractForceController.TimingModes.Curve:this.Enabled=!1;break}}},methods:{GetDecayMultiplier:function(body){var distance=Microsoft.Xna.Framework.Vector2.op_Subtraction(body.Position.$clone(),this.Position.$clone()).Length();switch(this.DecayMode){case VelcroPhysics.Extensions.Controllers.Wind.AbstractForceController.DecayModes.None:return 1;case VelcroPhysics.Extensions.Controllers.Wind.AbstractForceController.DecayModes.Step:return distance<this.DecayEnd?1:0;case VelcroPhysics.Extensions.Controllers.Wind.AbstractForceController.DecayModes.Linear:return distance<this.DecayStart?1:distance>this.DecayEnd?0:this.DecayEnd-this.DecayStart/distance-this.DecayStart;case VelcroPhysics.Extensions.Controllers.Wind.AbstractForceController.DecayModes.InverseSquare:return distance<this.DecayStart?1:1/((distance-this.DecayStart)*(distance-this.DecayStart));case VelcroPhysics.Extensions.Controllers.Wind.AbstractForceController.DecayModes.Curve:return distance<this.DecayStart?1:this.DecayCurve.Evaluate(distance-this.DecayStart);default:return 1}},Trigger:function(){this.Triggered=!0;this.ImpulseTime=0},Update:function(dt){switch(this.TimingMode){case VelcroPhysics.Extensions.Controllers.Wind.AbstractForceController.TimingModes.Switched:this.Enabled&&this.ApplyForce(dt,this.Strength);break;case VelcroPhysics.Extensions.Controllers.Wind.AbstractForceController.TimingModes.Triggered:this.Enabled&&this.Triggered&&(this.ImpulseTime<this.ImpulseLength?(this.ApplyForce(dt,this.Strength),this.ImpulseTime+=dt):this.Triggered=!1);break;case VelcroPhysics.Extensions.Controllers.Wind.AbstractForceController.TimingModes.Curve:this.Enabled&&this.Triggered&&(this.ImpulseTime<this.ImpulseLength?(this.ApplyForce(dt,this.Strength*this.StrengthCurve.Evaluate(this.ImpulseTime)),this.ImpulseTime+=dt):this.Triggered=!1);break}}}});Bridge.define("VelcroPhysics.Extensions.PhysicsLogics.Explosion.RealExplosion",{inherits:[VelcroPhysics.Extensions.PhysicsLogics.PhysicsLogicBase.PhysicsLogic],statics:{fields:{MaxEdgeOffset:0},ctors:{init:function(){this.MaxEdgeOffset=.0349065848}}},fields:{_data:null,_rdc:null,EdgeRatio:0,IgnoreWhenInsideShape:!1,MaxAngle:0,MaxShapes:0,MinRays:0},ctors:{init:function(){this._data=new(System.Collections.Generic.List$1(VelcroPhysics.Extensions.PhysicsLogics.PhysicsLogicBase.ShapeData).ctor);this.EdgeRatio=.025;this.IgnoreWhenInsideShape=!1;this.MaxAngle=.209439516;this.MaxShapes=100;this.MinRays=5},ctor:function(world){this.$initialize();VelcroPhysics.Extensions.PhysicsLogics.PhysicsLogicBase.PhysicsLogic.ctor.call(this,world,VelcroPhysics.Extensions.PhysicsLogics.PhysicsLogicBase.PhysicsLogicType.Explosion);this._rdc=new VelcroPhysics.Extensions.PhysicsLogics.Explosion.RayDataComparer;this._data=new(System.Collections.Generic.List$1(VelcroPhysics.Extensions.PhysicsLogics.PhysicsLogicBase.ShapeData).ctor)}},methods:{Activate:function(pos,radius,maxForce){var aabb,i,ps,cs,v,vec,j,rayMissed,i1,fixture,midpt,iplus,laPos,la,d,fi,lastPos,last,i2,offset,j1,x,f,ri,ro,impulse,vectImp,i3,fix,shape,vectImp1;pos={v:pos};aabb={v:new VelcroPhysics.Shared.AABB};aabb.v.LowerBound=Microsoft.Xna.Framework.Vector2.op_Addition(pos.v.$clone(),new Microsoft.Xna.Framework.Vector2.$ctor2(-radius,-radius));aabb.v.UpperBound=Microsoft.Xna.Framework.Vector2.op_Addition(pos.v.$clone(),new Microsoft.Xna.Framework.Vector2.$ctor2(radius,radius));var shapes=System.Array.init(this.MaxShapes,null,VelcroPhysics.Dynamics.Fixture),containedShapes=System.Array.init(5,null,VelcroPhysics.Dynamics.Fixture),exit=!1,shapeCount=0,containedShapeCount=0;if(this.World.QueryAABB$1(Bridge.fn.bind(this,function(fixture){if(fixture.TestPoint(pos)){if(this.IgnoreWhenInsideShape)return exit=!0,!1;containedShapes[Bridge.identity(containedShapeCount,containedShapeCount=containedShapeCount+1|0)]=fixture}else shapes[Bridge.identity(shapeCount,shapeCount=shapeCount+1|0)]=fixture;return!0}),aabb),exit)return new(System.Collections.Generic.Dictionary$2(VelcroPhysics.Dynamics.Fixture,Microsoft.Xna.Framework.Vector2));var exploded=new(System.Collections.Generic.Dictionary$2(VelcroPhysics.Dynamics.Fixture,Microsoft.Xna.Framework.Vector2)),vals=System.Array.init(new Float32Array(Bridge.Int.mul(shapeCount,2)),System.Single),valIndex=0;for(i=0;i<shapeCount;i=i+1|0)if(cs=Bridge.as(shapes[i].Shape,VelcroPhysics.Collision.Shapes.CircleShape),cs!=null?(v=new VelcroPhysics.Shared.Vertices.ctor,vec=Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.Zero.$clone(),new Microsoft.Xna.Framework.Vector2.$ctor2(cs.Radius,0)),v.add(vec.$clone()),vec=Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.Zero.$clone(),new Microsoft.Xna.Framework.Vector2.$ctor2(0,cs.Radius)),v.add(vec.$clone()),vec=Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.Zero.$clone(),new Microsoft.Xna.Framework.Vector2.$ctor2(-cs.Radius,cs.Radius)),v.add(vec.$clone()),vec=Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.Zero.$clone(),new Microsoft.Xna.Framework.Vector2.$ctor2(0,-cs.Radius)),v.add(vec.$clone()),ps=new VelcroPhysics.Collision.Shapes.PolygonShape.$ctor2(v,0)):ps=Bridge.as(shapes[i].Shape,VelcroPhysics.Collision.Shapes.PolygonShape),shapes[i].Body.BodyType===VelcroPhysics.Dynamics.BodyType.Dynamic&&ps!=null){var toCentroid=Microsoft.Xna.Framework.Vector2.op_Subtraction(shapes[i].Body.GetWorldPoint(ps.MassData.Centroid.$clone()),pos.v.$clone()),angleToCentroid=Math.atan2(toCentroid.Y,toCentroid.X),min=340282347e30,max=-340282347e30,minAbsolute=0,maxAbsolute=0;for(j=0;j<ps.Vertices.Count;j=j+1|0){var toVertex=Microsoft.Xna.Framework.Vector2.op_Subtraction(shapes[i].Body.GetWorldPoint(ps.Vertices.getItem(j).$clone()),pos.v.$clone()),newAngle=Math.atan2(toVertex.Y,toVertex.X),diff=newAngle-angleToCentroid;(diff=(diff-Microsoft.Xna.Framework.MathHelper.Pi)%6.28318548,diff<0&&(diff+=6.28318548),diff-=Microsoft.Xna.Framework.MathHelper.Pi,Math.abs(diff)>Microsoft.Xna.Framework.MathHelper.Pi)||(diff>max&&(max=diff,maxAbsolute=newAngle),diff<min&&(min=diff,minAbsolute=newAngle))}vals[valIndex]=minAbsolute;valIndex=valIndex+1|0;vals[valIndex]=maxAbsolute;valIndex=valIndex+1|0}for(System.Array.sort(vals,0,valIndex,this._rdc),this._data.clear(),rayMissed=!0,i1=0;i1<valIndex;i1=i1+1|0)if(fixture={v:null},iplus=i1===(valIndex-1|0)?0:i1+1|0,vals[i1]!==vals[iplus]){midpt=i1===(valIndex-1|0)?vals[0]+6.28318548+vals[i1]:vals[i1+1|0]+vals[i1];midpt=midpt/2;var p1=pos.v.$clone(),p2=Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(radius,new Microsoft.Xna.Framework.Vector2.$ctor2(Math.cos(midpt),Math.sin(midpt))),pos.v.$clone()),hitClosest={v:!1};if(this.World.RayCast$1(function($me,hitClosest,fixture){return Bridge.fn.bind($me,function(f,p,n,fr){var body=f.Body;return this.IsActiveOn(body)?(hitClosest.v=!0,fixture.v=f,fr):0})}(this,hitClosest,fixture),p1.$clone(),p2.$clone()),hitClosest.v&&fixture.v.Body.BodyType===VelcroPhysics.Dynamics.BodyType.Dynamic){if(System.Linq.Enumerable.from(this._data).any()&&Bridge.referenceEquals(System.Linq.Enumerable.from(this._data).last().Body,fixture.v.Body)&&!rayMissed?(laPos=this._data.Count-1|0,la=this._data.getItem(laPos).$clone(),la.Max=vals[iplus],this._data.setItem(laPos,la.$clone())):(d=new VelcroPhysics.Extensions.PhysicsLogics.PhysicsLogicBase.ShapeData,d.Body=fixture.v.Body,d.Min=vals[i1],d.Max=vals[iplus],this._data.add(d.$clone())),this._data.Count>1&&i1===(valIndex-1|0)&&Bridge.referenceEquals(System.Linq.Enumerable.from(this._data).last().Body,System.Linq.Enumerable.from(this._data).first().Body)&&System.Linq.Enumerable.from(this._data).last().Max===System.Linq.Enumerable.from(this._data).first().Min)for(fi=this._data.getItem(0).$clone(),fi.Min=System.Linq.Enumerable.from(this._data).last().Min,this._data.removeAt(this._data.Count-1|0),this._data.setItem(0,fi.$clone());System.Linq.Enumerable.from(this._data).first().Min>=System.Linq.Enumerable.from(this._data).first().Max;)fi.Min-=6.28318548,this._data.setItem(0,fi.$clone());for(lastPos=this._data.Count-1|0,last=this._data.getItem(lastPos).$clone();this._data.Count>0&&System.Linq.Enumerable.from(this._data).last().Min>=System.Linq.Enumerable.from(this._data).last().Max;)last.Min=System.Linq.Enumerable.from(this._data).last().Min-6.28318548,this._data.setItem(lastPos,last.$clone());rayMissed=!1}else rayMissed=!0}for(i2=0;i2<this._data.Count;i2=i2+1|0)if(this.IsActiveOn(this._data.getItem(i2).$clone().Body)){var arclen=this._data.getItem(i2).$clone().Max-this._data.getItem(i2).$clone().Min,first=Microsoft.Xna.Framework.MathHelper.Min$1(VelcroPhysics.Extensions.PhysicsLogics.Explosion.RealExplosion.MaxEdgeOffset,this.EdgeRatio*arclen),insertedRays=Bridge.Int.clip32(Math.ceil((arclen-2*first-(this.MinRays-1|0)*this.MaxAngle)/this.MaxAngle));for(insertedRays<0&&(insertedRays=0),offset=(arclen-first*2)/(this.MinRays+insertedRays-1),j1=this._data.getItem(i2).$clone().Min+first;j1<this._data.getItem(i2).$clone().Max||VelcroPhysics.Utilities.MathUtils.FloatEquals$1(j1,this._data.getItem(i2).$clone().Max,.0001);j1+=offset){var p11=pos.v.$clone(),p21=Microsoft.Xna.Framework.Vector2.op_Addition(pos.v.$clone(),Microsoft.Xna.Framework.Vector2.op_Multiply$2(radius,new Microsoft.Xna.Framework.Vector2.$ctor2(Math.cos(j1),Math.sin(j1)))),hitpoint={v:Microsoft.Xna.Framework.Vector2.Zero.$clone()},minlambda=340282347e30,fl=this._data.getItem(i2).$clone().Body.FixtureList;for(x=0;x<fl.Count;x=x+1|0)f=fl.getItem(x),ri={v:new VelcroPhysics.Collision.RayCast.RayCastInput},ri.v.Point1=p11.$clone(),ri.v.Point2=p21.$clone(),ri.v.MaxFraction=50,ro={v:new VelcroPhysics.Collision.RayCast.RayCastOutput},f.RayCast(ro,ri,0)&&minlambda>ro.v.Fraction&&(minlambda=ro.v.Fraction,hitpoint.v=Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(ro.v.Fraction,p21.$clone()),Microsoft.Xna.Framework.Vector2.op_Multiply$2(1-ro.v.Fraction,p11.$clone()))),impulse=arclen/(this.MinRays+insertedRays|0)*maxForce*180/Microsoft.Xna.Framework.MathHelper.Pi*(1-Math.min(1,minlambda)),vectImp={v:Microsoft.Xna.Framework.Vector2.op_Multiply$2(Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse,new Microsoft.Xna.Framework.Vector2.$ctor2(Math.cos(j1),Math.sin(j1))),Microsoft.Xna.Framework.Vector2.op_UnaryNegation(ro.v.Normal.$clone())),new Microsoft.Xna.Framework.Vector2.$ctor2(Math.cos(j1),Math.sin(j1)))},this._data.getItem(i2).$clone().Body.ApplyLinearImpulse$3(vectImp,hitpoint),exploded.containsKey(f)?exploded.set(f,Microsoft.Xna.Framework.Vector2.op_Addition(exploded.get(f).$clone(),vectImp.v.$clone())):exploded.add(f,vectImp.v.$clone()),minlambda>1&&(hitpoint.v=p21.$clone())}}for(i3=0;i3<containedShapeCount;i3=i3+1|0)if(fix=containedShapes[i3],this.IsActiveOn(fix.Body)){var impulse1=this.MinRays*maxForce*180/Microsoft.Xna.Framework.MathHelper.Pi,hitPoint={v:new Microsoft.Xna.Framework.Vector2},circShape=Bridge.as(fix.Shape,VelcroPhysics.Collision.Shapes.CircleShape);circShape!=null?hitPoint.v=fix.Body.GetWorldPoint(circShape.Position.$clone()):(shape=Bridge.as(fix.Shape,VelcroPhysics.Collision.Shapes.PolygonShape),hitPoint.v=fix.Body.GetWorldPoint(shape.MassData.Centroid.$clone()));vectImp1={v:Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse1,Microsoft.Xna.Framework.Vector2.op_Subtraction(hitPoint.v.$clone(),pos.v.$clone()))};fix.Body.ApplyLinearImpulse$3(vectImp1,hitPoint);exploded.containsKey(fix)||exploded.add(fix,vectImp1.v.$clone())}return exploded}}});Bridge.define("VelcroPhysics.Extensions.PhysicsLogics.Explosion.SimpleExplosion",{inherits:[VelcroPhysics.Extensions.PhysicsLogics.PhysicsLogicBase.PhysicsLogic],fields:{Power:0},ctors:{ctor:function(world){this.$initialize();VelcroPhysics.Extensions.PhysicsLogics.PhysicsLogicBase.PhysicsLogic.ctor.call(this,world,VelcroPhysics.Extensions.PhysicsLogics.PhysicsLogicBase.PhysicsLogicType.Explosion);this.Power=1}},methods:{Activate:function(pos,radius,force,maxForce){maxForce===void 0&&(maxForce=340282347e30);var affectedBodies=new(System.Collections.Generic.HashSet$1(VelcroPhysics.Dynamics.Body).ctor),aabb={v:new VelcroPhysics.Shared.AABB};return aabb.v.LowerBound=Microsoft.Xna.Framework.Vector2.op_Subtraction(pos.$clone(),new Microsoft.Xna.Framework.Vector2.$ctor1(radius)),aabb.v.UpperBound=Microsoft.Xna.Framework.Vector2.op_Addition(pos.$clone(),new Microsoft.Xna.Framework.Vector2.$ctor1(radius)),this.World.QueryAABB$1(function(fixture){return Microsoft.Xna.Framework.Vector2.Distance(fixture.Body.Position.$clone(),pos.$clone())<=radius&&(affectedBodies.contains(fixture.Body)||affectedBodies.add(fixture.Body)),!0},aabb),this.ApplyImpulse(pos.$clone(),radius,force,maxForce,affectedBodies)},ApplyImpulse:function(pos,radius,force,maxForce,overlappingBodies){var $t,forces=new(System.Collections.Generic.Dictionary$2(VelcroPhysics.Dynamics.Body,Microsoft.Xna.Framework.Vector2)),overlappingBody;$t=Bridge.getEnumerator(overlappingBodies);try{while($t.moveNext())if(overlappingBody=$t.Current,this.IsActiveOn(overlappingBody)){var distance=Microsoft.Xna.Framework.Vector2.Distance(pos.$clone(),overlappingBody.Position.$clone()),forcePercent=this.GetPercent(distance,radius),forceVector=Microsoft.Xna.Framework.Vector2.op_Subtraction(pos.$clone(),overlappingBody.Position.$clone());forceVector=Microsoft.Xna.Framework.Vector2.op_Multiply$1(forceVector.$clone(),1/Math.sqrt(forceVector.X*forceVector.X+forceVector.Y*forceVector.Y));forceVector=Microsoft.Xna.Framework.Vector2.op_Multiply$1(forceVector.$clone(),Microsoft.Xna.Framework.MathHelper.Min$1(force*forcePercent,maxForce));forceVector=Microsoft.Xna.Framework.Vector2.op_Multiply$1(forceVector.$clone(),-1);overlappingBody.ApplyLinearImpulse(forceVector.$clone());forces.add(overlappingBody,forceVector.$clone())}}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}return forces},GetPercent:function(distance,radius){var percent=Math.pow(1-(distance-radius)/radius,this.Power)-1;return isNaN(percent)?0:Microsoft.Xna.Framework.MathHelper.Clamp$1(percent,0,1)}}});Bridge.define("VelcroPhysics.Templates.Joints.DistanceJointTemplate",{inherits:[VelcroPhysics.Templates.Joints.JointTemplate],fields:{DampingRatio:0,FrequencyHz:0,Length:0,LocalAnchorA:null,LocalAnchorB:null},alias:["SetDefaults","VelcroPhysics$Templates$IDefaults$SetDefaults"],ctors:{init:function(){this.LocalAnchorA=new Microsoft.Xna.Framework.Vector2;this.LocalAnchorB=new Microsoft.Xna.Framework.Vector2},ctor:function(){this.$initialize();VelcroPhysics.Templates.Joints.JointTemplate.ctor.call(this,VelcroPhysics.Dynamics.Joints.JointType.Distance)}},methods:{SetDefaults:function(){this.Length=1}}});Bridge.define("VelcroPhysics.Templates.Joints.FrictionJointTemplate",{inherits:[VelcroPhysics.Templates.Joints.JointTemplate],fields:{LocalAnchorA:null,LocalAnchorB:null,MaxForce:0,MaxTorque:0},ctors:{init:function(){this.LocalAnchorA=new Microsoft.Xna.Framework.Vector2;this.LocalAnchorB=new Microsoft.Xna.Framework.Vector2},ctor:function(){this.$initialize();VelcroPhysics.Templates.Joints.JointTemplate.ctor.call(this,VelcroPhysics.Dynamics.Joints.JointType.Friction)}}});Bridge.define("VelcroPhysics.Templates.Joints.GearJointTemplate",{inherits:[VelcroPhysics.Templates.Joints.JointTemplate],fields:{JointA:null,JointB:null,Ratio:0},alias:["SetDefaults","VelcroPhysics$Templates$IDefaults$SetDefaults"],ctors:{ctor:function(){this.$initialize();VelcroPhysics.Templates.Joints.JointTemplate.ctor.call(this,VelcroPhysics.Dynamics.Joints.JointType.Gear)}},methods:{SetDefaults:function(){this.Ratio=1}}});Bridge.define("VelcroPhysics.Templates.Joints.MotorJointTemplate",{inherits:[VelcroPhysics.Templates.Joints.JointTemplate],fields:{AngularOffset:0,CorrectionFactor:0,LinearOffset:null,MaxForce:0,MaxTorque:0},alias:["SetDefaults","VelcroPhysics$Templates$IDefaults$SetDefaults"],ctors:{init:function(){this.LinearOffset=new Microsoft.Xna.Framework.Vector2},ctor:function(){this.$initialize();VelcroPhysics.Templates.Joints.JointTemplate.ctor.call(this,VelcroPhysics.Dynamics.Joints.JointType.Motor)}},methods:{SetDefaults:function(){this.MaxForce=1;this.MaxTorque=1;this.CorrectionFactor=.3}}});Bridge.define("VelcroPhysics.Templates.Joints.MouseJointTemplate",{inherits:[VelcroPhysics.Templates.Joints.JointTemplate],fields:{DampingRatio:0,FrequencyHz:0,MaxForce:0,Target:null},alias:["SetDefaults","VelcroPhysics$Templates$IDefaults$SetDefaults"],ctors:{init:function(){this.Target=new Microsoft.Xna.Framework.Vector2},ctor:function(){this.$initialize();VelcroPhysics.Templates.Joints.JointTemplate.ctor.call(this,VelcroPhysics.Dynamics.Joints.JointType.FixedMouse)}},methods:{SetDefaults:function(){this.FrequencyHz=5;this.DampingRatio=.7}}});Bridge.define("VelcroPhysics.Templates.Joints.PrismaticJointTemplate",{inherits:[VelcroPhysics.Templates.Joints.JointTemplate],fields:{EnableLimit:!1,EnableMotor:!1,LocalAnchorA:null,LocalAnchorB:null,LocalAxisA:null,LowerTranslation:0,MaxMotorForce:0,MotorSpeed:0,ReferenceAngle:0,UpperTranslation:0},alias:["SetDefaults","VelcroPhysics$Templates$IDefaults$SetDefaults"],ctors:{init:function(){this.LocalAnchorA=new Microsoft.Xna.Framework.Vector2;this.LocalAnchorB=new Microsoft.Xna.Framework.Vector2;this.LocalAxisA=new Microsoft.Xna.Framework.Vector2},ctor:function(){this.$initialize();VelcroPhysics.Templates.Joints.JointTemplate.ctor.call(this,VelcroPhysics.Dynamics.Joints.JointType.Prismatic)}},methods:{SetDefaults:function(){this.LocalAxisA=new Microsoft.Xna.Framework.Vector2.$ctor2(1,0)}}});Bridge.define("VelcroPhysics.Templates.Joints.PulleyJointTemplate",{inherits:[VelcroPhysics.Templates.Joints.JointTemplate],fields:{GroundAnchorA:null,GroundAnchorB:null,LengthA:0,LengthB:0,LocalAnchorA:null,LocalAnchorB:null,Ratio:0},alias:["SetDefaults","VelcroPhysics$Templates$IDefaults$SetDefaults"],ctors:{init:function(){this.GroundAnchorA=new Microsoft.Xna.Framework.Vector2;this.GroundAnchorB=new Microsoft.Xna.Framework.Vector2;this.LocalAnchorA=new Microsoft.Xna.Framework.Vector2;this.LocalAnchorB=new Microsoft.Xna.Framework.Vector2},ctor:function(){this.$initialize();VelcroPhysics.Templates.Joints.JointTemplate.ctor.call(this,VelcroPhysics.Dynamics.Joints.JointType.Pulley)}},methods:{SetDefaults:function(){this.GroundAnchorA=new Microsoft.Xna.Framework.Vector2.$ctor2(-1,1);this.GroundAnchorB=new Microsoft.Xna.Framework.Vector2.$ctor2(1,1);this.LocalAnchorA=new Microsoft.Xna.Framework.Vector2.$ctor2(-1,0);this.LocalAnchorB=new Microsoft.Xna.Framework.Vector2.$ctor2(1,0);this.Ratio=1;this.CollideConnected=!0}}});Bridge.define("VelcroPhysics.Templates.Joints.RevoluteJointTemplate",{inherits:[VelcroPhysics.Templates.Joints.JointTemplate],fields:{EnableLimit:!1,EnableMotor:!1,LocalAnchorA:null,LocalAnchorB:null,LowerAngle:0,MaxMotorTorque:0,MotorSpeed:0,ReferenceAngle:0,UpperAngle:0},ctors:{init:function(){this.LocalAnchorA=new Microsoft.Xna.Framework.Vector2;this.LocalAnchorB=new Microsoft.Xna.Framework.Vector2},ctor:function(){this.$initialize();VelcroPhysics.Templates.Joints.JointTemplate.ctor.call(this,VelcroPhysics.Dynamics.Joints.JointType.Revolute)}}});Bridge.define("VelcroPhysics.Templates.Joints.RopeJointTemplate",{inherits:[VelcroPhysics.Templates.Joints.JointTemplate],fields:{LocalAnchorA:null,LocalAnchorB:null,MaxLength:0},alias:["SetDefaults","VelcroPhysics$Templates$IDefaults$SetDefaults"],ctors:{init:function(){this.LocalAnchorA=new Microsoft.Xna.Framework.Vector2;this.LocalAnchorB=new Microsoft.Xna.Framework.Vector2},ctor:function(){this.$initialize();VelcroPhysics.Templates.Joints.JointTemplate.ctor.call(this,VelcroPhysics.Dynamics.Joints.JointType.Rope)}},methods:{SetDefaults:function(){this.LocalAnchorA=new Microsoft.Xna.Framework.Vector2.$ctor2(-1,0);this.LocalAnchorB=new Microsoft.Xna.Framework.Vector2.$ctor2(1,0)}}});Bridge.define("VelcroPhysics.Templates.Joints.WeldJointTemplate",{inherits:[VelcroPhysics.Templates.Joints.JointTemplate],fields:{DampingRatio:0,FrequencyHz:0,LocalAnchorA:null,LocalAnchorB:null,ReferenceAngle:0},ctors:{init:function(){this.LocalAnchorA=new Microsoft.Xna.Framework.Vector2;this.LocalAnchorB=new Microsoft.Xna.Framework.Vector2},ctor:function(){this.$initialize();VelcroPhysics.Templates.Joints.JointTemplate.ctor.call(this,VelcroPhysics.Dynamics.Joints.JointType.Weld)}}});Bridge.define("VelcroPhysics.Templates.Joints.WheelJointTemplate",{inherits:[VelcroPhysics.Templates.Joints.JointTemplate],fields:{DampingRatio:0,EnableMotor:!1,FrequencyHz:0,LocalAnchorA:null,LocalAnchorB:null,LocalAxisA:null,MaxMotorTorque:0,MotorSpeed:0},alias:["SetDefaults","VelcroPhysics$Templates$IDefaults$SetDefaults"],ctors:{init:function(){this.LocalAnchorA=new Microsoft.Xna.Framework.Vector2;this.LocalAnchorB=new Microsoft.Xna.Framework.Vector2;this.LocalAxisA=new Microsoft.Xna.Framework.Vector2},ctor:function(){this.$initialize();VelcroPhysics.Templates.Joints.JointTemplate.ctor.call(this,VelcroPhysics.Dynamics.Joints.JointType.Wheel)}},methods:{SetDefaults:function(){this.LocalAxisA=new Microsoft.Xna.Framework.Vector2.$ctor2(1,0);this.FrequencyHz=2;this.DampingRatio=.7}}});Bridge.define("VelcroPhysics.Tools.Triangulation.Delaunay.Sets.ConstrainedPointSet",{inherits:[VelcroPhysics.Tools.Triangulation.Delaunay.Sets.PointSet],fields:{_constrainedPointList:null,EdgeIndex:null},props:{TriangulationMode:{get:function(){return VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationMode.Constrained}}},alias:["TriangulationMode","VelcroPhysics$Tools$Triangulation$Delaunay$Triangulatable$TriangulationMode","PrepareTriangulation","VelcroPhysics$Tools$Triangulation$Delaunay$Triangulatable$PrepareTriangulation"],ctors:{$ctor1:function(points,index){this.$initialize();VelcroPhysics.Tools.Triangulation.Delaunay.Sets.PointSet.ctor.call(this,points);this.EdgeIndex=index},ctor:function(points,constraints){this.$initialize();VelcroPhysics.Tools.Triangulation.Delaunay.Sets.PointSet.ctor.call(this,points);this._constrainedPointList=new(System.Collections.Generic.List$1(VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationPoint).ctor);this._constrainedPointList.AddRange(constraints)}},methods:{PrepareTriangulation:function(tcx){var $t,$t1,p1,p2,iterator,i;if(VelcroPhysics.Tools.Triangulation.Delaunay.Sets.PointSet.prototype.PrepareTriangulation.call(this,tcx),this._constrainedPointList!=null)for(iterator=this._constrainedPointList.GetEnumerator();iterator.moveNext();)p1=iterator.Current,iterator.moveNext(),p2=iterator.Current,tcx.NewConstraint(p1,p2);else for(i=0;i<this.EdgeIndex.length;i=i+2|0)tcx.NewConstraint(System.Array.getItem(this.Points,($t=this.EdgeIndex)[i],VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationPoint),System.Array.getItem(this.Points,($t1=this.EdgeIndex)[i+1|0],VelcroPhysics.Tools.Triangulation.Delaunay.TriangulationPoint))},isValid:function(){return!0}}});Bridge.define("VelcroPhysics.Extensions.Controllers.Wind.SimpleWindForce",{inherits:[VelcroPhysics.Extensions.Controllers.Wind.AbstractForceController],fields:{Direction:null,Divergence:0,IgnorePosition:!1},ctors:{init:function(){this.Direction=new Microsoft.Xna.Framework.Vector2}},methods:{ApplyForce:function(dt,strength){var $t,body,decayMultiplier,forceVector,strengthVariation;$t=Bridge.getEnumerator(this.World.BodyList);try{while($t.moveNext())body=$t.Current,decayMultiplier=this.GetDecayMultiplier(body),decayMultiplier!==0&&(forceVector=new Microsoft.Xna.Framework.Vector2,this.ForceType===VelcroPhysics.Extensions.Controllers.Wind.AbstractForceController.ForceTypes.Point?forceVector=Microsoft.Xna.Framework.Vector2.op_Subtraction(body.Position.$clone(),this.Position.$clone()):(this.Direction.Normalize(),forceVector=this.Direction.$clone(),forceVector.Length()===0&&(forceVector=new Microsoft.Xna.Framework.Vector2.$ctor2(0,1))),this.Variation!==0?(strengthVariation=this.Randomize.NextDouble()*Microsoft.Xna.Framework.MathHelper.Clamp$1(this.Variation,0,1),forceVector.Normalize(),body.ApplyForce(Microsoft.Xna.Framework.Vector2.op_Multiply$1(Microsoft.Xna.Framework.Vector2.op_Multiply$1(Microsoft.Xna.Framework.Vector2.op_Multiply$1(forceVector.$clone(),strength),decayMultiplier),strengthVariation))):(forceVector.Normalize(),body.ApplyForce(Microsoft.Xna.Framework.Vector2.op_Multiply$1(Microsoft.Xna.Framework.Vector2.op_Multiply$1(forceVector.$clone(),strength),decayMultiplier))))}finally{Bridge.is($t,System.IDisposable)&&$t.System$IDisposable$Dispose()}}}})});